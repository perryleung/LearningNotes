# 陈同学推荐系列

## 1.   1-简单-两数之和
**简单**
- 题目描述
  给定一个整数数组 nums?和一个整数目标值 target，请你在该数组中找出`和为目标值`的那`两个`整数，并返回它们的数组下标。
  你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

- 实例1
  输入：nums = [2,7,11,15], target = 9
  输出：[0,1]
  解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
- 实例2
  输入：nums = [3,2,4], target = 6
  输出：[1,2]
- 实例3
  输入：nums = [3,3], target = 6
	输出：[0,1]

- 提示
	2 <= nums.length <= 10^3
	-10^9 <= nums[i] <= 10^9
	-10^9 <= target <= 10^9
	只会存在一个有效答案

- 思路：暴力、哈希、排序双指针（yyds）

暴力法：
	无论如何都要想到暴力法，因为这样的题目绝大多数都是有暴力而言
	思路：
	从 i = 0 开始遍历 nums[i]
	然后在 j = i + 1 开始比较if(nums[i] + nums[j] == target)

```c++
// 暴力法 O(n^2)
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        vector<int> res;
        if(nums.size()==0)
            return res;
        for (int i = 0; i < nums.size(); i++)
        {
            for (int j = i + 1; j < nums.size(); j++)
            {
                if(nums[i] + nums[j] == target)
                {
                    res.push_back(i);
                    res.push_back(j);
                    return res;
                }
            }
        }
        return res;
    }
}
```

哈希表法：
	刷了这么多题，哈希表其实可以作为常用的 “思维武器” 之一
    v1思路：
	1.首先遍历nums数组，然后用数字映射索引：
		unordered_map<int, int> hash; hash[nums[i]] = i；
	2.然后遍历数组，判断
		int other = target - nums[i];
		if (m.count(other) && m[other] != i)
	v2思路：
	直接遍历数组nums，并为之判断 `一步到位`
		if(hash.count(target-nums[i]))
			存在则结果是 i, hash[target-nums[i]]
		else
			hash[nums[i]] = i;
```c++
// hash v1
vector<int> twoSum(vector<int>& nums, int target) {
	vector<int> res;
	if(nums.size()==0)
		return res;
	unordered_map<int, int> m;
	for (int i = 0; i < nums.size(); i++)
		m[nums[i]] = i;
	for (int i = 0; i < nums.size(); i++) {
		int other = target - nums[i];
		if (m.count(other) && m[other] != i)
		//防止重复使用，[3,2,4]&6 ->not [0, 0] but[1,2]
		{
			res.push_back(i);
			res.push_back(m[other]);
			return res;
		}
	}
	return res;
}
// hash v2	进阶版
vector<int> twoSum(vector<int>& nums, int target) {
	unordered_map<int, int> m;
	vector<int> result;
	for (int i = 0; i < nums.size(); i++){
		if(m.find(target-nums[i]) == m.end()){
			m[nums[i]] = i;
		}else{
			result.push_back(m[target - nums[i]]);
			result.push_back(i);
			break;
		}
	}
	return result;
}
```

## 2.   2-中等-两数相加
**简单**
- 题目描述
  给你两个`非空`的链表，表示两个非负的整数。它们每位数字都是按照`逆序`的方式存储的，并且每个节点只能存储`一位`数字。
	请你将两个数相加，并以相同形式返回一个表示和的链表。
	你可以假设除了数字 0 之外，这两个数都不会以 0?开头。

- 示例
  输入：l1 = [2,4,3], l2 = [5,6,4]
	输出：[7,0,8]
	解释：342 + 465 = 807.

	输入：l1 = [0], l2 = [0]
	输出：[0]

	输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
	输出：[8,9,9,9,0,0,0,1]

- 思路：双指针 && sum + carry
  要是有求和的需求，一定要想到`sum + carry`
  要注意两个指针有可能一个指针先走完的情况
  先用一个数组来存储了结果，最后再用链表串起来返回结果

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* p1 = l1;
        ListNode* p2 = l2;
        vector<int> res;
        int val1 = 0;	// sum
        int val2 = 0;	// carry
        while(p1 && p2) {
            int tmp = p1->val + p2->val + val2;
            val1 = tmp % 10;
            val2 = tmp / 10;
            res.push_back(val1);
            p1 = p1->next;
            p2 = p2->next;
        }
        while(p1) {
            int tmp = p1->val + val2;
            val1 = tmp % 10;
            val2 = tmp / 10;
            res.push_back(val1);
            p1 = p1->next;
        }
        while(p2) {
            int tmp = p2->val + val2;
            val1 = tmp % 10;
            val2 = tmp / 10;
            res.push_back(val1);
            p2 = p2->next;
        }
        if(val2 != 0)
            res.push_back(val2);
        ListNode* ans = new ListNode(res[0]);
        ListNode* tmp = ans;
        for(int i = 1; i < res.size(); i++) {
            ListNode* node = new ListNode(res[i]);
            tmp->next = node;
            tmp = node;
        }
        return ans;
    }
};
```

## 3.   3-中等-无重复字符串的最长子串
**中等**
- 题目描述
  	给定一个字符串，请你找出其中不含有重复字符的``最长子串``的长度。

- 示例:
	输入: s = "abcabcbb"
	输出: 3 
	解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。

	输入: s = "bbbbb"
	输出: 1
	解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。

	输入: s = "pwwkew"
	输出: 3
	解释: 因为无重复字符的最长子串是?"wke"，所以其长度为 3。
	?    请注意，你的答案必须是``子串``的长度，"pwke"?是一个子序列，不是子串。

	输入: s = ""
	输出: 0
?
- 提示：
	0 <= s.length <= 5 * 104
	s?由英文字母、数字、符号和空格组成

- 思路：滑动窗口，这种在字符串内找子串子序列的都是用滑动窗口
  1. 用hash<char, int>来表示窗口window，初始化left=right=0索引
  2. 每次扩展一次就right++，并window[s[right]]++
  3. 若window[s[right]] > 1则缩短窗口，left++	// 因为要无重复子串
  4. 在缩短时，window[s[left]]--
  5. 缩短完成后，更新长度len = right - left 

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int sz = s.size();
        if(sz == 0) return 0;
        if(sz == 1) return 1;
        int len = 0, l = 0, r = 0;
        unordered_map<char, int> window;
        while(r < sz) {		// 注意判断条件
            char c = s[r];
            r++;
            window[c]++;
            while(window[c] > 1) {
                char toDelete = s[l];
                l++;
                window[toDelete]--;
            }
            if(len < r - l)
                len = r - l;
        }
        return len;
    }
};
```

## 4.   5-中等-最长回文子串
**中等**
- 题目描述
	给你一个字符串 s，找到 s 中最长的回文子串。

- 示例：
	输入：s = "babad"
	输出："bab"
	解释："aba" 同样是符合题意的答案。

	输入：s = "cbbd"
	输出："bb"

	输入：s = "a"
	输出："a"

	输入：s = "ac"
	输出："a"

- 提示：
	1 <= s.length <= 1000
	s 仅由数字和英文字母（大写和/或小写）组成

- 思路：遍历暴力法
	有两种情况需要注意：奇数个回文字符`aba`，偶数个回文字符`abba`
	string s1 = isPalindrome(s, i, i);		// 以自我为中心散开
    string s2 = isPalindrome(s, i, i + 1);
	
```c++
class Solution {
public:
    string longestPalindrome(string s) {
        string res;
        for (int i = 0; i < s.size(); i++) {
            string s1 = isPalindrome(s, i, i);		// 奇数个回文字符
            string s2 = isPalindrome(s, i, i + 1);	// 偶数个回文字符
            res = res.size() > s1.size() ? res : s1;// 比较大小结果
            res = res.size() > s2.size() ? res : s2;
        }
        return res;
    }
    string isPalindrome(const string& s, int l, int r) {
        while (l >= 0 && r < s.size() && s[l] == s[r]) {
			// 从中间开始扩散看是否相等
            l--;
            r++;
        }
        return s.substr(l + 1, r - l - 1);
    }
};
```

## 5.   7-简单-整数反转
**中等**
- 题目描述
    给你一个 32 位的有符号整数 x ，返回 x 中每位上的数字反转后的结果。
    如果反转后整数超过 32 位的有符号整数的范围?[?231,? 231?? 1] ，就返回 0。
    假设环境不允许存储 64 位整数（有符号或无符号）。
?
- 示例：
    输入：x = 123
    输出：321

    输入：x = -123
    输出：-321

    输入：x = 120
    输出：21

    输入：x = 0
    输出：0
    ?
- 提示：
    -2^31 <= x <= 2^31 - 1
    2^31 - 1 = 2147483647,
    -2^31 = -2147483648

- 思路：
    注意溢出问题，只能一个个位数遍历，`不要忽略提示`
    while(x) {res = res * 10 + x % 10; x /= 10;}


```c++
class Solution {
public:
    int reverse(int x) {
        int res = 0;
        while(x != 0) {
            /* if(res > INT_MAX / 10 || res < INT_MIN / 10)
                return 0; */
            int tmp = x % 10;   // 取最后一位
            // 判断下面是否溢出
            if(res > INT_MAX / 10 || res == INT_MAX / 10 && tmp > 7)
                return 0;
            if(res < INT_MIN / 10 || res == INT_MIN / 10 && tmp < -8)
                return 0;
            res = res * 10 + tmp;
            x /= 10;
        }
        return res;
    }
};
// or
int reverse(int x) {
    long res = 0;   // long 型才能有n > INT_MAX || n < INT_MIN
    while(x) {
        res = res * 10 + x % 10;
        x /= 10;
    }
    return n > INT_MAX || n < INT_MIN ? 0 : (int)n; //
}
```

## 6.   9-简单-回文数
**中等**
- 题目描述   
    给你一个整数 x ，如果 x 是一个回文整数，返回 ture ；否则，返回 false 。
    回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，121 是回文，而 123 不是。

- 示例：
    输入：x = 121
    输出：true

    输入：x = -121
    输出：false
    解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。

    输入：x = 10
    输出：false
    解释：从右向左读, 为 01 。因此它不是一个回文数。

    输入：x = -101
    输出：false
 
- 提示：
    -2^31 <= x <= 2^31 - 1

- 思路：分类讨论，并且要注意在反转时可能出现`溢出问题`
    负数肯定不是；0是；
    剩下的正数进行判断：先把x倒置表示成res，比较二者是否相同，相同则返回true，否则false。

```c++
class Solution {
public:
    bool isPalindrome(int x) {
        if(x<0) return false;
        if(x==0) return true;
        long res=0; // 解决溢出问题的关键时定义 long
        int y=x;
        while(x){
            res=res*10+x%10;
            x=x/10;
        }
        return (int)res==y?true:false;
    }
};
// or
bool isPalindrome(int x){
    return (x >= 0 && x == reverse(x));
}
int reverse(int x){
    int y(0);   // 这里定义成long 就好
    int n;
    while(x!=0){
        n = x % 10;
        if(y > INT_MAX / 10 - n){
            return x - 1;
        }
        y = y * 10 + n;
        x /= 10;
    }
    return y;
}

```

## 7.   11-中等-盛最多水的容器
**中等** `技巧`
- 题目描述
    给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点?(i,?ai) 。在坐标内画 n 条垂直线，垂直线 i?的两个端点分别为?(i,?ai) 和 (i, 0) 。找出其中的两条线，使得它们与?x?轴共同构成的容器可以容纳最多的水。
    说明：你不能倾斜容器。

- 示例

    输入：[1,8,6,2,5,4,8,3,7]
    输出：49 
    解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为?49。

    输入：height = [1,1]
    输出：1

    输入：height = [4,3,2,1,4]
    输出：16

    输入：height = [1,2,1]
    输出：2
    ?
- 提示：
    n = height.length
    2 <= n <= 3 * 10^4
    0 <= height[i] <= 3 * 10^4

- 思路：双指针法（指头指尾）
    双指针，每次移动较小的那一边，才有可能获得更大的容量，`因为水高度取决于短的一端`，如果移动较大的那一端，底变小，容量不可能变大

```c++
class Solution {
public:
    int maxArea(vector<int>& height) {
        int res = 0;
        int l = 0;
        int r = height.size() - 1;
        while(l < r) {
            int area = (r - l) * min(height[l], height[r]);
            res = max(area, res);
            if(height[l] < height[r])
                l++;
            else
                r--;
        }
        return res;
    }
};
```

## 8.   14-简单-最长公共前缀
**简单**
- 题目描述
    编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 ""。

- 示例：
    输入：strs = ["flower","flow","flight"]
    输出："fl"

    输入：strs = ["dog","racecar","car"]
    输出：""
    解释：输入不存在公共前缀。
?
- 提示：
    0 <= strs.length <= 200
    0 <= strs[i].length <= 200
    strs[i] 仅由小写英文字母组成

- 思路：暴力法，一个个对比

```c++
string longestCommonPrefix(vector<string>& strs) {
    if (strs.size() <= 0) return "";
    if (strs.size() == 1) return strs[0];
    //if (strs[0].size() == 0) return "";
    for (int index = 0;  ; index++){
        char ch=strs[0][index]; // 以第一个str为基准，慢慢对比每一个index上的字符
        for (int i = 0; i < strs.size(); i++) {
            if (strs[i].empty()) return ""; // 如果有空字符则返回
            if (ch != strs[i][index]) return strs[0].substr(0, index);
            if (strs[i].size() == index) return strs[i];  //边界 
        }
    }
}
// or
string longestCommonPrefix(vector<string>& strs) {
    string word;
    if(strs.size()<=0)
        return word;
    for (int i = 0; i <= strs[0].size();i++){
        string w = strs[0].substr(0, i);//从第0个开始取i个
        bool match = true;
        for (int j = 1; j < strs.size();j++){
            if(i>strs[j].size() || w != strs[j].substr(0,i)){
                match = false;
                break;
            }
        }
        if(!match){
            return word;
        }
        word = w;
    }
    return word;
}
```

## 9.   15-中等-三数之和
**中等**
- 题目描述
    给你一个包含 n 个整数的数组?nums，判断?nums?中是否存在三个元素 a，b，c ，使得?a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。

    注意：答案中不可以包含重复的三元组。

- 示例：
    输入：nums = [-1,0,1,2,-1,-4]
    输出：[[-1,-1,2],[-1,0,1]]

    输入：nums = []
    输出：[]

    输入：nums = [0]
    输出：[]
?
- 提示：
    0 <= nums.length <= 3000
    -10^5 <= nums[i] <= 10^5
 
//做过两数之和的话，这题就很简单了。a+b+c =0，就相当于a+b = -c，按照两数之和为-c的做法来做就可以了。一顿操作猛如虎，点击提交超时了！

- 思路：
    1. 先sort，排序是解决`求和`这类问题的关键武器之一~~
    2. 遍历，遍历到有>=0的元素就break，因为加上后面的都只会大于0
    3. 注意要去除重复的元素，用过了就不能用了

```c++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> res;
        if(nums.size() < 3)
            return res;
        std::sort(nums.begin(), nums.end());
        for (int i = 0; i < nums.size(); i++) {
            int target = -nums[i];
            int front = i + 1;
            int back = nums.size() - 1;
            while(front < back) {
                if(nums[front] + nums[back] < target)
                    front++;
                else if(nums[front] + nums[back] > target)
                    back--;
                else {
                    // 找到了一种组合方式
                    vector<int> tmp(3,0);
                    tmp[0] = nums[i];
                    tmp[1] = nums[front];
                    tmp[2] = nums[back];
                    res.push_back(tmp);
                    // 保持target不变，再去尝试找其他组合
                    while(front < back && tmp[1]== nums[front])
                        front++;
                    while(front < back && tmp[2] == nums[back])
                        back--;
                }
           }
           //下面这里需要注意，这是为了去除重复的三元组答案
           // 输入：    nums = [-1,0,1,2,-1,-1,-4]
           // sort后：  nums = [-4,-1,-1,-1,0,1,2]
           // 输出：[[-1,-1,2],[-1,0,1]] 
           // 若没有如下则可能：[[-1,-1,2],[-1,-1,2],[-1,0,1],[-1,0,1]]
           while(i+1 < nums.size() && nums[i+1]==nums[i])
               i++;
        }
        return res;
    }
};
```

## 10.  16-中等-最接近的三数之和
**简单**
- 题目描述
    给定一个包括?n 个整数的数组?nums?和 一个目标值?target。找出?nums?中的三个整数，使得它们的和与?target?最接近。返回这三个数的和。假定每组输入只存在唯一答案。

- 示例
    输入：nums = [-1,2,1,-4], target = 1
    输出：2
    解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。
?
- 提示：
    3 <= nums.length <= 10^3
    -10^3?<= nums[i]?<= 10^3
    -10^4?<= target?<= 10^4

- 思路：排序、遍历：当前值+双指针
    1. 排序
    2. int l = i + 1, r = nums.size()-1;
    3. int tmp_sum = nums[i] + nums[l] + nums[r];
    4. 遍历的边界需要注意的是 0 ~ size() - 2，因为要加三个数

```c++
class Solution {
public:
    int threeSumClosest(vector<int>& nums, int target) {
        sort(nums.begin(), nums.end());
        int res = nums[1] + nums[2] + nums[0];
        for(int i = 0; i < nums.size() - 2; i++) {
            int s = i + 1;
            int e = nums.size() - 1;
            while(s < e) {
                int sum = nums[i] + nums[s] + nums[e];
                if(sum == target)   return 0;   // 直接返回节省时间
                if(abs(target - sum) < abs(target - res))
                    res = sum;
                if(target > sum)
                    s++;
                else if(target < sum)
                    e--;
                else
                    return sum;
            }
        }
        return res;
    }
};
```

## 11.  17-中等-电话号码的字母组合
**困难** `技巧`
- 题目描述
    给定一个仅包含数字?2-9?的字符串，返回所有它能表示的字母组合。答案可以按`任意顺序`返回。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

- 示例：

    输入：digits = "23"
    输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]

    输入：digits = ""
    输出：[]

    输入：digits = "2"
    输出：["a","b","c"]

- 提示：
    0 <= digits.length <= 4
    digits[i] 是范围 ['2', '9'] 的一个数字。

- 思路：dfs回溯 or 迭代较麻烦但符合正常逻辑，偏暴力

```c++
// dfs
class Solution {
public:
    unordered_map<char, string> table{
            {'0', " "}, {'1',"*"}, {'2', "abc"},
            {'3',"def"}, {'4',"ghi"}, {'5',"jkl"},
            {'6',"mno"}, {'7',"pqrs"},{'8',"tuv"},
            {'9',"wxyz"}};  
    vector<string> res;
    string str;

    vector<string> letterCombinations(string digits) {
        if(digits == "") return res;
        func(digits, 0);
        return res;
    }

    void func(string &digits, int k){
        if(str.size() == digits.size()){
            res.push_back(str);
            return;
        }
        // digits[k]->数字， table[数字]->字符
        string tmp = table[digits[k]];
        for(char w : tmp){
            str.push_back(w);   // str += w也可
            func(digits, k+1);
            str.pop_back();
        }
        return;
    }
};
```
```c++
// 迭代，时空都大
class Solution {
public:
    vector<string> sList={"","","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};
    vector<string> letterCombinations(string digits) {
        if(digits.size() == 0)
            return {};
        queue<string> q;    // 用来存储结果，慢慢读取数据来一个个组合
        for(int i = 0; i < digits.size(); i++) {
            int pos = digits[i] - '0';
            string tmpStr = sList[i];
            if(q.empty()) { // 第一次读入时为空
                string initStr;
                for(int j = 0; j < tmpStr.size(); j++) {
                    initStr = tmpStr[j];// 慢慢存入第一个字符串的一个个字符
                    q.push(initStr);
                }
            }else {         // 从第二次开始q不为空
                int sz = q.size();  // 一开始要记录组合的次数就是目前q的长度
                for(int j = 0; j < sz; j++) {
                    string tmp = q.front();
                    q.pop();    // 一个个提取出q的字符
                    for(int k = 0; k < tmpStr.size(); k++) {
                        q.push(tmp + tmpStr[k]);
                    }
                }
            }
        }
        vector<string> res;
        while(!q.empty()) {
            res.push_back(q.front());
            q.pop();
        }
        return res;
    }
};
```

## 12.  18-中等-四数之和
**中等**
- 题目描述
    给定一个包含?n 个整数的数组?nums?和一个目标值?target，判断?nums?中是否存在四个元素 a，b，c?和 d?，使得?a + b + c + d?的值与?target?相等？找出所有满足条件且不重复的四元组。

    注意：答案中不可以包含重复的四元组。

- 示例：
    给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。

    满足要求的四元组集合为：
    [
        [-1,  0, 0, 1],
        [-2, -1, 1, 2],
        [-2,  0, 0, 2]
    ]

- 思路：双指针
    1. 排序+双指针就是这类题的解法
    2. 要想使用双指针，前提是要去重加剪枝
    3. 去重的原因：如果当前的数是其中合适的答案的四元组值一，那么如果下一个数是重复，那么就会有重复的四元组答案
    4. 剪枝就是为了更快啦
    5. if(nums[i] + nums[i+1] + nums[i+2] + nums[i+3] > target) 说明sum太大了，排序数组中再遍历加下去也没有用
    6. if(nums[i] + nums[n-3] + nums[n-2] + nums[n-1] < target) 说明sum太小了，就连加最大的那三个值都不够，因此要i++

```c++
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        vector<vector<int> > res;
        int n = nums.size();
        if(n < 4)   return res;
        std::sort(nums.begin(), nums.end());        // 前提
        for(int i = 0; i < n - 3; i++) {
            if(i > 0 && nums[i] == nums[i-1])       // 去重 
                continue;
            if(nums[i] + nums[i+1] + nums[i+2] + nums[i+3] > target)    // 剪枝
                break;
            if(nums[i] + nums[n-3] + nums[n-2] + nums[n-1] < target)    //  剪枝
                continue;
            for(int j = i + 1; j < n - 2; j++) {
                if(j > i+1 && nums[j] == nums[j-1]) // 去重
                    continue;
                if(nums[j] + nums[j+1] + nums[j+2] > target - nums[i])  // 剪枝
                    break;
                if(nums[j] + nums[n-2] + nums[n-1] < target - nums[i])  // 剪枝
                    continue;
                int l = j + 1;
                int r = n - 1;
                while(l < r) {
                    if(nums[l] + nums[r] < target - nums[i]- nums[j])
                        l++;
                    else if(nums[l] + nums[r] > target - nums[i]- nums[j])
                        r--;
                    else {
                        res.push_back({nums[i], nums[j], nums[l], nums[r]});
                        l++;r--;
                        while(l < r && nums[l] == nums[l-1]) l++;
                        while(l < r && nums[r] == nums[r+1]) r--;
                    }
                }
            }
        }
        return res;
    }
};
```

## 13.  19-中等-删除链表的倒数第N个结点
**简单**
- 题目描述
    给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。
    进阶：你能尝试使用一趟扫描实现吗？

- 示例：
    输入：head = [1,2,3,4,5], n = 2
    输出：[1,2,3,5]

- 思路：快慢指针

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        if(!head)
            return nullptr;
        ListNode newHead(-1);
        newHead.next = head;
        ListNode *fast = &newHead;
        ListNode *slow = &newHead;
        int i = 0;
        while (i < n) {
            fast = fast->next;
            ++i;
        }
        while(fast->next) {
            fast = fast->next;
            slow = slow->next;
        }
        ListNode *tmp = slow->next;
        slow->next = tmp->next;
        delete tmp;
        tmp = nullptr;
        return newHead.next;//attention！！！
    }
};

// or 进阶的递归
class Solution {
public:
    int cur=0;
    ListNode* removeNthFromEnd(ListNode* head, int n) {
       if(!head) return NULL;
       head->next = removeNthFromEnd(head->next,n);
       cur++;
       if(n==cur) return head->next;    // 但那个结点的内存还在没有释放
       return head;
    }
};
```

## 14.  20-简单-有效的括号
**简单**
- 题目描述
    给定一个只包括 '('，')'，'{'，'}'，'['，']'?的字符串 s ，判断字符串是否有效。
    有效字符串需满足：左括号必须用相同类型的右括号闭合，左括号必须以正确的顺序闭合。

- 示例：
    输入：s = "()"
    输出：true

    输入：s = "()[]{}"
    输出：true

    输入：s = "(]"
    输出：false

    输入：s = "([)]"
    输出：false

    输入：s = "{[]}"
    输出：true
?
- 提示：
    1 <= s.length <= 104
    s 仅由括号 '()[]{}' 组成

- 思路：用栈，这种括号匹配问题一定要想到用栈
    1. 一个重要的点要想清楚：如果括号是有效的话，那么当右括号出现时其前面的一定是对应它的左括号！
    2. 定义一个栈，遇到左括号就放进去，遇到右括号就看看和栈顶的是否匹配，匹配失败则false


```c++
#include <iostream>
#include <string>
#include <stack>
using namespace std;

class Solution {
public:
    bool isValid(string s) {
        stack<char> st;
        for(char ch : s){
            if (ch == '(' || ch == '{' || ch == '[')
                st.push(ch);
            else if (ch == ')' || ch == '}' || ch == ']') {
                if(st.empty())
                    return false;
                else if (ch == ')' && st.top() == '(' || ch == '}' && st.top() == '{' || ch == ']' && st.top() == '[')
                    st.pop();
                else 
                    return false;
            }
        }
        return st.empty();  // 判断条件
    }
};
```

## 15.  21-简单-合并两个有序链表
**简单**
- 题目描述
    将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。?

- 示例
    输入：l1 = [1,2,4], l2 = [1,3,4]
    输出：[1,1,2,3,4,4]

    输入：l1 = [], l2 = []
    输出：[]

    输入：l1 = [], l2 = [0]
    输出：[0]

- 思路：
    1. /*merge two lists to the new list*/
    2. /*merge the 2nd list into 1st list*/

```c++
/*merge the 2nd list into 1st list*/
ListNode* mergeTwoLists0(ListNode* head1, ListNode* head2){
    ListNode *p1 = head1, *p2 = head2;
    static ListNode dummy(0);
    
    dummy.next = p1;
    ListNode *prev = &dummy;
    
    while(p1 && p2){
        if(p1->val < p2->val){
            prev = p1;
            p1 = p1->next;
        }else{
            prev->next = p2;
            p2 = p2->next;
            prev = prev->next;
            prev->next = p1;
        }
    }
    if(p2){
        prev->next = p2;
    }
    return dummy.next;
}
/*merge two lists to the new list*/
ListNode *mergeTwoLists1(ListNode *l1,ListNode *l2){
    ListNode *l = NULL, *p = NULL;

    while(l1!=NULL && l2 !=NULL){
        ListNode *n = NULL;
        if(l1->val < l2->val){
            n = l1;
            l1 = l1->next;
        }else{
            n = l2;
            l2 = l2->next;
        }
        if(l==NULL){
            l = p = n;
        }else{
            p->next = n;
            p = p->next;
        }
    }

    ListNode *rest = l1 ? l1 : l2;
    l = mergeTheRest(rest, l, p);
    return l;
}

```

## 16.  22-中等-括号生成
**中等**
- 题目描述
    数字 n?代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。

- 示例：
    输入：n = 3
    输出：["((()))","(()())","(())()","()(())","()()()"]

    输入：n = 1
    输出：["()"]

- 提示：
    1 <= n <= 8

- 思路：dfs
    1. n是代表了扩号的对数，那么左右括号都有各n个；
    2. 有效的方式是存在的左括号的数量永远不可能少于右扩号的数量
    3. 因此要分开来回溯，并且要左扩号先开始回
    4. 要判断一次结果的条件是左右扩号的数量都用完了
    
```c++
class Solution {
public:
    vector<string> res;
    string path;
    vector<string> generateParenthesis(int n) {
        if(n == 0)
            return {};
        traceBack(n, n);
        return res;
    }
    // left 和 right 分别代表了剩余可以用的左右扩号的数量
    void traceBack(int left, int right) {
        if(left > right)    // 有剩余的左括号数量不能多于右括号的数量
            return;
        if(left < 0 || right < 0)   // 返回条件之一
            return;
        if(left == 0 && right == 0) {
            res.push_back(path);
            return;
        }
        path.push_back('(');
        traceBack(left - 1, right);
        path.pop_back();
        path.push_back(')');
        traceBack(left, right - 1);
        path.pop_back();
    }
};
```

## 17.  24-中等-两两交换链表中的节点
**中等**
- 题目描述
    给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。
    你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

- 示例：
    输入：head = [1,2,3,4]
    输出：[2,1,4,3]

    输入：head = []
    输出：[]

    输入：head = [1]
    输出：[1]

- 思路：
    1. 递归：终止条件是空链表或没有只有一个节点，因为是两两交换，所以在一次递归操作中要两个操作节点；
    2. 迭代：创建一个dummy头节点来记录pre，这是对链表操作的基本功

```c++
ListNode* swapPairs(ListNode* head) {
    if(!head || !head->next)
        return head;
    ListNode* left = new ListNode(-1);  // dummy
    left->next = head;
    ListNode* pre = left;   // 记录pre
    ListNode* p = head;     // 记录cur
    while(p && p->next) {   // 两两交换要两个结点操作
        ListNode* pNext = p->next;  // 记录next
        p->next = pNext->next;
        pNext->next = p;
        pre->next = pNext;
        // 上面三步交换完成，推进下一步
        pre = p;
        p = p->next;
    }
    return left->next;
}
// or 递归
ListNode* swapPairs(ListNode* head) {
    if(!head || !head->next)        // 终止条件
        return head;
    ListNode* next = head->next;    // 记录
    head->next = swapPairs(next->next); // 顺序1
    next->next = head;                  // 顺序2 不能乱
    return next;    // 想想因为出栈时交换完成了是先经过head再经过next的！
}
```

## 18.  26-简单-删除排序数组中的重复项
**简单**
- 题目描述
    给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。
    不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。

- 示例:
    给定数组 nums = [1,1,2]
    函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 
    
    给定 nums = [0,0,1,1,1,2,2,3,3,4]
    函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。

    你不需要考虑数组中超出新长度后面的元素。

- 思路：双指针，遇到不同的往前放

```c++
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int n = nums.size();
        if(n == 0 || n == 1)
            return n;
        int slow = 0, fast = 1;
        while(fast < n) {
            if(nums[fast] != nums[slow]) {
                slow++;     
                // if(slow == fast) continue;
                nums[slow] = nums[fast];
            }
            fast++;
        }
        return slow + 1;
    }
};
```

 

## 19.  31-中等-下一个排列
**困难** 
- 题目描述
    实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。
    如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。
    必须`原地`修改，只允许使用额外常数空间。

- 示例：
    输入：nums = [1,2,3]
    输出：[1,3,2]

    输入：nums = [3,2,1]
    输出：[1,2,3]

    输入：nums = [1,1,5]
    输出：[1,5,1]

    输入：nums = [1]
    输出：[1]

- 思路：从低位挑一个大一点的数，换掉前面的小一点的一个数，实现变大。变大幅度要尽量小。
    像 [3,2,1] 递减的，没有下一个排列，因为大的已经尽量往前排了，没法更大。
    像 [1,5,2,4,3,2] 这种，我们希望它稍微变大。
    从低位挑一个大一点的数，换掉前面的小一点的一个数。
    于是，从右往左，寻找第一个比右邻居小的数。（把它换到后面去）
    找到 1 5 (2) 4 3 2 中间这个 2，让它和它身后的一个数交换，轻微变大。
    还是从右往左，寻找第一个比这个 2 微大的数。15 (2) 4 (3) 2，交换，变成 15 (3) 4 (2) 2。
    这并未结束，变大的幅度可以再小一点，仟位变大了，后三位还可以小。
    后三位是递减的，翻转，变成[1,5,3,2,2,4]，它就是[1,5,2,4,3,2]的下一个排列。

再来：
    先找出`最大`的索引 k 满足 nums[k-1] < nums[k]，如果不存在，就翻转整个数组；
    再找出另一个`最大`索引 l 满足 nums[l] > nums[k-1]；
    交换 nums[l] 和 nums[k]；
    最后翻转 nums[k:]。
    举个例子:
    比如 nums = [1,2,7,4,3,1]，下一个排列是什么？
    我们找到第一个最大索引是 nums[1] = 2
    再找到第二个最大索引是 nums[4] = 3
    交换，nums = [1,3,7,4,2,1];
    翻转，nums = [1,3,1,2,4,7]
    完毕! 所以, 时间复杂度：O(n) 空间复杂度：O(1)

```c++
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        int pos = nums.size() - 1;
		while (pos > 0 && nums[pos] <= nums[pos - 1])
			pos--;
        // 这里pos找出的是第一个nums[i] > nums[i-1]就是升序的最后一个
        // 如果i = 0说明完全倒叙，直接反转，如果i!=0则反转[i,剩下来的]
		reverse(nums.begin() + pos, nums.end());  //逆序
		if (pos > 0){
			int start = pos;
			for (; start < nums.size(); start++){ //因为已经反转了一次，所以从start开始寻找第一个大于nums[pos - 1]的数，从start开始是升序的
				if (nums[start] > nums[pos - 1]){
					swap(nums, start, pos-1); //交换
					break; //关键
				}
			}
		}
    }
    void swap(vector<int>& nums, int k, int l) {
        int tmp = nums[k];
        nums[k] = nums[l];
        nums[l] = tmp;
    }
};
```

## 20.  33-中等-搜索旋转排序数组
**中等**
- 题目描述
    升序排列的整数数组 nums 在预先未知的某个点上进行了旋转（例如， [0,1,2,4,5,6,7] 经旋转后可能变为?[4,5,6,7,0,1,2] ）。
    请你在数组中搜索?target ，如果数组中存在这个目标值，则返回它的索引，否则返回?-1?。

- 示例：
    输入：nums = [4,5,6,7,0,1,2], target = 0
    输出：4

    输入：nums = [4,5,6,7,0,1,2], target = 3
    输出：-1

    输入：nums = [1], target = 0
    输出：-1
?
- 提示：
    1 <= nums.length <= 5000
    -10^4 <= nums[i] <= 10^4
    nums 中的每个值都 独一无二
    nums 肯定会在某个点上旋转
    -10^4 <= target <= 10^4

- 思路：暴力O(n)，二分才好：这种`有序数列`或`曾经有序数列`一定要往二分方向想~
    1. 总有一边有序
    2. 判断：左边有序：nums[l] <= nums[mid] 否则，右边有序（nums[mid] <= nums[r]）
    3. 只要在有序的半段里用首尾两个数组来判断目标值是否在这一区域内，这样就可以确定保留哪半边了，总结：`利用有序的那一半段来判断`

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int l = 0;
        int r = nums.size() - 1;
        while(l <= r) {
            int mid = (l + r) >> 1;
            if(nums[mid] == target)
                return mid;
            //总是有一边是有序的
            if(nums[l] <= nums[mid]) { 
                //假设左边有序：nums[l] <= nums[mid]
                if(target >= nums[l] && target < nums[mid])
                    //如果target在有序的左边，则搜左边
                    r = mid - 1;
                else
                    //否则搜索另一边
                    l = mid + 1;
            }else {
                //假设右边有序：nums[mid] <= nums[r]
                if(target > nums[mid] && target <= nums[r])
                    //如果target在有序的右边，则搜索右边
                    l = mid + 1;
                else
                    //否则搜索另一边
                    r = mid - 1;
            }
        }
        return -1;
    }
};
```

## 21.  34-中等-在排序数组中查找元素的第一个和最后一个位置
**中等**
- 题目描述
    给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值 target，返回?[-1, -1]。
    进阶：你可以设计并实现时间复杂度为?O(log n)?的算法解决此问题吗？

- 示例：
    输入：nums = [5,7,7,8,8,10], target = 8
    输出：[3,4]

    输入：nums = [5,7,7,8,8,10], target = 6
    输出：[-1,-1]

    输入：nums = [], target = 0
    输出：[-1,-1]

- 思路：二分法明显的
    1. 可以设置找左边界的二分，找target左边界，找target+1的左边界，然后相减
    2. 设置找左右边界的二分，然后相减

```c++
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {   
        vector<int> res(2, -1);
        if (nums.size() == 0)
            return res;
        int left = bSearch(nums, target);
        int right = bSearch(nums, target + 1) - 1;
        if (left < nums.size() && nums[left] == target){
            res[0] = left;
            res[1] = right;
        }
        return res;
    }
    int bSearch(vector<int>& nums, int target){
        int left = 0;
        int right = nums.size() - 1;
        while(left <= right){
            int mid = (left + right) / 2;
            if (nums[mid] < target)
                left = mid + 1;
            else
                right = mid - 1;
        }
        return left;
    }   
};
```   

## 22.  35-简单-搜索插入位置
**中等**
- 题目描述
    给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
    你可以假设数组中无重复元素。

- 示例:
    输入: [1,3,5,6], 5
    输出: 2

    输入: [1,3,5,6], 2
    输出: 1

    输入: [1,3,5,6], 7
    输出: 4

    输入: [1,3,5,6], 0
    输出: 0

- 思路：无脑二分
    如果没有的话，就应该插入到l的位置，因为如果跳出了二分查找，条件是l>r,也就是l=mid+1
    其实二分的边界条件可以在面试的时候慢慢推导
```c++
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int n = nums.size();
        int l = 0;
        int r = n - 1;
        while(l <= r) {
            int mid = (l+r) >> 1;
            if(nums[mid] == target)
                return mid;
            if(nums[mid] < target)
                l = mid + 1;
            else
                r = mid - 1;
        }
        return l;
    }
};
```

## 23.  38-简单-外观数列
**困难**
- 题目描述
    给定一个正整数 n ，输出外观数列的第 n 项。
    `外观数列`是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。
    你可以将其视作是由递归公式定义的数字字符串序列：
    countAndSay(1) = "1"
    countAndSay(n) 是对 countAndSay(n-1) 的描述，然后转换成另一个数字字符串。
    前五项如下：
    1.     1
    2.     11
    3.     21
    4.     1211
    5.     111221
    第一项是数字 1 
    描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 "11"
    描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 "21"
    描述前一项，这个数是 21 即 “ 一 个 2 + 一 个 1 ” ，记作 "1211"
    描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 "111221"

- 思路：没有数学技巧，用一次迭代加递归即可，没有其他思路
```c++
class Solution {
public:
    string countAndSay(int n) {
        if(n == 1) return "1";
        string previous = countAndSay(n-1);
        string result = ""; // 使用递归来一层一层往前推
        int count = 1; // count用来计数
        for(int i=0;i<previous.length();i++)
        {
            if(previous[i] == previous[i+1])
            {
                count ++; // 比如previous是111221时，111部分会让count=3，此时i在第三个1处
            }
            else
            {
                result += to_string(count) + previous[i]; // result会从空变成“31”（当i在第三个1处时）
                count = 1; // 由于i在第三个1处时，i+1处的值为2，1 != 2，所以count重新变成1
            }
        }
        return result;
    }
};
```

## 24.  39-中等-组合总和
**中等**
- 题目描述
    给定一个无重复元素的数组?candidates?和一个目标数?target?，找出?candidates?中所有可以使数字和为?target?的组合。
    candidates?中的数字可以无限制重复被选取。
    说明：
    所有数字（包括?target）都是正整数。
    解集不能包含重复的组合。
?
- 示例：
    输入：candidates = [2,3,6,7], target = 7,
    所求解集为：
    [
    [7],
    [2,2,3]
    ]

    输入：candidates = [2,3,5], target = 8,
    所求解集为：
    [
    ? [2,2,2,2],
    ? [2,3,3],
    ? [3,5]
    ]

- 思路：经典dfs
    1. 可以无限制被重复选取
    2. 解集不能包含重复的组合，因此dfs中的for要从start开始，否则如果从0开始结果如下
        输入
        [2,3,6,7], 7
        输出
        [[2,2,3],[2,3,2],[3,2,2],[7]]
        预期结果
        [[2,2,3],[7]]

```c++
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        sort(candidates.begin(), candidates.end());
        helper(candidates, 0, 0, target);
        return res;
    }
    void helper(vector<int>& cdds, int start, int sum, int target) {
        if(sum > target)
            return;
        if(sum == target) {
            res.push_back(path);
            return;
        }
        for(int i = start; i < cdds.size(); i++) {
            path.push_back(cdds[i]);
            helper(cdds, i, cdds[i] + sum, target);
            // 注意从i=0开始回溯就可以在回溯时同时选第一个元素多次，好好体会
            path.pop_back();
        }
    }
};
```

## 25.  40-中等-组合总和 II
**中等**
- 题目描述
    给定一个数组?candidates?和一个目标数?target?，找出?candidates?中所有可以使数字和为?target?的组合。
    candidates?中的每个数字在每个组合中只能使用一次。

    说明：
    所有数字（包括目标数）都是正整数。
    解集不能包含重复的组合。?

- 示例:
    输入: candidates =?[10,1,2,7,6,1,5], target =?8,
    所求解集为:
    [
    [1, 7],
    [1, 2, 5],
    [2, 6],
    [1, 1, 6]
    ]

    输入: candidates =?[2,5,2,1,2], target =?5,
    所求解集为:
    [
    ? [1,2,2],
    ? [5]
    ]

- 思路：dfs加入去重剪枝，![https://leetcode-cn.com/problems/combination-sum-ii/solution/man-tan-wo-li-jie-de-hui-su-chang-wen-shou-hua-tu-/]
    ![https://leetcode-cn.com/problems/combination-sum-ii/solution/wu-lun-ru-he-wo-ye-yao-rang-ni-nong-dong-n7gs/]
    1. 递归树图中每一层都可以有每一个结点，也可以只有有前面没有用过的结点，题解很详细
   
```c++
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        sort(candidates.begin(), candidates.end());
        vector<bool> used(candidates.size(), false);
        dfs(candidates, target, 0, 0, used);
        return res;
    }
    void dfs(vector<int>& candidates, int target, int start, int sum, vector<bool>& used) {
        if(sum > target)
            return;
        if(sum == target) {
            res.push_back(path);
            return;
        }
        for (int i = start; i < candidates.size() && sum + candidates[i] <= target; i++) {
            // 画图理解！！！
            // used[i - 1] == true，说明同一树支candidates[i - 1]使用过
            // used[i - 1] == false，说明同一树层candidates[i - 1]使用过
            // 要对同一树层使用过的元素进行跳过
            if (i > 0 && candidates[i] == candidates[i - 1] && used[i - 1] == false) {
                continue;// i > 0是因为要i-1索引 
            }
            sum += candidates[i];
            path.push_back(candidates[i]);
            used[i] = true;
            dfs(candidates, target, i+1, sum, used);
            // 和39.组合总和的区别1：这里是i+1，每个数字在每个组合中只能使用一次
            used[i] = false;
            sum -= candidates[i];
            path.pop_back();
        }
    }
};
```

## 26.  46-中等-全排列
**中等**
- 题目描述
    给定一个`没有重复`数字的序列，返回其所有可能的全排列。

- 示例:
    输入: [1,2,3]
    输出:
    [
    [1,2,3],
    [1,3,2],
    [2,1,3],
    [2,3,1],
    [3,1,2],
    [3,2,1]
    ]

- 思路：dfs

```c++
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;  
    vector<vector<int>> permute(vector<int>& nums) {
        if(nums.size() < 1)
            return res;
        if(nums.size() == 1) {
            res.push_back(nums);
            return res;
        }
        vector<bool> used(nums.size(), false);
        traceBack(nums, used);
        return res;
    }
    void traceBack(const vector<int> & nums, vector<bool> & used) {
        if(path.size() == nums.size()) {
            res.push_back(path);
            return;
        }
        for (int i = 0; i < nums.size(); i++) {
            if(used[i])
                continue;
            path.push_back(nums[i]);
            used[i] = true;
            traceBack(nums, used);
            path.pop_back();
            used[i] = false;
        }
    }

};
```

## 27.  48-中等-旋转图像
**简单**
- 题目描述
    给定一个 n?×?n 的二维矩阵?matrix 表示一个图像。请你将图像顺时针旋转 90 度。
    你必须在`原地`旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。

- 示例：
    输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
    输出：[[7,4,1],[8,5,2],[9,6,3]]

    输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]
    输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]

    输入：matrix = [[1]]
    输出：[[1]]

    输入：matrix = [[1,2],[3,4]]
    输出：[[3,1],[4,2]]

- 思路：根据对角线交换元素，然后上下按行交换元素。对角线的选择是根据+90°还是-90°
```c++
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        if(n == 1) return;
        for(int i = 0; i < n; i++) 
            for(int j = i + 1; j < n; j++) {
                int tmp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = tmp;
            }   // 根据对角线来交换元素
        for(int i = 0; i < n; i++) {
            int j = 0;
            int k = n - 1;
            while(j < k) {
                int tmp = matrix[i][j];
                matrix[i][j] = matrix[i][k];
                matrix[i][k] = tmp;
                j++;
                k--;
            }   // 上下行按中间分界线交换元素
        }
    }
};
```

## 28.  49-中等-字母异位词分组
**中等**
- 题目描述
    给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。

- 示例:
    输入: ["eat", "tea", "tan", "ate", "nat", "bat"]
    输出:
    [
    ["ate","eat","tea"],
    ["nat","tan"],
    ["bat"]
    ]

- 思路：hash表
    1. 遍历输入的每一个字符串
    2. 用一个变量记录每个字符串，然后排序字符串后，用哈希表记录
    3. 字母异位词排序后都是一样的，这是关键
    4. unordered<string, vector<string> > hash;它的second就是结果啦

```c++
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map<string, vector<string>> table;
        for(string& str : strs) {
            string tmp = str;
            sort(tmp.begin(), tmp.end());
            table[tmp].push_back(str);
        }
        vector<vector<string>> res;
        for(auto& t : table) 
            res.push_back(t.second);
        return res;
    }
};
```


## 29.  50-中等-Pow(x, n)
**简单**
- 题目描述
    实现?pow(x, n)?，即计算 x 的 n 次幂函数（即，xn）。

- 示例：
    输入：x = 2.00000, n = 10
    输出：1024.00000

    输入：x = 2.10000, n = 3
    输出：9.26100

    输入：x = 2.00000, n = -2
    输出：0.25000
    解释：2-2 = 1/22 = 1/4 = 0.25

- 思路：标签是二分查找，往二分方向想的话，就是half * half * rest
```c++
class Solution {
public:
    double myPow(double x, int n) {
        if(n == 0) 
            return 1.0; // 返回的是double
        if(n == 1)
            return x;
        if(n == -1)
            return 1 / x;
        double half = myPow(x, n / 2);
        double rest = myPow(x, n % 2);
        return half * half * rest;
    }
};
```

## 30.  53-简单-最大子序和
**中等** **dp**
- 题目描述
    给定一个整数数组 nums?，找到一个具有最大和的`连续`子数组（子数组最少包含一个元素），返回其最大和。

- 示例：
    输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
    输出：6
    解释：连续子数组?[4,-1,2,1] 的和最大，为?6 。

    输入：nums = [1]
    输出：1

    输入：nums = [0]
    输出：0

    输入：nums = [-1]
    输出：-1

    输入：nums = [-100000]
    输出：-100000

- 思路：动态规划
    1. vector<int> dp(nums.size()+1, 0); // 右对齐，一边都是右对齐
    2. 因为要连续的子数组，最大和，因此在遍历时碰到碰到负数时要特别注意处理

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        vector<int> dp(nums.size()+1, 0);
        int ans = INT_MIN;
        for(int i = 1; i <= nums.size(); i++) {
            if(dp[i-1] < 0) // 如果前面的最大和是负数，那么它没有利用价值
                dp[i] = nums[i-1];
            else
                dp[i] = dp[i-1]+nums[i-1];  // 加了之后再比较
            ans = std::max(dp[i], ans);     // 要真个遍历过程中最大的那个连续和
        }
        return ans;
    }
};
```

## 31.  54-中等-螺旋矩阵
**中等**
- 题目描述
    给你一个 m 行 n 列的矩阵?matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。

- 示例：
    输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
    输出：[1,2,3,6,9,8,7,4,5]

    输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
    输出：[1,2,3,4,8,12,11,10,9,5,6,7]

- 思路：矩阵的长宽不一定想等，定义一下边界就可以了
        “ 看了题解就像疏通了我多年的便秘。 ” ——某Coder 

```c++
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector<int> res;
        if(matrix.empty())
            return res;
        int l = 0;
        int r = matrix[0].size() - 1;
        int u = 0;
        int d = matrix.size() - 1;
        while(true) {
            for(int i = l; i <= r; ++i) ans.push_back(matrix[u][i]); //向右移动直到最右
            if(++ u > d) break; //重新设定上边界，若上边界大于下边界，则遍历遍历完成，下同
            for(int i = u; i <= d; ++i) ans.push_back(matrix[i][r]); //向下
            if(-- r < l) break; //重新设定有边界
            for(int i = r; i >= l; --i) ans.push_back(matrix[d][i]); //向左
            if(-- d < u) break; //重新设定下边界
            for(int i = d; i >= u; --i) ans.push_back(matrix[i][l]); //向上
            if(++ l > r) break; //重新设定左边界
        }
        return res;
    }
};
```

## 32.  55-中等-跳跃游戏
**困难**
- 题目描述
    给定一个非负整数数组?nums ，你最初位于数组的 第一个下标 。
    数组中的每个元素代表你在该位置可以跳跃的最大长度。
    判断你是否能够到达最后一个下标。

- 示例：
    输入：nums = [2,3,1,1,4]
    输出：true
    解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。

    输入：nums = [3,2,1,0,4]
    输出：false
    解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。

- 思路：两种思路，前者比较生硬，后者较容易理解。遍历到每个位置后最远可达nums[i]+i
```c++
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int k = 0;  //能到达最远的地方，初始为0
        for(int i = 0; i < nums.size(); i++) {
            if(k < i)
                return false;
            k = max(k, i + nums[i]); 
        }
        return true;
    }
};

想象你是那个在格子上行走的小人，格子里面的数字代表“能量”，你需要“能量”才能继续行走。
每次走到一个格子的时候，你检查现在格子里面的“能量”和你自己拥有的“能量”哪个更大，取更大的“能量”！ 如果你有更多的能量，你就可以走的更远啦！~
class Solution {
public:
    bool canJump(vector<int>& nums)
    {
        if(nums.size() == 0)
            return true;
        int cur = nums[0], i = 1;
        // 拿了0位置的能量，从i=1开始遍历
        for(; cur != 0 && i < nums.size(); i++)
        {
            cur--;
            if(cur < nums[i])
                cur = nums[i];
        }
        return i == nums.size();
    }
};
```

## 33.  56-中等-合并区间
**中等**
- 题目描述
    以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。
- 示例：
    输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
    输出：[[1,6],[8,10],[15,18]]
    解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].

    输入：intervals = [[1,4],[4,5]]
    输出：[[1,5]]
    解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。

- 思路：画图可以更加直观理解。区间排序：左边界递增，若左边界相等则右边界递减

```c++
class Solution {
public:
    static bool cmp(vector<int>& a, vector<int>& b) {
        return a[0] != b[0] ? a[0] > b[0] : a[1] < b[1];
        //起点升序排列、终点降序排列
    }
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        vector<vector<int>> res;
        int n = intervals.size();
        if(n == 0)
            return res;
        sort(intervals.begin(), intervals.end(), cmp);
        int left = intervals[0][0];
        int right = intervals[0][1];
        for (int i = 1; i < n; i++)
        {
            if (left <= intervals[i][0] && right >= intervals[i][1]) {
                continue;   // 已经包含了这个区间了 跳过
            }
            if (right >= intervals[i][0] && right <= intervals[i][1]) {
                right = intervals[i][1];    // 右边较大，扩展右边
                continue;
            }
            if(right < intervals[i][0]) {   // 遇到断开的区间，存入前面的结果之一
                res.push_back({left, right});
                left = intervals[i][0];
                right = intervals[i][1];
            }
        }
        res.push_back({left, right});
        return res;
    }
};
```

## 34.  61-中等-旋转链表
**中等**
- 题目描述
    给定一个链表，旋转链表，将链表每个节点向右移动?k?个位置，其中?k?是非负数。

- 示例:
    输入: 1->2->3->4->5->NULL, k = 2
    输出: 4->5->1->2->3->NULL
    解释:
    向右旋转 1 步: 5->1->2->3->4->NULL
    向右旋转 2 步: 4->5->1->2->3->NULL

    输入: 0->1->2->NULL, k = 4
    输出: 2->0->1->NULL
    解释:
    向右旋转 1 步: 2->0->1->NULL
    向右旋转 2 步: 1->2->0->NULL
    向右旋转 3 步:?0->1->2->NULL
    向右旋转 4 步:?2->0->1->NULL

- 思路：链表问题，无脑往双指针方向想。
    1. 因为 k 与链表长度都会影响最终结果，因此将链表连成环更直接
    2. step = len - k % len;  // 关键，画图理解，理解不了记住
    3. 就是 算出长度、连成环、算step、head走step-1步，断开尾巴

```c++
class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
        if(!head || !head->next || k == 0)
            return head;
        ListNode* fast = head;  // 快指针计算结点个数
        ListNode* slow = head;
        int len = 1;
        while(fast->next) {
            fast = fast->next;
            len++;
        }
        fast->next = head; // 形成环
        int step = len - k % len; //这一步关键
        while(step-- != 1)  // step==1跳出循环，方便断开尾巴
            slow = slow->next;
        ListNode* res = slow->next;
        slow->next = nullptr;
        return res;
    }
};
```

## 35.  62-中等-不同路径
**困难** **dp**
- 题目描述
    一个机器人位于一个 m x n?网格的左上角 （起始点在下图中标记为 “Start” ）。
    机器人每次`只能`向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。
    问总共有多少条不同的路径？
- 示例：
    输入：m = 3, n = 7
    输出：28

    输入：m = 3, n = 2
    输出：3
    解释：
    从左上角开始，总共有 3 条路径可以到达右下角。
    1. 向右 -> 向下 -> 向下
    2. 向下 -> 向下 -> 向右
    3. 向下 -> 向右 -> 向下
- 思路：动态规划 or 数学方式
    1. dp[m][n]中表示从起点走到(m,n)点的路径数目
    2. 数学方式是：机器人一定会走m+n-2步，即从m+n-2中挑出m-1步向下走不就行了吗？即C（（m+n-2），（m-1））
    3. **关键**C(m,n) = (n-m+1)(n-m+2)···(n-m+m) / (1·2···m) // m < n
```c++
class Solution {
public:
    int uniquePaths(int m, int n) {
        /* vector<vector<int>> dp(m, vector<int>(n, 0));
        for(int i = 0; i < m; i++)
            dp[i][0] = 1;
        for(int i = 0; i < n; i++)
            dp[0][i] = 1;
        for(int i = 1; i < m; i++)
            for(int j = 1; j < n; j++)
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
        return dp[m-1][n-1]; */
        /* vector<int> dp(n, 1);
        for(int i = 1; i < m; i++)
            for(int j = 1; j < n; j++)
                dp[j] = dp[j] + dp[j -1];
        return dp[n - 1];  */
        int N = m + n - 2;
        int M = min(m -1, n - 1);
        long long res = 1;
        for(int i = 1; i <= M; i++)
            res = res * (N - M + i) / i;
        return (int)res;
    }
};
```

## 36.  64-中等-最小路径和
**中等** **dp**
- 题目描述
    给定一个包含非负整数的 m?x?n?网格?grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。
    说明：每次只能向下或者向右移动一步。

- 示例：
    输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
    输出：7
    解释：因为路径 1→3→1→1→1 的总和最小。

    输入：grid = [[1,2,3],[4,5,6]]
    输出：12

- 思路：动态规划无脑，初级时注意初始化，高级时用一维数组来完成剪枝
```c++
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();
        /* vector<vector<int>> dp(m, vector<int>(n, 0));
        dp[0][0] = grid[0][0];  // 只能向右或向下，所以初始化就是边界的累加值啦
        for(int i = 1; i < m; i++)
            dp[i][0] += grid[i][0] + dp[i-1][0];
        for(int i = 1; i < n; i++)
            dp[0][i] += grid[0][i] + dp[0][i-1];
        for(int i = 1; i < m; i++)
            for(int j = 1; j < n; j++)  // 比较来自上面或者左边哪个值小
                dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]);
        return dp[m-1][n-1]; */
        vector<int> dp(n+1,INT_MAX);    // 要多一个空间列
        dp[1] = 0;
        for(int i=1;i<=m;i++)
            for(int j=1;j<=n;j++){
                dp[j] = min(dp[j-1],dp[j]) + grid[i-1][j-1]; //想得明白
            }   // 同一个变量来说，等号右边就是等号左边的前一个状态
        return dp[n];
    }
};
```


## 37.  66-简单-加一
**简单** 
- 题目描述
    给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。
    最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。
    你可以假设除了整数 0 之外，这个整数不会以零开头。
- 示例：
    输入：digits = [1,2,3]
    输出：[1,2,4]
    解释：输入数组表示数字 123。

    输入：digits = [4,3,2,1]
    输出：[4,3,2,2]
    解释：输入数组表示数字 4321。

    输入：digits = [0]
    输出：[1]
- 思路：sum + carry

```c++
class Solution {
public:
    vector<int> plusOne(vector<int>& digits) {
        int sz = digits.size();
        // case1:最后一个数字<9，直接+1
        if(digits[sz-1] < 9) {
            digits[sz-1]++;
            return digits;
        }
        //complicated，计算后面要变为0的个数
        int zeroNum = 0;
        for(int i = sz - 1; i >=0; i--) {
            if(digits[i] == 9)
                zeroNum++;
            else {
                digits[i]++;
                break;  // 从尾到头计算9的个数，最后一个非9的数+1便可
            }
        }
        if(zeroNum == sz) {
            /* vector<int> res(zeroNum+1,0);
            res[0] = 1;
            return res; */
            //上面的构造函数用时较长
            digits[0] = 1;
            for(int i = 1; i < sz; i++)
                digits[i] = 0;
            digits.push_back(0);
            return digits;
        }
        for(int i = sz - zeroNum; i < sz; i++)
            digits[i] = 0;
        return digits;
    }
};
```


## 38.  69-简单-x 的平方根
**中等**
- 题目描述
    实现?int sqrt(int x)?函数。计算并返回?x?的平方根，其中?x 是非负整数。
    由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。
- 示例:
    输入: 4     输出: 2
    输入: 8     输出: 2
    说明: 8 的平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。
- 思路：标签说是二分查找，额，就是次方、开方都是可以往二分方面想的，另外右牛顿迭代法
  ![https://leetcode-cn.com/problems/sqrtx/solution/er-fen-cha-zhao-niu-dun-fa-python-dai-ma-by-liweiw/]

```c++
class Solution {
public:
    int mySqrt(int x) {
        if(x<=0){
            return 0;
        }
        //牛顿迭代法
        double last = 0;
        double res = 1;
        while(res!=last){
            last = res;
            res = (res + x / res) / 2;
            //or (last-res)<10E-6
        }
        return (int)res;
        // 二分法
        int min = 0;
        int max = x;
        while(max - min > 1) {
            int mid = (min+max) >> 1;
            if(x/mid < mid) max = mid;
            else            min = mid;
        }
        return min;
        // 或则 二分法
        long left = 1;
        long right = x;
        while (left <= right) {
            long mid = left + (right - left) / 2;
            long t = mid * mid;
            if (t == x) {
                return (int)mid;
            } else if (t < x) {
                left = mid + 1;
            } else if (t > x) {
                right = mid - 1;
            }
        }
        return (int)right;
    }
};
```


## 39.  70-简单-爬楼梯
**简单** **dp**
- 题目描述
    假设你正在爬楼梯。需要 n?阶你才能到达楼顶。
    每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
    注意：给定 n 是一个正整数。
- 示例：
    输入： 2
    输出： 2
    解释： 有两种方法可以爬到楼顶。
    1.  1 阶 + 1 阶
    2.  2 阶

    输入： 3
    输出： 3
    解释： 有三种方法可以爬到楼顶。
    1.  1 阶 + 1 阶 + 1 阶
    2.  1 阶 + 2 阶
    3.  2 阶 + 1 阶

- 思路：第n个台阶只能从第n-1或者n-2个上来。到第n-1个台阶的走法 + 第n-2个台阶的走法 = 到第n个台阶的走法，已经知道了第1个和第2个台阶的走法，一路加上去。

```c++
class Solution {
public:
    int climbStairs(int n) {
        if(n <= 2)  return n;
        int a = 1, b = 2;
        for(int i = 3; i <= n; i++) {
            int tmp = a + b;    // 跟斐波那契数列一样的案例
            a = b;
            b = tmp;
        }
        return b;
    }
};
```

## 40.  75-中等-颜色分类
**中等**
- 题目描述
    给定一个包含红色、白色和蓝色，一共?n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。
    此题中，我们使用整数 0、?1 和 2 分别表示红色、白色和蓝色。
- 示例：
    输入：nums = [2,0,2,1,1,0]  输出：[0,0,1,1,2,2]
    输入：nums = [2,0,1]        输出：[0,1,2]
- 思路：划分区间来交换就可，可以扩展到区间的划分
```c++
class Solution {
public:
    void sortColors(vector<int>& nums) {
        int sz = nums.size();
        if(sz < 2)
            return;
        // [0, zero) == 0
        // [zero, i) == 1
        // [two, nums.size) ==2
        int zero = 0;
        int i = 0;
        int two = sz;
        while(i < two) {
            if(nums[i] == 0) {
                swap(nums[zero], nums[i]);
                i++;
                zero++;
            }else if(nums[i] == 1) {
                i++;
            }else {
                two--;
                swap(nums[i], nums[two]);
                //i++;  注意这里不需要，因为交换后并没有判断
            }
        }
    }
};
```

## 41.  78-中等-子集
**中等**
- 题目描述
    给你一个整数数组?nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。
    解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。

- 示例：
    输入：nums = [1,2,3]
    输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]

    输入：nums = [0]
    输出：[[],[0]]

- 思路：无脑dfs

```c++
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path = {};
    vector<vector<int>> subsets(vector<int>& nums) {
        if(nums.size() == 0)
            return res;
        traceBack(nums, 0, path);
        return res;
    }
    void traceBack(const vector<int> & nums, int start, vector<int> path) {
        res.push_back(path);
        for (int i = start; i < nums.size(); ++i) {
            path.push_back(nums[i]);
            traceBack(nums, i + 1, path);
            path.pop_back();
        }
    }
};
```





## 42.  79-中等-单词搜索
**困难**
- 题目描述
    给定一个二维网格和一个单词，找出该单词是否存在于网格中。
    单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。   ?
- 示例:
    board =
    [
    ['A','B','C','E'],
    ['S','F','C','S'],
    ['A','D','E','E']
    ]
    给定 word = "ABCCED", 返回 true
    给定 word = "SEE", 返回 true
    给定 word = "ABCB", 返回 false
- 思路：提高速度方法是string和vector<vector<int>>用`引用传参`，dfs无脑
```c++
class Solution {
public:
    int m;
    int n;
    bool exist(vector<vector<char>>& board, string word) {
        m = board.size();
        n = board[0].size();
        for(int i = 0; i < m; i++)
            for(int j = 0; j < n; j++)
                if(dfs(board, word, 0, i, j))
                    return true;
        return false;
    }
    bool dfs(vector<vector<char>>& board, string& word, int index, int x, int y) {
        if(board[x][y] != word[index])
            return false;
        if(index == word.size() - 1)
            return true;
        char tmp = board[x][y];
        board[x][y] = '#'; 
        if(x > 0 && dfs(board, word, index+1, x-1, y))  
            return true;
        if(x < m-1 && dfs(board, word, index+1, x+1, y)) 
            return true;
        if(y > 0 && dfs(board, word, index+1, x, y-1))  
            return true;
        if(y < n-1 && dfs(board, word, index+1, x, y+1))
            return true;
        board[x][y] = tmp;
        return false;        
    }
};
```


## 43.  83-简单-删除排序链表中的重复元素
**简单**
- 题目描述
    给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。
- 示例:
    输入: 1->1->2
    输出: 1->2

    输入: 1->1->2->3->3
    输出: 1->2->3
- 思路：暴力直接法、快慢指针法
```c++
class Solution {
public:
    //暴力法
    ListNode* deleteDuplicates(ListNode* head) {
        for (ListNode *p = head; p && p->next;){
            if(p->val==p->next->val){
                p->next = p->next->next;
                continue;
            }
            p = p->next;
        }
        return head;
    }
    //双指针
    ListNode* deleteDuplicates(ListNode* head) {
        if(!head || !head->next)
            return head;
        ListNode *slow = head;
        ListNode *fast = head->next;
        while(fast) {
            if(slow->val != fast->val) {
                slow->next = fast;
                slow = fast;
            }
            fast = fast->next;
        }
        slow->next = nullptr;
        return head;
    }
};
```

## 44.  86-中等-分隔链表
**简单**
- 题目描述
    给你一个链表和一个特定值 x ，请你对链表进行分隔，使得所有小于 x 的节点都出现在大于或等于 x 的节点之前。
    你应当保留两个分区中每个节点的初始相对位置。
- 示例：
    输入：head = 1->4->3->2->5->2, x = 3
    输出：1->2->2->4->3->5
- 思路：建立两个链表，一个存大于x的一个存小于x的
```c++
class Solution {
public:
    ListNode* partition(ListNode* head, int x) {
        ListNode* smaller = new ListNode;
        ListNode* larger = new ListNode;
        ListNode* s = smaller;
        ListNode* l = larger;
        ListNode* p = head;
        while(p) {
            if(p->val < x) {
                s->next = p;
                p = p->next;
                s = s->next;
                s->next = nullptr;
            }else {
                l->next = p;
                p = p->next;
                l = l->next;
                l->next = nullptr;
            }
        }
        s->next = larger->next;
        return smaller->next;
    }
};
```

## 45.  88-简单-合并两个有序数组
**简单**
- 题目描述
    给你两个有序整数数组?nums1 和 nums2，请你将 nums2 合并到?nums1?中，使 nums1 成为一个有序数组。
    初始化?nums1 和 nums2 的元素数量分别为?m 和 n 。你可以假设?nums1 的空间大小等于?m + n，这样它就有足够的空间保存来自 nums2 的元素。
- 示例：
    输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
    输出：[1,2,2,3,5,6]
    输入：nums1 = [1], m = 1, nums2 = [], n = 0
    输出：[1]
- 思路：因为有序，所以从大到小看数组会方便排序，一个个搬运
```c++
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        if(n == 0)
            return;
        //转换为索引
        int i = nums1.size() - 1;
        m--;    
        n--;
        while(n >= 0) {
            while(m >= 0 && nums1[m] >= nums2[n])
                swap(nums1[i--], nums1[m--]);   // 把比nums2[n]大的搬运到它后面
            nums1[i--] = nums2[n--];
        }
    }
};
```

## 46.  90-中等-子集 II
**中等**
- 题目描述
    给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。
    说明：解集不能包含重复的子集。
- 示例:
    输入: [1,2,2]
    输出:
    [
    [2],
    [1],
    [1,2,2],
    [2,2],
    [1,2],
    []
    ]
- 思路：dfs啦，跟40题结合看，不要少了sort这一步，因为要让相同元素连在一起相邻
```c++
class Solution {
public:
    vector<vector<int> > res;
    vector<int> path;
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        if(nums.size() == 0)    
            return res;
        vector<bool> used(nums.size(), false);
        sort(nums.begin(), nums.end());
        dfs(nums, 0, used);
        return res;
    }
    void dfs(vector<int>& nums, int start, vector<bool>& used) {
        res.push_back(path);
        for(int i = start; i < nums.size(); i++) {
            if(i > 0 && nums[i] == nums[i-1] && !used[i-1])
                continue;
            used[i] = true;
            path.push_back(nums[i]);
            dfs(nums, i+1, used);
            path.pop_back();
            used[i] = false;
        }
    }
    // or
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        if(nums.size() == 0)
            return {{}};
        sort(nums.begin(), nums.end());  
        /* vector<bool> used(nums.size(), false); */      
        dfs(nums, 0);
        return ans;
    }
    void dfs(vector<int>& nums, int start) {
        ans.push_back(path);
        for(int i = start; i < nums.size(); i++) {
            if(i > start && nums[i-1] == nums[i]) // i > start
                continue;
            path.push_back(nums[i]);
            dfs(nums, i + 1);
            path.pop_back();
        }
    }
};
```


## 47.  91-中等-解码方法
**困难** **dp**
- 题目描述
    一条包含字母?A-Z 的消息通过以下映射进行了 编码 ：
    'A' -> 1
    'B' -> 2
    ...
    'Z' -> 26
    要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，"111" 可以将 "1" 中的每个 "1" 映射为 "A" ，从而得到 "AAA" ，或者可以将 "11" 和 "1"（分别为 "K" 和 "A" ）映射为 "KA" 。注意，"06" 不能映射为 "F" ，因为 "6" 和 "06" 不同。
    给你一个只含数字的 非空 字符串 num ，请计算并返回 解码 方法的 总数 。
    题目数据保证答案肯定是一个 32 位 的整数。
- 示例：
    输入：s = "12"
    输出：2
    解释：它可以解码为 "AB"（1 2）或者 "L"（12）。

    输入：s = "226"
    输出：3
    解释：它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。

    输入：s = "0"
    输出：0
    解释：没有字符映射到以 0 开头的数字。含有 0 的有效映射是 'J' -> "10" 和 'T'-> "20" 。由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。

    输入：s = "06"
    输出：0
    解释："06" 不能映射到 "F" ，因为字符串开头的 0 无法指向一个有效的字符。?
- 思路：因为所有数字都必须要映射，所以输入对'0'要特殊处理，并且超出'26'就返回0
```c++
class Solution {
public:
    int numDecodings(string s) {
        if(s[0] == '0')
            return 0;
        /* 
        要求是每个符号都要参与解码，否则返回0，特别要注意符号'0'的情况
        dp[i] == s[0...i]的解码方法总数
        if(s[i] == '0') 
            if(s[i-1] == '1' || s[i-1] == '2') dp[i] = dp[i-2]; // 因为s[i-1]s[i]必须组合解码，所以这个对组合数目没有改变
            else return 0;
        if(s[i-1] == '1')
            dp[i] = dp[i-1] + dp[i-2]; //s[i-1]s[i]组合时dp[i-2]，分开时dp[i-1]
        if(s[i-1] == '2' && s[i] >= '1' && s[i] <='6')
            dp[i] = dp[i-1] + dp[i-2]; //s[i-1]s[i]组合时dp[i-2]，分开时dp[i-1]
        else
            dp[i] = dp[i-2]
         */
        vector<int> dp(s.size()+1, 0);
        dp[0] = 1;  // 左对齐
        dp[1] = 1;  
        for(int i = 1; i < s.size(); i++) {
            if (s[i] == '0')//1.s[i]为0的情况
                if (s[i - 1] == '1' || s[i - 1] == '2') //s[i - 1]等于1或2的情况
                    dp[i+1] = dp[i-1];//由于s[1]指第二个下标，对应为dp[2],所以dp的下标要比s大1，故为dp[i+1]
                else 
                    return 0;
            else //2.s[i]不为0的情况
                if (s[i - 1] == '1' || (s[i - 1] == '2' && s[i] <= '6'))//s[i-1]s[i]两位数要小于26的情况
                    dp[i+1] = dp[i]+dp[i-1];
                else//其他情况
                    dp[i+1] = dp[i];
        } 
        return dp[s.size()];
    }
};
```

## 48.  92-中等-反转链表 II
**困难**
- 题目描述
    反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。
    说明: 1 ≤?m?≤?n?≤ 链表长度。
- 示例:
    输入: 1->2->3->4->5->NULL, m = 2, n = 4
    输出: 1->4->3->2->5->NULL
- 思路：直接来遍历原地翻转，注意要设一个dummy结点 or 用递归 ![https://leetcode-cn.com/problems/reverse-linked-list-ii/solution/bu-bu-chai-jie-ru-he-di-gui-di-fan-zhuan-lian-biao/]
```c++
class Solution {
public:
    ListNode* reverseBetween(ListNode* head, int m, int n) {
        ListNode *dum = new ListNode(-1);
        dum->next = head;
        ListNode *left = dum;
        ListNode *right = dum;

        for(int i = 0;i<m-1;i++){ // left指向反转前一个节点
            left = left->next;
        }
        right = left->next;  // 用right遍历迭代，反转n-m+1长的链表
  
        ListNode *pre = new ListNode(-1); // 指向反转后链表的头部
        ListNode *tmp = right; // 记录反转前的链表头部（反转后变成尾部）
        int length = n-m+1;
        while(length--){   //迭代反转
            ListNode *next = right->next;
            right->next = pre;
            pre = right;
            right = next;
        }
        tmp->next = right;  // 将反转后的链表头尾与原链表相接
        left->next = pre;

        return dum->next; 
    }
};
/* ListNode reverse(ListNode head) {
    if (head.next == null) return head;
    ListNode last = reverse(head.next);
    head.next.next = head;
    head.next = null;
    return last;
} */
class Solution {
public:
    ListNode *successor = nullptr;
    // 将链表的前 n 个节点反转（n <= 链表长度）
    ListNode* reverse(ListNode* head, int n) {
        if(n == 1) {
            successor = head->next; // 记录第 n + 1 个节点
            return head;
        }
        ListNode *plast = reverse(head->next, n - 1);
        head->next->next = head;
        head->next = successor;
        return plast;//递归里面操作的只有head，没有plast，所以肯定是最后一个plast的
    }
    ListNode* reverseBetween(ListNode* head, int m, int n) {
        if (m == 1)
            return reverse(head, n);
        else 
            head->next = reverseBetween(head->next, m - 1, n - 1);
        return head;
    }
};
```

## 49.  94-中等-二叉树的中序遍历
**困难**
- 题目描述
    给定一个二叉树的根节点 root ，返回它的 中序 遍历。
- 思路：递归与不递归，非递归一定要用`栈stack`！！
- 前中后序 ![https://leetcode-cn.com/problems/binary-tree-postorder-traversal/solution/bang-ni-dui-er-cha-shu-bu-zai-mi-mang-che-di-chi-t/]
```c++
class Solution {
public:
    void inorder(TreeNode* root, vector<int>& ret){
        if(!root)
            return;
        inorder(root->left, ret);
        ret.push_back(root->val);
        inorder(root->right, ret);
    }
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> ret;
        inorder(root, ret);
        return ret;
        }
};
// stack
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode *> st;
        TreeNode* node = root;
        // 当node==null && st.empty()时跳出
        while(node || !st.empty()) {
            // 先把node走到最左的路径结点按顺序入栈
            if(node) {
                st.push(node->left);
                node = node->left;
            }else {
                node = st.top();
                st.pop();
                res.push_back(node->val);
                node = node->right;
            }
        }
        return res;
    }
};
// 前序遍历：根、左、右
// 入栈：    根、右、左
vector<int> preinorder(TreeNode* root) {
    vector<int> res;
    if(!root)   return res;
    stack<TreeNode*> st;
    st.push(root)
    while(!st.empty()) {
        TreeNode* tmp = st.top();           // 中
        st.pop();
        res.push_back(tmp->val);
        if(tmp->right) st.push(tmp->right); // 右
        if(tmp->left)  st.push(tmp->left);  // 左
    }
    return res;
}
// 后序遍历：   左、右、根
// 入栈：       根、左、右
// 翻转：       左、右、根
vector<int> preinorder(TreeNode* root) {
    vector<int> res;
    if(!root)   return res;
    stack<TreeNode*> st;
    st.push(root)
    while(!st.empty()) {
        TreeNode* tmp = st.top();           // 中
        st.pop();
        res.push_back(tmp->val);
        if(tmp->left)  st.push(tmp->left);  // 左
        if(tmp->right) st.push(tmp->right); // 右
    }// 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈）
    reverse(res.begin(), res.end());// 将结果反转之后就是左右中的顺序了
    return res;
}
```


## 50.  95-中等-不同的二叉搜索树 II （生成BST）
**困难**
- 题目描述
    给定一个整数 n，生成所有由 1 ...?n 为节点所组成的 二叉搜索树 。
- 示例：
    输入：3
    输出：
    [
    ? [1,null,3,2],
    ? [3,2,null,1],
    ? [3,1,null,null,2],
    ? [2,1,3],
    ? [1,null,2,null,3]
    ]
    解释：以上的输出对应以下 5 种不同结构的二叉搜索树
- 思路：递归咯。利用一下查找二叉树的性质。左子树的所有值小于根节点，右子树的所有值大于根节点。
        `思路没有想出来就完蛋`
所以如果求 1...n 的所有可能。
我们只需要把 1 作为根节点，[ ] 空作为左子树，[ 2 ... n ] 的所有可能作为右子树。
2 作为根节点，[ 1 ] 作为左子树，[ 3...n ] 的所有可能作为右子树。
3 作为根节点，[ 1 2 ] 的所有可能作为左子树，[ 4 ... n ] 的所有可能作为右子树，然后左子树和右子树两两组合。
4 作为根节点，[ 1 2 3 ] 的所有可能作为左子树，[ 5 ... n ] 的所有可能作为右子树，然后左子树和右子树两两组合。
...
n 作为根节点，[ 1... n ] 的所有可能作为左子树，[ ] 作为右子树。
至于，[ 2 ... n ] 的所有可能以及 [ 4 ... n ] 以及其他情况的所有可能，可以利用上边的方法，把每个数字作为根节点，然后把所有可能的左子树和右子树组合起来即可。
如果只有一个数字，那么所有可能就是一种情况，把该数字作为一棵树。而如果是 [ ]，那就返回 null。

```c++
class Solution {
private:
    vector<TreeNode*> helper(int start, int end){
        vector<TreeNode*> res;
        if(start > end) {
            res.push_back(NULL);
            return res;
        }
        for(int i = start; i <= end; i++){
            vector<TreeNode*> lefts = helper(start, i - 1);
            vector<TreeNode*> rights = helper(i + 1, end);
            for(int j = 0; j < (int)lefts.size(); j++){
                for(int k = 0; k < (int)rights.size(); k++){
                    TreeNode* root = new TreeNode(i);
                    root->left = lefts[j];
                    root->right = rights[k];
                    res.push_back(root);
                }
            }
        }
        return res;
    }
public:
    vector<TreeNode*> generateTrees(int n) {
        if(n == 0) return vector<TreeNode*>(0);
        return helper(1,n);
    }
};
```

## 51. 96-中等-不同的二叉搜索树
**困难** **dp**
- 题目描述
    给定一个整数 n，求以?1 ...?n?为节点组成的二叉搜索树有多少种？
- 示例:
    输入: 3    输出: 5
    解释: 给定 n = 3, 一共有 5 种不同结构的二叉搜索树
- 思路：假设n个节点存在二叉排序树的个数是G(n)，1为根节点，2为根节点，...，n为根节点，当1为根节点时，其左子树节点个数为0，右子树节点个数为n-1，同理当2为根节点时，其左子树节点个数为1，右子树节点为n-2，所以可得G(n) = G(0) * G(n-1) + G(1) * (n-2) + ... + G(n-1) * G(0)

动态规划：
    假设n个节点存在二叉排序树的个数是G(n)，令f(i)为以i为根的二叉搜索树的个数

    即有:G(n) = f(1) + f(2) + f(3) + f(4) + ... + f(n)

    n为根节点，当i为根节点时，其左子树节点个数为[1,2,3,...,i-1]，右子树节点个数为[i+1,i+2,...n]，所以当i为根节点时，其左子树节点个数为i-1个，右子树节点为n-i，即f(i) = G(i-1)*G(n-i),

    上面两式可得:G(n) = G(0)*G(n-1)+G(1)*(n-2)+...+G(n-1)*G(0)
![https://leetcode-cn.com/problems/unique-binary-search-trees/solution/96-bu-tong-de-er-cha-sou-suo-shu-dong-ta-vn6x/]
    dp[3]，就是 元素1为头结点搜索树的数量 + 元素2为头结点搜索树的数量 + 元素3为头结点搜索树的数量
    元素1为头结点搜索树的数量 = 右子树有2个元素的搜索树数量 * 左子树有0个元素的搜索树数量
    元素2为头结点搜索树的数量 = 右子树有1个元素的搜索树数量 * 左子树有1个元素的搜索树数量
    元素3为头结点搜索树的数量 = 右子树有0个元素的搜索树数量 * 左子树有2个元素的搜索树数量
    有2个元素的搜索树数量就是dp[2]。
    有1个元素的搜索树数量就是dp[1]。
    有0个元素的搜索树数量就是dp[0]。
    所以dp[3] = dp[2] * dp[0] + dp[1] * dp[1] + dp[0] * dp[2]
```c++
class Solution {
public:
    int numTrees(int n) {
        vector<int> dp(n + 1, 0);   // 令 G(i) = dp[i]
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 2; i <= n; i++){       //算G(n)
            // 计算 n = i 的个数，既 G(i)
            for (int j = 1; j <= i; j++) {
                // G(i) = f(1) + f(2) + ... + f(i) 令 j ∈ [1, i]
                // f(j) = G(j-1) * G(i-j)
                dp[i] += dp[j - 1] * dp[i - j];
            }   //算f(i)
        }
        return dp[n];
    }
};
```


## 52. 98-中等-验证二叉搜索树
**困难**
- 题目描述
    给定一个二叉树，判断其是否是一个有效的二叉搜索树。假设一个二叉搜索树具有如下特征：节点的左子树只包含小于当前节点的数。节点的右子树只包含大于当前节点的数。所有左子树和右子树自身必须也是二叉搜索树。
- 思路：递归，重点是用一个点来做记录，有两种递归方式，但都不是很懂
```c++
class solution {
public:
    TreeNode* pre = nullptr;    //  用来记录前一个结点
    bool isValidBST(TreeNode* root) {
        if(!root)
            return true;
        bool left = isValidBST(root->left);
        
        if(pre && pre->val >= root->val)
            return false;
        pre = root;

        bool right = isValidBST(root->right);
        return left && right;
        /* // or
        return helper(root, nullptr, nullptr); */
    }
    bool helper(TreeNode* root, TreeNode* min, TreeNode* max) {
    // helper的作用：只比较root结点和它的两个孩子结点之间的值，在孩子层比较
    // 这里的root是以孩子结点的身份，min和max可以想象其中一个是root的父亲，其实都是
    // max和min只是root父亲作为大小判断的职能
        if(!root)   
            return true;
        if(min && min->val >= root->val)
            return false;
        if(max && max->val <= root->val)
            return false;
        return helper(root->left, min, root) && helper(root->right, root, max);
    }
};
```

## 53. 101-简单-对称二叉树
**中等**
- 题目描述
    给定一个二叉树，检查它是否是镜像对称的。例如，二叉树 [1,2,2,3,4,4,3] 是对称的。
- 思路：把一棵树当两棵树来判断就好了，无脑递归
```c++
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        return helper(root, root);
    }
    bool helper(TreeNode* r1, TreeNode* r2) {
        if(!r1 && !r2) return true;
        if(!r1 || !r2) return false;
        if(r1->val != r2->val)  return false;
        return helper(r1->left, r2->right) && helper(r1->right, r2->left);
    }
};
```

## 54. 102-中等-二叉树的层序遍历
**简单**
- 题目描述  
    给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。
- 示例：
二叉树：[3,9,20,null,null,15,7],
         3
        / \
       9  20
         /  \
        15   7
    返回其层序遍历结果：
    [
    [3],
    [9,20],
    [15,7]
    ]
- 思路：
    1. 非递归：比较熟了，用队列，需要注意的是在每次迭代时队列的长度大小要在开始时存起来用，因为是会变化的
    2. 递归：技巧，因为level层数=res.size()，所以可以在递归中记录每一层，然后在每一次递归中添加数据 
```c++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> res;
        if(!root)
            return res;
        queue<TreeNode*> q;
        q.push(root);
        while(!q.empty()) {
            int sz = q.size();
            vector<int> level;
            for(int i = 0; i< sz; i++) {
                TreeNode* tmp = q.front();
                q.pop();
                level.push_back(tmp->val);
                // 下一层的数据进入队列
                if(tmp->left)   q.push(tmp->left);
                if(tmp->right)  q.push(tmp->right);
            }
            res.push_back(level);
        }
        return res;
    }
    // or 递归版本 慢好多?
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> res;
        if(!root)
            return res;
        helper(root, res, 0);
        return res;
    }
    void helper(TreeNode* root, vector<vector<int>>& res, int level) {
        if(res.size() == level)
            res.push_back(vector<int>());
        res[level].push_back(root->val);
        if(root->left)  helper(root->left, res, level+1);
        if(root->right) helper(root->right, res, level+1);
    }
};
```

## 55. 103-中等-二叉树的锯齿形层序遍历
**中等**
- 题目描述
    给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。
给定二叉树?[3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
返回锯齿形层序遍历如下：
[
[3],
[20,9],
[15,7]
]
- 思路：就是在层间遍历那里加入顺序的调整，也有递归跟非递归的队列
```c++
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        vector<vector<int>> res;
        if(!root)
            return res;
        return helper(root, res, 0);
    }
    vector<vector<int>> helper(TreeNode *root, vector<vector<int>> &res, int level){
        if(level == res.size())
            res.push_back(vector<int>());
        if (level % 2 != 0)
            res[level].push_back(root->val);
        else
            res[level].insert(res[level].begin(),root->val);
        if(root->right)
            helper(root->right, res, level + 1);
        if(root->left)
            helper(root->left, res, level + 1);
        return res;
    }
};
// or
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        vector<vector<int>> res;
        if(!root)
            return res;
        queue<TreeNode *> que;
        que.push(root);
        int level = 0;  // 这里要有一个层数来确定方向
        while(!que.empty()){
            vector<int> level_data;
            int level_size = que.size();
            while(level_size--){
                TreeNode *tmp = que.front();
                que.pop();
                if (level % 2 == 0)
                    level_data.push_back(tmp->val);
                else
                    level_data.insert(level_data.begin(), tmp->val);
                if(tmp->left)
                    que.push(tmp->left);
                if(tmp->right)
                    que.push(tmp->right);   
            }
            level++;
            res.push_back(level_data);
        }
        return res;
    }
};
```

## 56. 104-简单-二叉树的最大深度
**简单**
- 题目描述
    给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。说明:?叶子节点是指没有子节点的节点。
- 示例：
给定二叉树 [3,9,20,null,null,15,7]，
    3
   / \
  9  20
    /  \
   15   7       返回它的最大深度?3 。
- 思路：递归计算左右子树的最大深度+1便是答案; 非递归的话用层间遍历层数就可以了
```c++
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if (!root){
            return 0;
        }else {
            int left_depth = maxDepth(root->left);
            int right_depth = maxDepth(root->right);
            int total_depth = left_depth > right_depth ? left_depth : right_depth;
            return total_depth + 1;
        }
    }
};
int maxDepth(TreeNode* root) {
    if(root == NULL)
        return 0;
    int num = 0;
    queue<TreeNode *> que;
    que.push(root);
    while(!que.empty()){
        int n = que.size();
        for(int i = 0;i < n;++i){
            TreeNode *cur = que.front();
            if(cur->left != NULL)
                que.push(cur->left);
            if(cur->right != NULL)
                que.push(cur->right);
            que.pop();
        }
        num++;
    }
    return num;
}
```


## 57. 105-中等-从前序与中序遍历序列构造二叉树
**中等**
- 题目描述
    注意:你可以假设树中没有重复的元素。
- 例如给出
前序遍历 preorder =?[3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
返回如下的二叉树：
    3
   / \
  9  20
    /  \
   15   7
- 思路：从前序中确定根结点，再到中序中确定左右结点，递归的终止条件
```c++
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        int presize = preorder.size();
        int insize = inorder.size();
        if(presize != insize || presize < 1 || insize < 1)
            return nullptr;
        return helper(preorder, inorder, 0, presize-1, 0, insize-1);
    }
    TreeNode* helper(vector<int>& porder, vector<int>& iorder, int pleft, int pright, int ileft, int iright) {
        if(pleft > pright || ileft > iright)
            return nullptr;
        TreeNode* root = new TreeNode(porder[pleft]);
        int rootInInorder = ileft;
        while(porder[pleft] != iorder[rootInInorder]) rootInInorder++;
        int left = rootInInorder - ileft;
        root->left = helper(porder, iorder, pleft+1, pleft+left, ileft, rootInInorder-1);
        root->right = helper(porder, iorder, pleft+left+1, pright, rootInInorder+1, iright);
        return root;
    }
};
```


## 58. 108-简单-将有序数组转换为二叉搜索树
**中等**
- 题目描述
    将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。本题中，一个高度平衡二叉树是指一个二叉树每个节点?的左右两个子树的高度差的绝对值不超过 1。
- 示例:
给定有序数组: [-10,-3,0,5,9],
一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：
      0
     / \
   -3   9
   /   /
 -10  5
- 思路：分治
```c++
class Solution {
public:
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        return help(nums, 0, nums.size() - 1);
    }
    TreeNode* help(vector<int>& nums, int l, int r) {
        if (l > r) return nullptr;
        int mid = l + ((r - l) >> 1);
        TreeNode* root = new TreeNode(nums[mid]);
        root->left = help(nums, l, mid - 1);
        root->right = help(nums, mid + 1, r);
        return root;
    }
};
```

## 59. 109-中等-有序链表转换二叉搜索树
**中等**
- 题目描述
    给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。
    本题中，一个高度平衡二叉树是指一个二叉树每个节点?的左右两个子树的高度差的绝对值不超过 1。
- 示例:
    给定的有序链表： [-10, -3, 0, 5, 9],
    一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：
      0
     / \
   -3   9
   /   /
 -10  5
- 思路：
    1. 将链表遍历一遍存到一个数组中，然后根据108题的办法来解决
    2. 快慢指针
```c++
class Solution {
public:
    TreeNode* sortedListToBST(ListNode* head) {
        if(!head)
            return nullptr;
        vector<int> vec;
        while(head) {
            vec.push_back(head->val);
            head = head->next;
        }
        return buildBST(vec, 0, vec.size());
    }
    TreeNode* buildBST(vector<int>& vec, int l, int r) {
        if(l == r)
            return nullptr;
        int mid = (l + r) >> 1;
        TreeNode* root = new TreeNode(vec[mid]);
        root->left = buildBST(vec, l, mid);
        root->right = buildBST(vec, mid+1, r);
        return root;
    }
};
class Solution {
public:
    TreeNode* sortedListToBST(ListNode* head) {   
        if(!head)
            return nullptr;
        TreeNode* root; 
        if(!head->next){
            root = new TreeNode(head->val);
            return root;
        }        
        ListNode *slow = head;
        ListNode *fast = head;
        ListNode *prev = head;
        while(fast != NULL && fast->next != NULL){
            fast = fast->next->next;
            slow = slow->next;
        }
        while(prev->next != slow)
            prev = prev->next;     
        root = new TreeNode(slow->val);
    
        ListNode* headRight = slow->next;
        ListNode* headLeft = head;

        prev->next = nullptr;   // 关键！要断开来，否则会溢出

        root->left = sortedListToBST(headLeft);
        root->right = sortedListToBST(headRight);
        return root;
    } 
};
```

## 60.  113-中等-路径总和 II
**中等**
- 题目描述
给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。
说明:?叶子节点是指没有子节点的节点。
- 示例:
给定如下二叉树，以及目标和?sum = 22，
              5
             / \
            4   8
           /   / \
          11  13  4
         /  \    / \
        7    2  5   1
返回:
[
   [5,4,11,2],
   [5,8,4,5]
]
- 思路：dfs
```c++
class Solution {
public:
    vector<vector<int>> ans;
    vector<int> path;
    vector<vector<int>> pathSum(TreeNode* root, int sum) {
        if(!root)
            return ans;
        dfs(root, sum);
        return ans;
    }
    void dfs(TreeNode* root, int sum) {
        if(!root)
            return;
        path.push_back(root->val);
        //这里要在push_back后面才能判断
        if(root->val == sum && !root->left && !root->right)
            ans.push_back(path);
        dfs(root->left, sum-root->val);
        dfs(root->right, sum-root->val);
        path.pop_back();
    }
};
```

## 61.  114-中等-二叉树展开为链表
**中等**
- 题目描述
    给你二叉树的根结点 root ，请你将它展开为一个单链表：
    展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。
    展开后的单链表应该与二叉树 先序遍历 顺序相同。
- 思路：两种，非递归与递归 ![https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by--26/]
```c++
/* 非递归：
将左子树插入到右子树的地方
将原来的右子树接到左子树的最右边节点
考虑新的右子树的根节点，一直重复上边的过程，直到新的右子树为 null */
class Solution {
public:
    void flatten(TreeNode* root) {
        TreeNode* node = root;
        while(node) {
            if(!node->left) //左子树为 null，直接考虑下一个节点
                node = node->right;
            else {
                TreeNode* pre = node->left;// 找左子树最右边的节点
                while(pre->right)
                    pre = pre->right;    // pre 是当前node左孩子的最右子孙
                pre->right = node->right;//将原来的右子树接到左子树的最右边节点
                node->right = node->left;// 将左子树插入到右子树的地方
                node->left = nullptr;
                node = node->right;      // 考虑下一个节点
            }
        }
    }
};
class Solution {
public:
    TreeNode* last = nullptr;
    void flatten(TreeNode* root) {
        if(!root)
            return;
        flatten(root->right);
        flatten(root->left);
        root->right = last;
        root->left = nullptr;
        last = root;
    }
};
```

## 62.  118-简单-杨辉三角
**中等**
- 题目描述
    给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。在杨辉三角中，每个数是它左上方和右上方的数的和。
- 示例:
输入: 5
输出:
[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]
- 思路：
```c++
class Solution {
public:
    vector<vector<int>> generate(int numRows) {
        vector<vector<int>> res(numRows);
        for(int i = 0; i < numRows; i++) {
            vector<int> row(i+1, 0);   // 申请好内存
            row[0] = row[i] = 1;    // 头尾都是1
            // res.push_back(row);     // 这里出错了
            res[i] = row;
            for(int j = 1; j <= i / 2; j++) {
                res[i][j] = res[i-1][j-1]+res[i-1][j];
                //if(j * 2 != i)      // 可有可无
                res[i][i-j] = res[i][j];// 对称位置直接赋值
            }
        }
        return res;
    }
};
```

## 63.  121-简单-买卖股票的最佳时机
**中等** **dp**
- 题目描述
    给定一个数组 prices ，它的第?i 个元素?prices[i] 表示一支给定股票第 i 天的价格。
    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。
    返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。
- 示例：
输入：[7,1,5,3,6,4]         输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
输入：prices = [7,6,4,3,1]  输出：0
解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
- 思路：dp动态规划 前i天的最大收益 = max{前i-1天的最大收益，第i天的价格-前i-1天中的最小价格}
![https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484508&idx=1&sn=42cae6e7c5ccab1f156a83ea65b00b78&chksm=9bd7fa54aca07342d12ae149dac3dfa76dc42bcdd55df2c71e78f92dedbbcbdb36dec56ac13b&scene=21#wechat_redirect]
```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.empty())      // dp[i][k][0] = 第i天、可以交易k次、没有股票时的收益
            return 0;           // dp[i][k][1] = 第i天、可以交易k次、持有股票时的收益
        int dp_i_0 = 0;         // 第i天，0：没有股票，初始化i = -1，k = 1
        int dp_i_1 = INT_MIN;   // 第i天，1：持有股票，初始化i = -1，k = 1，因为一开始不可能持有股票，所以初始化为负无穷
        for (int i = 0; i < prices.size(); i++)
        {
            dp_i_0 = max(dp_i_0, dp_i_1 + price[i]);
            // dp_i_1 = max(dp_i_1, dp_i_0 - price[i]);
            // 因为k = 1只能交易一次，所以初始化dp_i_0表示的收益为0
            dp_i_1 = max(dp_i_1, - price[i]);
        }
        return dp_i_0;
    }
};
```

## 64.  122-中等-买卖股票的最佳时机 II
**中等** **dp**
- 题目描述
给定一个数组，它的第?i 个元素是一支给定股票第 i 天的价格。
设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

- 示例:
输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
?    随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。

输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
?    注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
?    因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。

输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。

- 思路：就是上一题的 k = 正无穷多次，可以贪心算法，可以dp
```c++
/* [7, 1, 5, 6] 第二天买入，第四天卖出，收益最大（6-1），所以一般人可能会想，怎么判断不是第三天就卖出了呢? 
这里就把问题复杂化了，根据题目的意思，当天卖出以后，当天还可以买入
所以其实可以第三天卖出，第三天买入，第四天又卖出（（5-1）+ （6-5） === 6 - 1）。
所以算法可以直接简化为只要今天比昨天大，就卖出。 */
// 贪心
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int profit(0);
        for(int i = 0; i < prices.size(); i++) {
            if(i>0 && prices[i] > prices[i-1])
                profit += prices[i]-prices[i-1];
        }
        return profit;
    }
};
// dp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int dp_i_0 = 0;
        int dp_i_1 = INT_MIN;
        for(int i = 0; i < prices.size(); i++) {
            dp_i_0 = max(dp_i_0, dp_i_1 + prices[i]); // 手上没有股票时的收益 = max{不操作，有股票时把股票卖了}
            dp_i_1 = max(dp_i_1, dp_i_0 - prices[i]); // 手上持有股票时的收益 = max{不操作，没股票时把股票买了}
        }
        return dp_i_0;  // 当然是在最后一天前把股票卖了钱才是最多的
    }
};
```

## 65.  125-简单-验证回文串
**中等**
- 题目描述
    给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。
    说明：本题中，我们将空字符串定义为有效的回文串。
- 示例 :
    输入: "A man, a plan, a canal: Panama"      输出: true
    输入: "race a car"                          输出: false
- 思路：字符串操作
    1. isalnum(c) 判断是不是`字符或数字`，因此适合本题
    2. isspace(c) 判断是不是`空格`，因为本题含有标点符号，因此不适合本题
    3. toupper(c) 转换为大写字母，对于数字也见效
    4. tolower(c) 转换为小写字母，对于数字也见效

*分享个字母大小写转换的方法：* 对于数字也见效，比tolower() 或 toupper更快
*统一转成大写：ch & 0b11011111 简写：ch & 0xDF*
*统一转成小写：ch | 0b00100000 简写：ch | 0x20*
*比较的时候注意加上小括号哦，因为位运算优先级比较低。*
```c++
class Solution {
public:
    bool isPalindrome(string s) {
        for (int b = 0, e = s.size() - 1; b < e; b++, e--) {
            while (!isalnum(s[b]) && b < e)
                b++;
            while (!isalnum(s[e]) && b < e)
                e--;
            if (toupper(s[b]) != toupper(s[e]))
                return false;
        }
        return true;
    }
};
```

## 66.  136-简单-只出现一次的数字
**简单**
- 题目描述
    给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
    说明：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？
- 示例:
输入: [2,2,1]       输出: 1
输入: [4,1,2,1,2]   输出: 4
- 思路：
    1. 不需要额外空间的方法，就往位运算上想
    2. 除了异或以外，还可以用哈希表噢
```c++
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int res = 0;
        for (int i = 0; i != nums.size(); i++)
            res ^= nums[i];
        return res;
        // return accumulate(nums.begin(),nums.end(),0,bit_xor()); // 一行异或
    }
};
```


## 67.  137-中等-只出现一次的数字 II
**简单**
- 题目描述
    给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。
    说明：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？
- 示例:
    输入: [2,2,3,2]             输出: 3
    输入: [0,1,0,1,0,1,99]      输出: 99
- 思路：每个元素均为32bit，那么出现三次的元素在它的32bit中的每个bit出现1的次数肯定可以整除3
```c++
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int res = 0;
        for(int i = 0; i < 32; i++){    //每一位都要计算
            int count = 0;
            for (int j = 0; j < nums.length; j++) {
                //先将数右移，并求出最后一位为 1 的个数
                if ( ( (nums[j] >> i) & 1) == 1) //计算每个数的第i位中1的个数
                    count++;            
            }
            //找到某一位取余为 1 的数，并左移，为了将这一位循环结束后移至原位
            if (count % 3 != 0) 
                res = res | (1 << i);
        }
        return res; 
    }
};
```

## 68.  139-中等-单词拆分
**困难** **dp**
- 题目描述
    给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定?s 是否可以被空格拆分为一个或多个在字典中出现的单词。
    说明：拆分时可以重复使用字典中的单词。你可以假设字典中没有重复的单词。
- 示例：
输入: s = "leetcode", wordDict = ["leet", "code"]                           输出: true
解释: 返回 true 因为 "leetcode" 可以被拆分成 "leet code"

输入: s = "applepenapple", wordDict = ["apple", "pen"]                      输出: true
解释: 返回 true 因为 "applepenapple" 可以被拆分成 "apple pen apple"。注意你可以重复使用字典中的单词。

输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]     输出: false

- 思路：

动规五部曲分析如下：

1. 确定dp数组以及下标的含义
dp[i] : 字符串长度为i的话，dp[i]为true，表示可以拆分为一个或多个在字典中出现的单词。

2. 确定递推公式
如果确定dp[j] 是true，且 [j, i] 这个区间的子串出现在字典里，那么dp[i]一定是true。（j < i ）。
所以递推公式是 if([j, i] 这个区间的子串出现在字典里 && dp[j]是true) 那么 dp[i] = true。

3. dp数组如何初始化
从递归公式中可以看出，dp[i] 的状态依靠 dp[j]是否为true，那么dp[0]就是递归的根基，dp[0]一定要为true，否则递归下去后面都都是false了。

那么dp[0]有没有意义呢？

dp[0]表示如果字符串为空的话，说明出现在字典里。

但题目中说了“给定一个非空字符串 s” 所以测试数据中不会出现i为0的情况，那么dp[0]初始为true完全就是为了推导公式。

下标非0的dp[i]初始化为false，只要没有被覆盖说明都是不可拆分为一个或多个在字典中出现的单词。

4. 确定遍历顺序
题目中说是拆分为一个或多个在字典中出现的单词，所以这是完全背包。

还要讨论两层for循环的前后循序。

`如果求组合数就是外层for循环遍历物品，内层for遍历背包。`

`如果求排列数就是外层for遍历背包，内层for循环遍历物品。` 排 外 包

本题最终要求的是是否都出现过，所以对出现单词集合里的元素是组合还是排列，并不在意！

那么本题使用求排列的方式，还是求组合的方式都可以。

即：外层for循环遍历物品，内层for遍历背包 或者 外层for遍历背包，内层for循环遍历物品 都是可以的。

但本题还有特殊性，因为是要求子串，最好是遍历背包放在外循环，将遍历物品放在内循环。

如果要是外层for循环遍历物品，内层for遍历背包，就需要把所有的子串都预先放在一个容器里。（如果不理解的话，可以自己尝试这么写一写就理解了）

所以最终我选择的遍历顺序为：遍历背包放在外循环，将遍历物品放在内循环。内循环从前到后。

5. 举例推导dp[i]

```c++
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        unordered_set<string> wordSet(wordDict.begin(), wordDict.end());
        vector<bool> dp(s.size() + 1, false);
        dp[0] = true;
        for (int i = 1; i <= s.size(); i++) {   // 遍历背包 
            for (int j = 0; j < i; j++) {       // 遍历物品
                string word = s.substr(j, i - j); //substr(起始位置，截取的个数)
                if (wordSet.find(word) != wordSet.end() && dp[j]) {
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[s.size()];
    }
};
```
```c++
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        //auto wordDictSet = unordered_set <string> ();
        /* 如果"onetwothree"这一段可以拆分，再加上four如果也可以，那不就行了；
        或者
        如果"onetwothre"这一段可以拆分，再加上efour如果也可以，那不就行了；
        这其实已经抓住了动态规划的最核心的东西了，换成式子来表达，就是
        dp["onetwothreefour"] = dp["onetwothree"这一段] && 判断一下"four"
        dp["onetwothreefour"] = dp["onetwothre"这一段] && 判断一下"efour" */

        unordered_set<string> wordDictSet;
        for (string word: wordDict) {
            wordDictSet.insert(word);
        }

        auto dp = vector<bool> (s.size() + 1);
        dp[0] = true;
        for (int i = 1; i <= s.size(); ++i) {
            for (int j = 0; j < i; ++j) {
                if (dp[j] && wordDictSet.find(s.substr(j, i - j)) != wordDictSet.end()) {
                    dp[i] = true;
                    break;
                }
            }
        }

        return dp[s.size()];
    }
};

```

## 69.  141-简单-环形链表
**简单**
- 题目描述
给定一个链表，判断链表中是否有环。
如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。
如果链表中存在环，则返回 true 。 否则，返回 false 。
进阶：你能用 O(1)（即，常量）内存解决此问题吗？
- 思路：快慢指针，若有环则双指针一定会重合
```c++
class Solution {
public:
    bool hasCycle(ListNode *head) {
        if (!head || !head->next){
            return false;
        }
        ListNode *slow = head;
        ListNode *fast = head->next;
        while(slow != fast){
            if (!fast || !fast->next){
                return false;
            }
            slow = slow->next;
            fast = fast->next->next;
        }
        return true;
    }
};
```

## 70.  142-中等-环形链表 II
**中等**
- 题目描述
给定一个链表，返回链表开始入环的第一个节点。?如果链表无环，则返回?null。
为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。
说明：不允许修改给定的链表。
进阶：你是否可以使用 O(1) 空间解决此题？
- 思路：分两个步骤，首先通过快慢指针的方法判断链表是否有环；接下来如果有环，则寻找入环的第一个节点。具体的方法为，首先假定链表起点到入环的第一个节点A的长度为a【未知】，到快慢指针相遇的节点B的长度为（a + b）【这个长度是已知的】。现在我们想知道a的值，注意到快指针p2始终是慢指针p走过长度的2倍，所以慢指针p从B继续走（a + b）又能回到B点，如果只走a个长度就能回到节点A。但是a的值是不知道的，解决思路是曲线救国，注意到起点到A的长度是a，那么可以用一个从起点开始的新指针q和从节点B开始的慢指针p同步走，相遇的地方必然是入环的第一个节点A。 文字有点绕，画个图就一目了然了~~ 
```c++
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        if(!head)
            return nullptr;
        ListNode *fast = head;
        ListNode *slow = head;
        while(fast->next && fast->next->next) {
            fast = fast->next->next;
            slow = slow->next;
            if(fast == slow)
                break;
        }
        if(!fast->next || !fast->next->next)     
            return nullptr;     // 判断为无环
        slow = head;
        while(slow != fast) {
            slow = slow->next;
            fast = fast->next;
        }
        return slow;
    }
};
```


## 71.  143-中等-重排链表
**中等**
- 题目描述
    给定一个单链表?L：L0→L1→…→Ln-1→Ln ，
    将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…
    你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。
- 示例:
给定链表 1->2->3->4, 重新排列为 1->4->2->3.
给定链表 1->2->3->4->5, 重新排列为 1->5->2->4->3.
- 思路：
    1. （好一点）用hash表<int, TreeNode*>来记录<索引，结点>，然后遍历表再头尾对接就可以了
    2. （麻烦的）用快慢指针找到链表中点，翻转后半部分的链表，然后再一个个头尾对接
```c++
class Solution {
public:
    void reorderList(ListNode* head) {
        if(!head || !head->next || !head->next->next)
            return;
        //找中点，链表分成两个
        ListNode* slow = head;
        ListNode* fast = head;
        while (fast->next && fast->next->next) {
            slow = slow->next;
            fast = fast->next->next;
        }

        ListNode* newHead = slow->next;
        slow->next = nullptr;

        //第二个链表倒置
        newHead = reverseList(newHead);

        //链表节点依次连接
        while (newHead) {
            ListNode* temp = newHead->next;
            newHead->next = head->next;
            head->next = newHead;
            head = newHead->next;
            newHead = temp;
        }
    }
private:
    ListNode* reverseList(ListNode* head) {
        if (!head) return nullptr;
        ListNode* tail = head;
        head = head->next;
        tail->next = nullptr;
        while (head) {
            ListNode* temp = head->next;
            head->next = tail;
            tail = head;
            head = temp;
        }
        return tail;
    }
        /* unordered_map<int, ListNode*> map;
        int num = 0;
        while(head) {
            map[num] = head;
            num++;
            head = head->next;
        }
        num--; //转为索引
        if(num < 2)
            return; //如果只是两个节点那没必要
        int i = 0;
        while(i < num) {
            map[i]->next = map[num];
            i++;
            if(i==num)
                break;
            map[num]->next = map[i];
            num--;
        }
        map[i]->next = nullptr;//别忘了
        } */
};
```

## 72.  144-中等-二叉树的前序遍历
**中等** 去94题

## 73.  146-中等-LRU 缓存机制（未）
**中等**
- 题目描述
运用你所掌握的数据结构，设计和实现一个? LRU (最近最少使用) 缓存机制 。
实现 LRUCache 类：
1. LRUCache(int capacity) 以正整数作为容量?capacity 初始化 LRU 缓存
2. int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。
3. void put(int key, int value)?如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。

进阶：你是否可以在?O(1) 时间复杂度内完成这两种操作？

- 思路：链表 + 哈希

```c++
struct DLNode
{
    DLNode *next;
    DLNode *pre;
    int key;
    int val;
    DLNode(int k, int v):key(k), val(v), next(nullptr), pre(nullptr) {}
    DLNode():key(0), val(0), next(nullptr), pre(nullptr) {}
};

class LRUCache {
private:
    int _size;
    int _capacity;
    DLNode *head;
    DLNode *tail;
    unordered_map<int, DLNode *> cache;

public:
    LRUCache(int capacity) {
        _size = 0;
        _capacity = capacity;
        head = new DLNode();
        tail = new DLNode();
        head->next = tail;
        tail->pre = head;
    }
    
    int get(int key) {
        if(!cache.count(key))
            return -1;
        DLNode *node = cache[key];
        moveToHead(node);
        return node->val;
    }
    
    void put(int key, int value) {
        if(!cache.count(key)) {
            DLNode *node = new DLNode(key, value);
            addNode(node);
            cache[key] = node;
            ++_size;
            if(_size > _capacity) {
                DLNode *nodeToDelete = deleteNode();
                cache.erase(nodeToDelete->key);
                delete nodeToDelete;
                nodeToDelete = nullptr;
                --_size;
            }
        }else {
            DLNode *node = cache[key];
            node->val = value;
            moveToHead(node);
        }
    }
    void addNode(DLNode *node) {
        node->next = head->next;
        node->pre = head;
        head->next->pre = node;
        head->next = node;
    }
    void removeNode(DLNode *node) {
        node->next->pre = node->pre;
        node->pre->next = node->next;
    }
    void moveToHead(DLNode *node) {
        removeNode(node);
        addNode(node);
    }
    DLNode* deleteNode() {
        DLNode *node = tail->pre;
        removeNode(node);
        return node;
    } 
};

```


## 74.  148-中等-排序链表
**中等**
- 题目描述
    给你链表的头结点?head?，请将其按 升序 排列并返回 排序后的链表 。
    进阶：你可以在?O(n?log?n) 时间复杂度和常数级空间复杂度下，对链表进行排序吗？
- 示例：
    输入：head = [4,2,1,3]      输出：[1,2,3,4]
    输入：head = [-1,5,3,4,0]   输出：[-1,0,3,4,5]
    输入：head = []             输出：[]
- 思路：用归并排序的思路，1 从中间分开两段， 2 递归来merge 3 归并
        用哈希可以吗？但空间复杂度就要有O(n)，似乎不用哈希表用vector也方便
```c++
class Solution {
public:
    ListNode * sortList(ListNode * head)
    {
        return  (head == NULL)? NULL: mergeSort(head);
    }
private:
    ListNode * findMid(ListNode * head)
    {
        ListNode * slow = head;
        ListNode * fast = head;
        ListNode * previous = NULL;
        while (fast != NULL && fast->next != NULL)
        {
            previous = slow;
            slow = slow->next;
            fast = fast->next->next;
        }
        // split the list into two parts
        previous->next = NULL;
        return slow;
    }

    ListNode * mergeTwoLists(ListNode * l1, ListNode * l2)
    {
        if(l1 == NULL) return l2;
        if(l2 == NULL) return l1;
        if(l1->val < l2->val){
            l1->next = mergeTwoLists(l1->next,l2);
            return l1;
        }else{
            l2->next = mergeTwoLists(l1,l2->next);
            return l2;
        }
    }

    ListNode * mergeSort(ListNode * head)
    {
        if (head->next == NULL) return head;
        ListNode * mid = findMid(head);
        ListNode * l1 = mergeSort(head);
        ListNode * l2 = mergeSort(mid);
        return mergeTwoLists(l1, l2);
    }

};
```

## 75.  150-中等-逆波兰表达式求值
**中等**
- 题目描述
逆波兰表达式：逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。

平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。
该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。

逆波兰表达式主要有以下两个优点：
去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。
适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。

- 示例：
输入: ["2", "1", "+", "3", "*"]
输出: 9
解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9

输入: ["4", "13", "5", "/", "+"]
输出: 6
解释: 该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6

输入: ["10", "6", "9", "3", "+", "-11", "*", "/", "*", "17", "+", "5", "+"]
输出: 22
解释: 
该算式转化为常见的中缀算术表达式为：
  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22

- 思路：数字进栈，遇到符号就出栈，运算
常用：
int -> string:  int n = atoi(s.c_str());
string -> int:  string s = to_string(n);

```c++
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        stack<string> stk;
        for(int i = 0; i < tokens.size(); i++) {
            if(tokens[i] != "+" && tokens[i] != "-" && tokens[i] != "*" && tokens[i] != "/")
                stk.push(tokens[i]);
            else {
                string s1 = stk.top(); stk.pop();
                string s2 = stk.top(); stk.pop();
                string tmp = doMath(s1, s2, tokens[i]);
                stk.push(tmp);
            }
        }
        int res = atoi(stk.top().c_str());  
        return res;
    }
    string doMath(string s1, string s2, string sign) {
        int n1 = atoi(s1.c_str());
        int n2 = atoi(s2.c_str());
        string tmp;
        if(sign == "+")
            tmp = to_string(n2+n1);
        else if(sign == "-")
            tmp = to_string(n2-n1);
        else if(sign == "*")
            tmp = to_string(n2*n1);
        else
            tmp = to_string(n2/n1);
        /* switch(sign) {
            case "+" :
                tmp = to_string(n2+n1); break;
            case "-" :
                tmp = to_string(n2-n1); break;
            case "*" :
                tmp = to_string(n2*n1); break;
            case "\" :
                tmp = to_string(n2/n1); break;
        } */
        return tmp;
    }
};
```

## 76.  151-中等-乘积最大子数组
**中等**
- 题目描述
给你一个整数数组 nums?，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。
- 示例:
输入: [2,3,-2,4]
输出: 6
解释:?子数组 [2,3] 有最大乘积 6。

输入: [-2,0,-1]
输出: 0
解释:?结果不能为 2, 因为 [-2,-1] 不是子数组。
- 思路：子数组意味着连续、有负数要注意大小
```c++
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int sz = nums.size();
        if(sz == 0)
            return 0;
        int preMax = nums[0];
        int preMin = nums[0];
        int curMax;
        int curMin;
        int res = nums[0];
        // 这里自己尝试不用preMax或preMin的原因是，在'='右边时cur可以充当pre
        // 但是不知道为什么就是要滚动变量才能通过
        for(int i = 1; i < sz; i++) {
            if(nums[i] >= 0) {
                curMax = max(nums[i], nums[i] * preMax);
                curMin = min(nums[i], nums[i] * preMin);
            }else {
                curMax = max(nums[i], nums[i] * preMin);
                curMin = min(nums[i], nums[i] * preMax);
            }
            res = max(res, curMax);
            preMax = curMax;
            preMin = curMin;
        }
        return res;
        /* vector<vector<int>> dp(sz,vector<int>(2,0));
        // dp[i][0]：以 nums[i] 结尾的连续子数组的最小值
        // dp[i][1]：以 nums[i] 结尾的连续子数组的最大值
        dp[0][0] = nums[0];
        dp[0][1] = nums[0];
        for(int i = 1; i < sz; i++) {
            if(nums[i] >= 0) {
                dp[i][0] = min(nums[i], nums[i] * dp[i - 1][0]);
                dp[i][1] = max(nums[i], nums[i] * dp[i - 1][1]);
            }else {
                dp[i][0] = min(nums[i], nums[i] * dp[i - 1][1]);
                dp[i][1] = max(nums[i], nums[i] * dp[i - 1][0]);
            }
        }
        int res = dp[0][1];
        for(int i = 1; i < sz; i++)
            res = max(res, dp[i][1]);
        return res; */
    }
};
```


## 77.  155-简单-最小栈
**中等**
- 题目描述
设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。

push(x) —— 将元素 x 推入栈中。
pop()?—— 删除栈顶的元素。
top()?—— 获取栈顶元素。
getMin() —— 检索栈中的最小元素。

- 思路：要两个stack来完成，s1用来完成平时的栈功能，s2用来完成getMin()功能
```c++
#include <stack>
class MinStack {
public:
    /** initialize your data structure here. */
    MinStack() {

    }  
    void push(int x) {
        s1.push(x);
        if (s2.empty() || x <= getMin()){
            s2.push(x);
        }
    }    
    void pop() {
        if (s1.top() == getMin()){
            s2.pop();
        }
        s1.pop();
    }   
    int top() {
        return s1.top();
    }   
    int getMin() {
        return s2.top();
    }
private:
    stack<int> s1;//real one    是栈的功能
    stack<int> s2;//needed one  从底到顶越来越小
};
```

## 78.  160-简单-相交链表
**简单**
- 题目描述
编写一个程序，找到两个单链表相交的起始节点。

- 思路：用两个指针去分别遍历两个链表，当它们各自遍历完成后，再去分别遍历另一个链表，如果相遇，相遇点就是所求

```c++
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        if(!headA || !headB)
            return nullptr;
        ListNode* curA = headA;
        ListNode* curB = headB;
        // 上面思路写得有点漏洞，因为两个指针最终总会相遇到nullptr（如果不重合）
        while(curA != curB) {
            /* curA = (curA == nullptr ? headB : curA->next);
            curB = (curB == nullptr ? headA : curB->next); */
            // or
            if(curA)
                curA = curA->next;
            else
                curA = headB;
            if(curB)
                curB = curB->next;
            else
                curB = headA;
        }
        return curA;
    }
};
```

## 79.  162-中等-寻找峰值
**困难**
- 题目描述
峰值元素是指其值大于左右相邻值的元素。
给你一个输入数组?nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。
你可以假设?nums[-1] = nums[n] = -∞ 。

- 示例：
输入：nums = [1,2,3,1]
输出：2
解释：3 是峰值元素，你的函数应该返回其索引 2。

输入：nums = [1,2,1,3,5,6,4]
输出：1 或 5 
解释：你的函数可以返回索引 1，其峰值元素为 2；
?    或者返回索引 5， 其峰值元素为 6。

- 思路：用二分法是我没想到的噢

```c++
class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        int sz = nums.size();
        int l = 0; 
        int r = sz-1;
        while(l < r) {
            int mid = (l+r) >> 1;
            /* if(nums[mid] <= nums[mid+1])
                l = mid+1;  // mid的峰值一定在右侧
            else            // 否则在左侧
                r = mid; */
            if(nums[mid] > nums[mid+1])
                r = mid;    // mid的峰值一定在左侧
            else            // 否则在右侧
                l = mid + 1;
        }
        return l;
    }
};
```

## 80.  169-简单-多数元素
**中等**
- 题目描述
给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于?? n/2 ??的元素。
你可以假设数组是非空的，并且给定的数组总是存在多数元素。

- 示例?：
输入：[3,2,3]               输出：3
输入：[2,2,1,1,1,2,2]       输出：2

- 思路：遍历，用一个cnt计数，如果遍历到当前的数是同样的，那就cnt++，否则cnt--，当cnt==0时重新计数，直到cnt!=0时那个数就是答案。这是利用了`大于?? n/2 ?`这个条件
```c++
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int ans = 0, cnt = 0;
        for(int num : nums) {
            if(cnt == 0) {
                ans = num;
                cnt++;
            }else {
                if(ans == num)
                    cnt++;
                else
                    cnt--;
            }
        }
        return ans;
    }
};
```

## 81.  171-简单-Excel表列序号
**简单**
- 题目描述
给定一个Excel表格中的列名称，返回其相应的列序号。
例如，
    A -> 1
    B -> 2
    C -> 3
    ...
    Z -> 26
    AA -> 27
    AB -> 28 
    ...
- 示例:
输入: "A"       输出: 1
输入: "AB"      输出: 28
输入: "ZY"      输出: 701
- 思路：这就是一个26进制转换为10进制的问题
```c++
class solution {
public:
    int titleToNumber(string s) {
        int res = 0;
        for(char c : s) {
            res = res * 26 + (c - 'A' + 1);
        }
        return res;
    }
};
```



## 82.  172-简单-阶乘后的零
**简单**
- 题目描述
给定一个整数 n，返回 n! 结果尾数中零的数量。
- 示例:
输入: 3     输出: 0
解释:?3! = 6, 尾数中没有零。

输入: 5     输出: 1
解释:?5! = 120, 尾数中有 1 个零.

说明: 你算法的时间复杂度应为?O(log?n)?。

- 思路：零的个数与2和5的个数有关，也与10有关，阶乘中每5个数就会产生一个0，前5个是个位数是2和5，然后5位数是有个10
```c++
class sulotion {
public: 
    trailingZeros(int n) {
        int cnt = 0;
        while(n >= 5) {
            n /= 5;
            cnt += n;
        }
        return cnt;
    }
};
```


## 83.  179-中等-最大数
**中等**
- 题目描述
给定一组非负整数 nums，重新排列它们每个数字的顺序（每个数字不可拆分）使之组成一个最大的整数。
注意：输出结果可能非常大，所以你需要返回一个字符串而不是整数。

- 示例：
输入：nums = [10,2]             输出："210"
输入：nums = [3,30,34,5,9]      输出："9534330"
输入：nums = [1]                输出："1"
输入：nums = [10]               输出："10"

- 思路：锻炼了仿函数和lambda的写法
- sort是关键：return to_string(m) + to_string(n) > to_string(n) + to_string(m);

```c++
class Solution {
public:
    static bool cmp(cosnt int& m, const int& n) {
        return to_string(m) + to_string(n) > to_string(n) + to_string(m);
    }
    string largestNumber(vector<int>& nums) {
        string res;
        // sort(nums.begin(), nums.end(), cmp);
        // or
        sort(nums.begin(), nums.end(), [](const int& m, const int& n) { return to_string(m) + to_string(n) > to_string(n) + to_string(m); });
        for(int n : nums) {
            res += to_string(n);
        }
        if(res[0] == '0')
            return "0";
        return res;
    }
};
```

## 84.  187-中等-重复的DNA序列
**中等**
- 题目描述
所有 DNA 都由一系列缩写为 'A'，'C'，'G' 和 'T' 的核苷酸组成，例如："ACGAATTCCG"。在研究 DNA 时，识别 DNA 中的重复序列有时会对研究非常有帮助。
编写一个函数来找出所有目标子串，目标子串的长度为 10，且在 DNA 字符串 s 中出现次数超过一次。

- 示例：
输入：s = "AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT"
输出：["AAAAACCCCC","CCCCCAAAAA"]

输入：s = "AAAAAAAAAAAAA"
输出：["AAAAAAAAAA"]

- 思路：重复的字符串，那么往哈希表方向想，每次存10个字符，子字符s.substr(i, 10)，从i开始的10个（包括i）
```c++
class Solution {
public:
    vector<string> findRepeatedDnaSequences(string s) {
        vector<string> ans;
        unordered_map<string, int> table;
        for(int i = 0; i + 9< s.size(); i++) {
            string tmpStr = s.substr(i,10);
            if(table.count(tmpStr) && table[tmpStr] == 1)   // 这里==1是为了判断出有重复，然后push_back进res一次就可以了
                ans.push_back(tmpStr);
            table[tmpStr]++;
        }
        return ans;
    }
};
```





## 85.  189-中等-旋转数组
**中等**
- 题目描述
给定一个数组，将数组中的元素向右移动?k?个位置，其中?k?是非负数。
进阶：
尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。
你可以使用空间复杂度为?O(1) 的?原地?算法解决这个问题吗？

- 示例:
输入: nums = [1,2,3,4,5,6,7], k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右旋转 1 步: [7,1,2,3,4,5,6]
向右旋转 2 步: [6,7,1,2,3,4,5]
向右旋转 3 步: [5,6,7,1,2,3,4]

输入：nums = [-1,-100,3,99], k = 2
输出：[3,99,-1,-100]
解释: 
向右旋转 1 步: [99,-1,-100,3]
向右旋转 2 步: [3,99,-1,-100]

- 思路：旋转3次就可以了

```c++
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        // 三次翻转搞定
        k = k % nums.size();
        reverse(nums.begin(), nums.begin() + nums.size() - k);  // 旋转前半部分
        reverse(nums.begin() + nums.size() - k, nums.end());    // 旋转后半部分
        reverse(nums.begin(), nums.end());                      // 旋转整个数组
    }
};
```


## 86.  198-中等-打家劫舍
**中等** **dp**
- 题目描述
你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。
- 示例：
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
?    偷窃到的最高金额 = 1 + 3 = 4 。

输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
?    偷窃到的最高金额 = 2 + 9 + 1 = 12 。

- 思路：用一个前变量来记录前    dp 方程 dp[i] = max(dp[i-2]+nums[i], dp[i-1])

```c++
class Solution {
public:
    int rob(vector<int>& nums) {
        int pre_money = 0;
        int cur_money = 0;
        for(int num : nums) {
            int tmp = max(cur_money, pre_money + num);  // dp 方程 dp[i] = max(dp[i-2]+nums[i], dp[i-1])
            pre_money = cur_money;
            cur_money = tmp;
        }
        return cur_money;
    }
};
```

## 87.  199-中等-二叉树的右视图
**中等**
- 题目描述
给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

- 思路：bfs就是层间遍历，dfs深度优先遍历，不用回溯！

```c++
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        vector<int> ans;
        // 以下是bfs
        /* queue<TreeNode*> q;
        if(root)
            q.push(root);
        while(!q.empty()) {
            int sz = q.size();
            for(int i = 0; i < sz; i++) {
                TreeNode* node = q.front();
                q.pop();
                if(i == sz - 1)
                    ans.push_back(node->val);
                if(node->left)
                    q.push(node->left);
                if(node->right)
                    q.push(node->right);
            }
        } */
        // 写一个dfs
        // 关键理解：设树有n层，那么ans.size() = n, n从0开始
        dfs(root, 0, ans);
        return ans;
    }

    void dfs(TreeNode* root, int level, vector<int>& ans) {
        if(!root)
            return;
        // 如果当前节点所在深度还没有出现在res里，说明在该深度下当前节点是第一个被访问的节点，因此将当前节点加入res中
        if(level == ans.size())
            ans.push_back(root->val);
        dfs(root->right, level+1, ans);
        dfs(root->left, level+1, ans);
        // 不用回溯才是最精妙的
    }
};
```

## 88.  200-中等-岛屿数量
**中等**
- 题目描述
给你一个由?'1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。
此外，你可以假设该网格的四条边均被水包围。
- 思路：遍历每个，遍历过了的元素由'1'转'0'，有'0'跳过
```c++
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        int ans = 0;
        for(int i = 0; i < grid.size(); i++) {
            for(int j = 0; j < grid[0].size(); j++) {
                char cur = grid[i][j];
                if(cur == '0')
                    continue;
                else    //发现岛屿
                    Island(grid, i, j); //把这个岛屿灭掉
                ans++;
            }
        }
        return ans;
    }
    void Island(vector<vector<char>>& grid, int i, int j) {
        if(i >= 0 && i < grid.size() && j >= 0 && j < grid[i].size() && grid[i][j] == '1')
            grid[i][j] = '0';
        else
            return;  //如果i或j越界了就会返回了        
        Island(grid, i - 1, j);
        Island(grid, i, j - 1);
        Island(grid, i + 1, j);
        Island(grid, i, j + 1);
    }

};
```

## 89.  202-简单-快乐数
**中等**
- 题目描述
编写一个算法来判断一个数 n 是不是快乐数。

「快乐数」定义为：
对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。
如果 可以变为? 1，那么这个数就是快乐数。
如果 n 是快乐数就返回 true ；不是，则返回 false 。

- 示例：
输入：19        输出：true
解释：
1^2 + 9^2 = 82
8^2 + 2^2 = 68
6^2 + 8^2 = 100
1^2 + 0^2 + 0^2 = 1

输入：n = 2     输出：false

- 思路：快慢指针的思想，初始化fast = slow = n，在一个循环内快数计算两次，慢数计算一次，如果是快乐数，那么fast会比slow先达到1，当fast==slow时跳出循环
- 前提：不是快乐数的数称为不快乐数（unhappy number），所有不快乐数的数位平方和计算，最後都会进入 4 → 16 → 37 → 58 → 89 → 145 → 42 → 20 → 4 的循环中。

```c++
class Solution {
public:
    int BitToSquare(int n){
        if(n == 1)
            return n;
        int sum = 0;
        while (n > 0){
            int tmp = n % 10;
            sum += tmp * tmp;
            n /= 10;
        }
        return sum;
    }
    bool isHappy(int n) {
        int fast = n;
        int low = n;
        do{
            fast = BitToSquare(fast);
            fast = BitToSquare(fast);
            low = BitToSquare(low);
        } while (fast != low);
        return low == 1;
    }
};
```



## 90.  203-简单-移除链表元素
**简单**
- 题目描述
删除链表中等于给定值 val 的所有节点。
- 示例:
输入: 1->2->6->3->4->5->6, val = 6
输出: 1->2->3->4->5
- 思路：干就完了欧里给！
```c++
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        if(head==NULL){
            return head;
        }
        ListNode *p = head;
        while (p->next != NULL){
            if(p->next->val == val){
                p->next = p->next->next;
            }else{
                p = p->next;
            }
        }
        if(head->val == val){
            head = head->next;  // 头部忘记了
        }
        return head;
    }
};
```

## 91.  206-简单-反转链表
**简单**
- 题目描述
反转一个单链表。
- 示例:
输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL

进阶:你可以迭代或递归地反转链表。你能否用两种方法解决这道题？

- 思路：干就完了 欧里给！

```c++
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if(!head)
            return nullptr;
        if(!head->next)
            return head;
        ListNode *cur = head;
        ListNode *pre = nullptr;    // dummy
        ListNode *next = head;
        while (cur->next != nullptr) {
            next = cur->next;
            cur->next = pre;
            pre = cur;
            cur = next;
        }
        cur->next = pre;
        return cur;
    }
    // 递归
        /* if (head == nullptr)
            return nullptr;
        if (head->next == nullptr)
            return head;
        ListNode *p_last = reverseList(head->next);
        head->next->next = head;
        head->next = nullptr;
        return p_last;
    } */
};
```

## 92.  215-中等-数组中的第K个最大元素
**中等**
- 题目描述
在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。

- 示例:
输入: [3,2,1,5,6,4] 和 k = 2            输出: 5
输入: [3,2,3,1,2,4,5,5,6] 和 k = 4      输出: 4

- 思路：1. 暴力法从大到小排序； 2. 小根堆，堆顶总是最小的，控制堆的大小为k就可以了
```c++
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        //大根堆
        //priority_queue<int> pq;   // 默认时大根堆
        //priority_queue<int, vector<int>, less<int>> pq;
        //小根堆    greater是大的排队排前面
        priority_queue<int, vector<int>, greater<int> > pq;
        for(int n : nums) {
            pq.push(n);
            if (pq.size() > k)
                pq.pop();
        }
        return pq.top();
    }
};
```



## 93.  217-简单-存在重复元素
**简单**
- 题目描述
  给定一个整数数组，判断是否存在重复元素。如果存在一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。
- 思路：哈希表 or set
```c++
class Solution {
public:
    bool containsDuplicate(vector<int>& nums) {
        int sz = nums.size();
        if(sz <= 1)
            return false;
        set<int> aSet;
        for(int n : nums)
            aSet.insert(n);
        return aSet.size() != sz;
        /* unordered_map<int, int> table;
        for(int n : nums) {
            if(table.count(n))
                return true;
            else 
                table[n]++;
        }
        return false; */
    }
};
```

## 94.  221-中等-最大正方形
**中等** **dp**
- 题目描述
在一个由 '0' 和 '1' 组成的二维矩阵内，找到只包含 '1' 的最大正方形，并返回其面积。
- 思路：dp 递推公式：dp[i][j] = 1 + min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]);
```c++
class Solution {
public:
    int maximalSquare(vector<vector<char>>& matrix) {
        int m = matrix.size();
        int n = matrix[0].size();
        vector<vector<int>> dp(m+1, vector<int>(n+1,0));
        /*
        vector<vector<int>> dp(m, vector<int>(n,0)); 
        for(int i = 0; i < m; i++)
            if(matrix[i][0] == '1')
                dp[i][0] = 1;
        for(int i = 0; i < n; i++)
            if(matrix[0][j] == '1')
                dp[0][i] = 1; */
        /**
        dp[i][j]表示以第i行第j列为右下角所能构成的最大正方形边长, 则递推式为: 
        dp[i][j] = 1 + min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]);
        **/
        int maxSize = 0;
        for(int i = 0; i < m; i++) {
            for(int j = 0; j < n; j++) {
                if(matrix[i][j] == '1')
                    dp[i+1][j+1] = min(min(dp[i][j], dp[i+1][j]), dp[i][j+1]) + 1;
                    maxSize = max(dp[i+1][j+1], maxSize);
            }
        }
        return maxSize*maxSize;
    }
};
```

## 95.  225-简单-用队列实现栈
**简单**
- 思路：用1个队列，就可以实现push、pop、top、emtyp的功能
```c++
class MyStack {
private:
    queue<int> q;
    int top_elem;   // 额外用一个变量记录就方便很多

public:
    /** Initialize your data structure here. */
    MyStack() {

    }
    
    /** Push element x onto stack. */
    void push(int x) {
        q.push(x);
        top_elem = x;   // 边push边更新
    }
    
    /** Removes the element on top of the stack and returns that element. */
    int pop() {
        // 让队列内的前 n - 1个元素出队再进队，然后更新top元素，头元素就可以pop了
        int size = q.size();
        while (size > 1) {
            q.push(q.front());
            q.pop();
            --size;
        }
        top_elem = q.back();
        int res = q.front();
        q.pop();
        return res;
    }
    
    /** Get the top element. */
    int top() {
        return top_elem;
    }
    
    /** Returns whether the stack is empty. */
    bool empty() {
        return q.empty();
    }
};
/**
 * Your MyStack object will be instantiated and called as such:
 * MyStack* obj = new MyStack();
 * obj->push(x);
 * int param_2 = obj->pop();
 * int param_3 = obj->top();
 * bool param_4 = obj->empty();
 */
```

## 96.  226-简单-翻转二叉树
**中等**
- 题目描述
翻转一棵二叉树。

- 示例：
输入：
     4
   /   \
  2     7
 / \   / \
1   3 6   9
输出：
     4
   /   \
  7     2
 / \   / \
9   6 3   1

- 思路：
    1. 递归：用前序、后序递归均可，但不知为何前序会快一些
    2. 非递归，用层序遍历，双向队列（用栈），但是好像又行不通诶

```c++
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(!root)
            return nullptr;
        /* TreeNode *tmp = root->left;
        root->left = root->right;
        root->right = tmp; */
        //前序遍历
        if(root->left)
            invertTree(root->left);
        if(root->right)
            invertTree(root->right);
        //看函数签名，其实也可以不用有返回的
        TreeNode *tmp = root->left;
        root->left = root->right;
        root->right = tmp;
        //后序遍历
        return root;
    }
};
```

## 97.  227-中等-基本计算器 II
**中等**
- 题目描述
实现一个基本的计算器来计算一个简单的字符串表达式的值。
字符串表达式仅包含非负整数，+， - ，*，/ 四种运算符和空格??。 整数除法仅保留整数部分。

- 示例:
输入: "3+2*2"
输出: 7

输入: " 3/2 "
输出: 1

输入: " 3+5 / 2 "
输出: 5

- 思路：数字进栈，符号处理，遇到??就用top来出来curnum，结果再push进栈，最后全部相加即可
```c++
class Solution {
public:
    int calculate(string s) {
        int num = 0;
        char sign = '+';
        stack<int> stk;
        for (int i = 0; i < s.size(); i++) {
            char c = s[i];
            if(isdigit(c))
                num = num * 10 + (c - '0'); // 转化为数字啦
            if((!isdigit(c) && c != ' ') || i == s.size() - 1) {
                switch (sign)
                {
                int preNum;
                case '+':
                    stk.push(num);
                    break;
                case '-':
                    stk.push(-num);
                    break;
                case '*':
                    preNum = stk.top();
                    stk.pop();
                    stk.push(preNum * num);
                    break;
                case '/':
                    preNum = stk.top();
                    stk.pop();
                    stk.push(preNum / num);
                    break;
                }
                sign = c;
                num = 0;
            }
        }
        int res = 0;
        while(!stk.empty()) {
            res += stk.top();
            stk.pop();
        }
        return res;
    }
};
```

## 98.  230-中等-二叉搜索树中第K小的元素
**中等**
- 题目描述
给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 个最小元素（从 1 开始计数）。

- 思路：
1. 用中序遍历法，把遍历结果存到于vector中，这样就可以在多次查找中方便
2. 用个数的方法
     * 查找左子树节点个数为leftN,如果K<=leftN,则所查找节点在左子树上.
     * 若K=leftN+1,则所查找节点为根节点
     * 若K>leftN+1,则所查找节点在右子树上,按照同样方法查找右子树第K-leftN个节点
3. 用栈代替递归

```c++
class Solution {
public:
    vector<int> res;
    int kthSmallest(TreeNode* root, int k) {
        helper(root);
        return res[k - 1];
    }
    void helper(TreeNode* root) {
        if(root == nullptr)
            return;
        helper(root->left);
        res.push_back(root->val);
        helper(root->right);
    }
};
// or 比较快噢
class Solution {
public:
    int kthSmallest(TreeNode* root, int k) {
        int leftN = findChild(root->left);
        if(leftN >= k)
            return kthSmallest(root->left, k);  // 整棵树中最k小元素在左子树也是最k小
        if(leftN + 1 == k)
            return root->val;
        return kthSmallest(root->right, k - leftN - 1);    // here attention，整棵树最k小在右子树
    }
    int findChild(TreeNode* root) {
        if(!root)
            return 0;
        return findChild(root->left) + findChild(root->right) + 1;
    }
};
// or
class Solution {
public:
    int kthSmallest(TreeNode* root, int k) {
        stack<TreeNode*> s;
        TreeNode* cur = root;
        s.push(cur);
        int idx = 0;
        while(!s.empty() || cur) {
            if(cur) {
                s.push(cur);
                cur = cur->left;
            }
            else {
                cur = s.top();
                s.pop();
                idx++;
                if(idx == k)
                    return cur->val;
                cur = cur->right;
            }
        }
        return 0;  
    }
};
```

## 99.  232-简单-用栈实现队列
**简单**
- 题目描述
实现 MyQueue 类：
void push(int x) 将元素 x 推到队列的末尾
int pop() 从队列的开头移除并返回元素
int peek() 返回队列开头的元素
boolean empty() 如果队列为空，返回 true ；否则，返回 false

- 思路：一个栈用来进，一个栈用来出
```c++
class MyQueue {
private:
    stack<int> s1;
    stack<int> s2;
public:
    /** Initialize your data structure here. */
    MyQueue() {

    }
    /** Push element x to the back of queue. */
    void push(int x) {
        s1.push(x);
    } 
    /** Removes the element from in front of queue and returns that element. */
    int pop() {
        if(empty())
            return -1;
        if(s2.empty()) {
            while(!s1.empty()) {
                s2.push(s1.top());
                s1.pop();
            }
        }  
        int res = s2.top();
        s2.pop();
        return res;
    }
    /** Get the front element. */
    int peek() {
        if(empty())
            return -1;
        if(s2.empty()) {
            while(!s1.empty()) {
                s2.push(s1.top());
                s1.pop();
            }
        }
        return s2.top();
    }
    /** Returns whether the queue is empty. */
    bool empty() {
        return s1.empty() && s2.empty();
    }
};
```

## 100. 234-简单-回文链表
**中等**
- 题目描述
请判断一个链表是否为回文链表。

- 示例:
输入: 1->2          输出: false
输入: 1->2->2->1    输出: true

- 思路：
1. 递归，有点难想
2. 非递归，快慢指针，反转slow之后的链表，然后判断是否一样的值

```c++
class Solution {
public:
    ListNode* reverse(ListNode* head) {
        if(head == nullptr)
            return nullptr;
        if(head->next == nullptr)
            return head;
        ListNode *pre = nullptr;
        ListNode *cur = head;
        ListNode *next = head;
        while(cur != nullptr) {
            next = cur->next;
            cur->next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
    /* ListNode *left; */

    bool isPalindrome(ListNode* head) {
        if (head == nullptr)
            return true;
        if (head->next == nullptr)
            return true;
        ListNode *slow = head;
        ListNode *fast = head;
        while(fast && fast->next) {
            slow = slow->next;
            fast = fast->next->next;
        }
        if (fast != nullptr)//说明链表是奇数个节点
            slow = slow->next;
        ListNode *p = reverse(slow);
        ListNode *q = head;
        while (p != nullptr) {
            if(p->val != q->val)
                return false;
            p = p->next;
            q = q->next;
        }
        return true;
    }
        /* left = head;
        return helper(head);
    } */
    /* bool helper(ListNode* head) {
        if(head == nullptr)
            return true;
        bool res = helper(head->next);
        res = res && (left->val == head->val);
        left = left->next;
        return res;
    } */
};
```

## 101. 235-简单-二叉搜索树的最近公共祖先
**困难**
- 题目描述：
给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先
- 思路：见注释
```c++
class Solution {
public:
    // 终极思路是：用二分搜索来做，BST的特点是中序遍历是升序，所以root->val在p和q的val之间
    // 如果root->val都大于p和q的val，则到root->left找，否则到root->right找
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(!root || p == root || q == root)
            return root;
        if(p->val > root->val && q->val > root->val)
            return lowestCommonAncestor(root->right, p, q);
        if(p->val < root->val && q->val < root->val)
            return lowestCommonAncestor(root->left, p, q);
        // 剩下的情况是root->val在p和q的val之间，所以root就是最低公共祖先
        return root;
    }
};
```


## 102.  236-中等-二叉树的最近公共祖先
**困难**
- 题目描述
给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
- 思路：见注释
```c++
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        // 所有的递归的返回值有4种可能性，null、p、q、公共祖先
        // 当遍历到叶结点后就会返回null
        // 当找到p或者q的是时候就会返回pq
        if(root == p || root == q || !root)
            return root;
        /*当然，值得一提的是，如果公共祖先是自己（pq），并不需要寻找另外 一个，
        我们在执行前序遍历会先找上面的，后找下面的，我们会直接返回公共祖先。*/
        TreeNode* left = lowestCommonAncestor(root->left, p, q);
        TreeNode* right = lowestCommonAncestor(root->right, p, q);
        // 返回的结点进行保存，可能是null
        // 也可能是pq，还可能是公共祖先
        // 如果左右都存在，就说明pq都出现了，这就是，公共祖先，
        // 此时不用考虑公共祖先是自己的情况，因为上面已经做过判断了。
        if(left && right)
            return root;
        // 否则我们返回已经找到的那个值（存储在left，与right中），p或者q
        // return left == nullptr ? right : left;
        if(left)
            return left;
        if(right)
            return right;
        return nullptr;
        
    }
};
```

## 103.  237-简单-删除链表中的节点
**简单**
- 题目描述
请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点。传入函数的唯一参数为 要被删除的节点 。
- 思路：这道题细思极恐：如何让自己在世界上消失，但又不死？ —— 将自己完全变成另一个人，再杀了那个人就行了。
```c++
class Solution {
public:
    void deleteNode(ListNode* node) {
        ListNode* next = node->next;
        if(next) {
            node->val = next->val;
            node->next = next->next;
            delete next;
            next = nullptr;
        }else {
            delete node;
            node = nullptr;
        }
    }
};
```

## 104.  238-中等-除自身以外数组的乘积
**困难**
- 题目描述：
给你一个长度为?n?的整数数组?nums，其中?n > 1，返回输出数组?output?，其中 output[i]?等于?nums?中除?nums[i]?之外其余各元素的乘积。
- 思路：左右各乘，然后共乘
```c++
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        /* 
        原数组：       [1       2       3       4]
        左部分的乘积：   1       1      1*2    1*2*3
        右部分的乘积： 2*3*4    3*4      4      1
        结果：        1*2*3*4  1*3*4   1*2*4  1*2*3*1 */
        //注：指针curLeft表示left之前所有数之积
        //注：指针curRight表示right之前所有数之积
        int sz = nums.size();
        if(sz < 1)
            return {};
        vector<int> res(sz, 1);
        int left = 1;
        for(int i = 0; i < sz; i++) {
            if(i > 0) {
                left *= nums[i-1];
            }
            res[i] = left;
        }
        int right = 1;
        for(int i = sz -1; i >= 0; i--) {
            if(i < sz - 1) {
                right *= nums[i+1];
            }
            res[i] *= right;
        }
        return res;
    }
    /* for(int i=0;i<n;++i)    //最终每个元素其左右乘积进行相乘得出结果
    {
        res[i]*=left;       //乘以其左边的乘积
        left*=nums[i];
        
        res[n-1-i]*=right;  //乘以其右边的乘积
        right*=nums[n-1-i];
    } */
};
```

## 105.  240-中等-搜索二维矩阵 II
**简单**
- 题目描述
编写一个高效的算法来搜索?m?x?n?矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：

每行的元素从左到右升序排列。
每列的元素从上到下升序排列。

- 思路：
在左下角开始遍历，target与左下角数字的比较大小决定走上一行还是走左一列

```c++
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
    /* 左下角的元素是这一行中最小的元素，同时又是这一列中最大的元素。比较左下角元素和目标：
        若左下角元素等于目标，则找到
        若左下角元素大于目标，则目标不可能存在于当前矩阵的最后一行，问题规模可以减小为在去掉最后一行的子矩阵中寻找目标
        若左下角元素小于目标，则目标不可能存在于当前矩阵的第一列，问题规模可以减小为在去掉第一列的子矩阵中寻找目标
        若最后矩阵减小为空，则说明不存在 */
        int sz = matrix.size();
        if(sz < 1)
            return false;
        int row = sz - 1;               // 行
        int col = matrix[0].size() - 1; // 列
        int i = row;
        int j = 0;
        while(i >= 0 && j <= col) {
            if(matrix[i][j] == target)
                return true;
            if(matrix[i][j] < target)
                j++;
            else
                i--;
        }
        return false;
    }
};
```

## 106.  242-简单-有效的字母异位词
**简单**
- 题目描述
给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

输入: s = "anagram", t = "nagaram"          输出: true
输入: s = "rat", t = "car"                  输出: false

- 思路：哈希表记录s的字符++，然后记录t的字符--，检查如果有非0就返回false

```c++
class Solution {
public:
    bool isAnagram(string s, string t) {
        int sz_s = s.size();
        int sz_t = t.size();
        if(sz_s != sz_t)
            return false;
        unordered_map<char, int> table;
        /* for(char c : s)
            table[c]++;
        for(char c : t) {
            if(!table.count(c))
                return false;
            else {
                table[c]--;
                if(table[c] == 0)
                    table.erase(c);
            }
        } 
        return table.empty();*/
        for(int i = 0; i < sz_s; i++) {
            table[s[i]]++;
            if(table[s[i]] == 0)
                table.erase(s[i]);
            table[t[i]]--;
            if(table[t[i]] == 0)
                table.erase(t[i]);
        }
        return table.empty();
    }
};
```

## 107.  258-中等-各位相加
**中等**
- 题目描述
给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。
- 示例:
输入: 38
输出: 2 
解释:   各位相加的过程为：3 + 8 = 11, 1 + 1 = 2。 由于?2 是一位数，所以返回 2。
进阶:   你可以不使用循环或者递归，且在 O(1) 时间复杂度内解决这个问题吗？
- 思路：
除了传统的单纯循环，还可以找规律。假如一个三位数'abc'，其值大小为s1 = 100 * a + 10 * b + 1 * c，经过一次各位相加后，变为s2 = a + b + c，减小的差值为(s1 -s2) = 99 * a + 9 * b，差值可以被9整除，每一个循环都这样，缩小了9的倍数。当num小于9，即只有一位时，直接返回num，大于9时，如果能被9整除，则返回9（因为不可能返回0也不可能返回两位数及以上的值），如果不能被整除，就返回被9除的余数。
```c++
class Solution {
public:
    int addDigits(int num) {
        //每一个循环都这样，缩小了9的倍数。当num小于9，即只有一位时，直接返回num，大于9时，如果能被9整除，则返回9
        if(num > 9) {
            num = num % 9;
            if(num == 0)
                return 9;
        }
        return num;
    }
};
// or

```

## 108.  268-简单-丢失的数字
**简单**
- 题目描述
给定一个包含 [0, n]?中?n?个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。
进阶：你能否实现线性时间复杂度、仅使用额外常数空间的算法解决此问题?
- 思路：异或
    1. 解法1 排序 排序后[0,n], 与下标对不上的就是缺失的元素
    2. 解法2 hash表
    3. 解法3 异或
    4. 解法4 求和运算 对[0,n]求和, 减去数组每个元素, 得出丢失的元素
```c++
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        int ans = 0;
        for(int i = 0; i < nums.size(); i++)
            ans = ans ^ (i + 1) ^ nums[i];
        return ans;
    }
};
```

## 109.  279-中等-完全平方数
**困难**
- 题目描述
给定正整数?n，找到若干个完全平方数（比如?1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。

给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。

完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。

- 示例：
输入：n = 12        输出：3 
解释：12 = 4 + 4 + 4

输入：n = 13        输出：2
解释：13 = 4 + 9

- 思路：类背包问题
1，对于正整数N, 所有的解都是 N = 一个整数的平方 + 另一个整数; 直白点, N = AxA + B
2, 而B又是由 "一个整数的平方 + 另一个整数" 组成的; 那么, B = CxC + D
3，总结下就是：N = IxI + N' 而 N' = IxI + N''
4, 本题要解的问题：正整数N最少由多个平方数相加;
5, 那么，N的最优解 = 1 + （N’的最优解）。而N'肯定小于N。
6, 所以本题的思路就是，对每一个N，观察1到N-1中，谁的解最小，那么N的解就是它+1.
7, 但是我们没必要1到N+1中的每一个数都去观察，因为有些组合不满足N = IxI + N'，譬如12 = 2+N'是不需要的，因为2不是某个数的平方。所以我们观察的范围要大大减小。
拿12举例,我们只能观察：
12 = 1 + 11
12 = 4 + 8
12 = 9 + 3
我们要得出3，8，11中谁的解最优，那么12的解就是它+1。
8, 我们从1到N计算, 2的解从1里找，3的解从[2,1]里找，4的解从[3,2,1]里找，依次类推，最后算到N的解即可。
*完全背包问题*![https://leetcode-cn.com/problems/perfect-squares/solution/wan-quan-bei-bao-wen-ti-by-bac0id/]
```c++
class Solution {
public:
    int numSquares(int n) {
        vector<int> dp(n+1, 0);                     // 每个数的最优解都存在result数组里
        for(int i = 1; i <= n; i++) {
            dp[i] = i;
            for(int j = 1; i - j*j >= 0; j++)       // 观察比N小的数，且符合N = IxI + N'的数值
                dp[i] = min(dp[i], dp[i - j*j] + 1);// 把最优解（最小值）+ 1 写入result
        }
        return dp[n];
    }
};
```

## 110.  283-简单-移动零
**简单**
- 题目描述
给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

示例:

输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
说明:

必须在原数组上操作，不能拷贝额外的数组。
尽量减少操作次数。

- 思路：双指针，将所有非0的数字往数组前面搬移，再在后面的符

```c++
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int n = nums.size();
        if(n == 0 || n == 1)
            return;
        int slow = 0, fast = 0;
        // fast负责遍历
        // slow负责记录非0
        while(fast < n) {
            if(nums[fast] != 0) {
                nums[slow] = nums[fast];
                slow++;
            }  
            fast++;
        }
        while(slow < n) {
            nums[slow] = 0;
            slow++;
        }
    }
};
```

## 111.  287-中等-寻找重复数
**中等**
- 题目描述
给定一个包含?n + 1 个整数的数组?nums ，其数字都在 1 到 n?之间（包括 1 和 n），可知至少存在一个重复的整数。
假设 nums 只有 一个重复的整数 ，找出 这个重复的数 。
- 示例：
输入：nums = [1,3,4,2,2]    输出：2
输入：nums = [3,1,3,4,2]    输出：3
输入：nums = [1,1]          输出：1
- 思路：
快慢指针思想, fast 和 slow 是指针, nums[slow] 表示取指针对应的元素
注意 nums 数组中的数字都是在 1 到 n 之间的(在数组中进行游走不会越界),
因为有重复数字的出现, 所以这个游走必然是成环的, 环的入口就是重复的元素, 即按照寻找链表环入口的思路来做
1. 判断是否有环：快慢指针遍历是否有相遇 slow == fast
2. 找到环的入口：判断有环后的快慢指针相遇后，令fast = 0从头开始遍历，直到再次相遇于入口 slow == fast
```c++
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        int fast = 0;
        int slow = 0;
        while(true) {
            slow = nums[slow];
            fast = nums[nums[fast]];
            if(slow == fast)
                break;
        }
        fast = 0;
        while(nums[slow] != nums[fast]) {
            slow = nums[slow];
            fast = nums[fast];
        }
        return nums[slow];
    }
};
```

## 112.  292-简单-Nim 游戏
**简单**
- 题目描述
你和你的朋友，两个人一起玩?Nim 游戏：

桌子上有一堆石头。
你们轮流进行自己的回合，你作为先手。
每一回合，轮到的人拿掉?1 - 3 块石头。
拿掉最后一块石头的人就是获胜者。
假设你们每一步都是最优解。请编写一个函数，来判断你是否可以在给定石头数量为 n 的情况下赢得游戏。如果可以赢，返回 true；否则，返回 false 。

- 思路：
面对4的整数倍的人永远无法翻身，你拿N根对手就会拿4-N根，保证每回合共减4根，你永远对面4倍数，直到4. 相反，如果最开始不是4倍数，你可以拿掉刚好剩下4倍数根，让他永远对面4倍数。

```c++
class Solution {
public:
    bool canWinNim(int n) {
        /* if(n <= 3)
            return true; */
        return n % 4 != 0;
    }
};
```

## 113.  300-中等-最长递增子序列
**中等** **dp**
- 题目描述
给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。
子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

- 示例：
输入：nums = [10,9,2,5,3,7,101,18]  输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。

输入：nums = [0,1,0,3,2,3]          输出：4

- 思路：
第 1 步：状态定义。dp[i] 表示以 nums[i] 结尾的最长上升子序列的长度。即：在 [0, ..., i] 的范围内，选择以数字 nums[i] 结尾可以获得的最长上升子序列的长度。

说明：以 nums[i] 结尾，是子序列动态规划问题的经典设计状态思路，思想是动态规划的无后效性（定义得越具体，状态转移方程越好推导）。

第 2 步：推导状态转移方程：遍历到 nums[i] 的时候，我们应该把下标区间 [0, ... ,i - 1] 的 dp 值都看一遍，如果当前的数 nums[i] 大于之前的某个数，那么 nums[i] 就可以接在这个数后面形成一个更长的上升子序列。把前面的数都看了， dp[i] 就是它们的最大值加 $1$。即比当前数要小的那些里头，找最大的，然后加 $1$ 。

状态转移方程即：dp[i] = max(1 + dp[j] if j < i and nums[j] < nums[i])。

第 3 步：初始化。单独一个数是子序列，初始化的值为 1；

第 4 步：输出。应该扫描这个 dp 数组，其中最大值的就是题目要求的最长上升子序列的长度。

```c++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int sz = nums.size();
        if(sz < 2)
            return sz;
        vector<int> dp(sz, 1);
        int ans = dp[0];
        for(int i = 1; i < sz; i++) {
            for(int j = 0; j < i; j++) {
                if(nums[j] < nums[i])
                    dp[i] = max(dp[j]+1, dp[i]);
            }
            ans = max(ans, dp[i]);
        }
        return ans;
    }
};
```

## 114.  313-中等-超级丑数
**困难** **dp**
- 题目描述
编写一段程序来查找第 n 个超级丑数。
超级丑数是指其所有质因数都是长度为?k?的质数列表?primes?中的正整数。

- 示例
输入: n = 12, primes = [2,7,13,19]      输出: 32 
解释: 给定长度为 4 的质数列表 primes = [2,7,13,19]，前 12 个超级丑数序列为：[1,2,4,7,8,13,14,16,19,26,28,32] 。

- 思路：动态规划 or 最小堆

```c++
// 丑数
class Solution {
public:
    int nthUglyNumber(int n) {
        vector<int> ugly(n, 1);
        vector<int> idx(3, 0);
        for(int i = 1; i < n; i++) {
            int a = ugly[idx[0]]*2;
            int b = ugly[idx[1]]*3;
            int c = ugly[idx[2]]*5;
            int next = min(a, min(b, c));
            if(next == a)
                idx[0]++;
            if(next == b)
                idx[1]++;
            if(next == c)
                idx[2]++;
            ugly[i] = next; 
        }
        return ugly.back();
    }
};
// 超级丑数
class Solution {
public:
    int nthSuperUglyNumber(int n, vector<int>& primes) {
        vector<int> dp(n, 1);               // 参考第264题
        vector<int> idx(primes.size(), 0);  // 一般丑数是用3指针， 而超级丑数用primes.size()个指针
        for(int i = 1; i < n; i++) {
            int next = INT_MAX;
            for(int j = 0; j < idx.size(); j++) {
                next = min(next, dp[idx[j]] * primes[j]); // idx[j] 代表 primes[j]的索引
            }
            for(int j = 0; j < idx.size(); j++) {
                if(next == dp[idx[j]] * primes[j])
                    idx[j]++;
            }
            dp[i] = next;
        }
        return dp[n-1];
    }
};

/* 丑数是基于（过去的丑数）和（质因子数组中质因子）的乘积中的最小值。采用最小优先队列实现最小值排在第一个。
最小优先队列中存储的是数组，数组中有三个元素。第一个元素为丑数，第二个元素记录了基于哪一个过去的丑数计算，第三个元素记录了基于哪一个质因子的计算。 */

class Solution {
    public int nthSuperUglyNumber(int n, int[] primes) {
        int[] ugly = new int[n];
        ugly[0] = 1;
        PriorityQueue<int[]> pq = new PriorityQueue<>((o1, o2) -> o1[0]-o2[0]);//lambda表达式。以数组的第一个元素升序排序。
        for(int i=0;i<primes.length;i++) pq.add(new int[]{primes[i],0,i});
        for (int i = 1; i < n; i++) {
            int[] tmp = pq.poll();
            ugly[i] = tmp[0];
            tmp[0] = ugly[++tmp[1]]*primes[tmp[2]];//tmp[1]和tmp[2]分别为丑数和质因子的索引。
            pq.add(tmp);
            if(ugly[i]==ugly[i-1]) i--;//如果ugly[i]和ugly[i-1]重复了，那就再重新计算一次ugly[i]。
        }
        return ugly[n - 1];
    }
}

```

## 115.  322-中等-零钱兑换（未）
**困难** **dp**
- 题目描述
给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回?-1。
你可以认为每种硬币的数量是无限的。

- 示例：

输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1

输入：coins = [2], amount = 3
输出：-1

输入：coins = [1], amount = 0
输出：0

输入：coins = [1], amount = 1
输出：1

输入：coins = [1], amount = 2
输出：2

- 思路：

```c++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        vector<int> dp(amount + 1, amount + 1);
        dp[0] = 0;
        for (int i = 0; i < dp.size(); i++) {
            for(int coin : coins){
                if(i - coin < 0)
                    continue;
                dp[i] = min(dp[i], 1 + dp[i - coin]);
            }
        }
        return (dp[amount] == amount + 1) ? -1 : dp[amount];
    }
};
```

## 116.  326-简单-3的幂
**中等**
- 题目描述
给定一个整数，写一个函数来判断它是否是 3?的幂次方。如果是，返回 true ；否则，返回 false 。

整数 n 是 3 的幂次方需满足：存在整数 x 使得 n == 3^x

- 示例：
输入：n = 27        输出：true
输入：n = 0         输出：false
输入：n = 9         输出：true

```c++
class Solution {
public:
    bool isPowerOfThree(int n) {
        /*
            换底公式： x = log3(n) = log10(n) / log10(3) 
            判断x是整数即可
        */
        if(n < 1)
            return false;
        double res = log10(n) / log10(3);
        if(abs(res - (int)res) > 0)
            return false;
        return true;
    }
};
```


## 117.  328-中等-奇偶链表
**中等**
- 题目描述
给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。

请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。

- 示例:

输入: 1->2->3->4->5->NULL
输出: 1->3->5->2->4->NULL

输入: 2->1->3->5->6->4->7->NULL 
输出: 2->3->6->7->1->5->4->NULL
说明:

应当保持奇数节点和偶数节点的相对顺序。
链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。

```c++
class Solution {
public:
    ListNode* oddEvenList(ListNode* head) {
        if(!head || !head->next)
            return head;
        // 奇头 ： head     奇尾 ： o
        // 偶头 ： p        偶尾 ： e
        ListNode* o = head;         // init
        ListNode* p = head->next;   // init
        ListNode* e = p;            // init
        while(o->next && e->next) {
            o->next = e->next;
            o = o->next;
            e->next = o->next;
            e = e->next;
        }
        o->next = p;
        return head;
    }
};
```

## 118.  334-中等-递增的三元子序列
**中等**
- 题目描述
给你一个整数数组?nums ，判断这个数组中是否存在长度为 3 的递增子序列。
如果存在这样的三元组下标 (i, j, k)?且满足 i < j < k ，使得?nums[i] < nums[j] < nums[k] ，返回 true ；否则，返回 false 

- 示例：
输入：nums = [1,2,3,4,5]
输出：true
解释：任何 i < j < k 的三元组都满足题意

输入：nums = [5,4,3,2,1]
输出：false
解释：不存在满足题意的三元组

输入：nums = [2,1,5,0,4,6]
输出：true
解释：三元组 (3, 4, 5) 满足题意，因为 nums[3] == 0 < nums[4] == 4 < nums[5] == 6

- 思路：设两个中间变量，按顺序遍历，small-1 < small-2 < tmp，如果tmp存在就返回true
```c++
class Solution {
public:
    bool increasingTriplet(vector<int>& nums) {
        if(nums.size() < 3)
            return false;
        int firstMin = INT_MAX;
        int secondMin = INT_MAX;
        for(int num : nums) {
            if(num <= firstMin)
                firstMin = num;
            else if(num <= secondMin)
                secondMin = num;
            else 
                return true;
        }
        return false;
    }
};
```



## 119.  337-中等-打家劫舍 III
**中等** **dp**
- 题目描述
在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。

计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。

- 示例:

输入: [3,2,3,null,3,null,1]
     3
    / \
   2   3
    \   \ 
     3   1
输出: 7 解释:?小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.

输入: [3,4,5,1,3,null,1]
?    3
    / \
   4   5
  / \   \ 
 1   3   1
输出: 9 解释:?小偷一晚能够盗取的最高金额?= 4 + 5 = 9.
- 思路：与dp的思想差不多，有偷与不偷的对比，res = max(do_it, not_do_it);
- dp的攻略：用memo记录！

```c++
class Solution {
public:
    unordered_map<TreeNode *, int> memo;
    int rob(TreeNode* root) {
        /*
        if(!root)
            return 0;
        if(memo.count(root))
            return memo[root];
        int do_it = root->val + (root->left ? (rob(root->left->left) + rob(root->left->right)) : 0) + (root->right ? (rob(root->right->left) + rob(root->right->right)) : 0);
        int not_do_it = rob(root->left) + rob(root->right);
        int res = max(do_it, not_do_it);
        memo[root] = res;
        return res;
    }*/
        if(!root)
            return 0;
        if(memo.count(root))
            return memo[root];
        if(!root->left && !root->right)
        {
            memo[root] = root->val;
            return root->val;
        }
        if(root->left && root->right)
        {
            int do_it = root->val + rob(root->left->left) + rob(root->left->right) + rob(root->right->left) + rob(root->right->right);
            int not_do_it = rob(root->left) + rob(root->right);
            int res = max(do_it, not_do_it);
            memo[root] = res;
            return res;
        }   
        if(root->left && !root->right)
        {
            int do_it = root->val + rob(root->left->left) + rob(root->left->right);
            int not_do_it = rob(root->left) + rob(root->right);
            int res = max(do_it, not_do_it);
            memo[root] = res;
            return res;
        }
        else//(!root->left && root->right)
        {
            int do_it = root->val + rob(root->right->left) + rob(root->right->right);
            int not_do_it = rob(root->left) + rob(root->right);
            int res = max(do_it, not_do_it);
            memo[root] = res;
            return res;
        }
    }
};
```


## 120.  338-中等-比特位计数
**中等**
- 题目描述
给定一个非负整数?num。对于?0 ≤ i ≤ num 范围中的每个数字?i?，计算其二进制数中的 1 的数目并将它们作为数组返回。

- 示例:
输入: 2         输出: [0,1,1]
输入: 5         输出: [0,1,1,2,1,2]

```c++
/* 分奇数和偶数：
偶数的二进制1个数超级简单，因为偶数是相当于被某个更小的数乘2，乘2怎么来的？在二进制运算中，就是左移一位，也就是在低位多加1个0，那样就说明dp[i] = dp[i / 2]
奇数稍微难想到一点，奇数由不大于该数的偶数+1得到，偶数+1在二进制位上会发生什么？会在低位多加1个1，那样就说明dp[i] = dp[i-1] + 1，当然也可以写成dp[i] = dp[i / 2] + 1
 */
 //利用已知算未知的方法1：
class Solution {
public:
    vector<int> countBits(int num) {
        int i = 1;
        vector<int> ans(num + 1);
        for (int i = 0; i <= num; i++) {
            if (i % 2 == 0) 
                ans[i] = ans[i / 2];
            else 
                ans[i] = ans[i / 2] + 1;
        }
        return ans;
    }
};
/* 利用已知算未知的方法2：i & (i - 1)可以去掉i最右边的一个1（如果有），因此 i & (i - 1）是比 i 小的
而且i & (i - 1)的1的个数已经在前面算过了，所以i的1的个数就是 i & (i - 1)的1的个数加上1 */
class Solution {
public:
    vector<int> countBits(int num) {
        vector<int> ans(num+1, 0);
        for(int i = 1; i <= num; i++) {
            ans[i] = ans[i&(i-1)] + 1;
        }
        return ans;
    }
};
// or
/* 利用已知算未知的方法3：i >> 1会把最低位去掉，因此i >> 1 也是比i小的，同样也是在前面的数组里算过。
当 i 的最低位是0，则 i 中1的个数和i >> 1中1的个数相同；当i的最低位是1，i 中1的个数是 i >> 1中1的个数再加1 */
class Solution {
public:
    vector<int> countBits(int num) {
        vector<int> ans(num+1, 0);
        for(int i = 1; i <= num; i++) {
            ans[i] = ans[i>>1] + (i & 1);
        }
        return ans;
    }
};
```

## 121.  344-简单-反转字符串
**简单**
- 题目描述
编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。

不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。

你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。

- 示例：
输入：["h","e","l","l","o"]
输出：["o","l","l","e","h"]

输入：["H","a","n","n","a","h"]
输出：["h","a","n","n","a","H"]

- 思路：双指针都用不着
```c++
class Solution {
public:
    void reverseString(vector<char>& s) {
        if(s.size() == 0 || s.size() == 1)
            return;
        int size = s.size();
        for (int i = 0; i < size / 2; ++i) {
            char tmp = s[i];
            s[i] = s[size - 1 - i];
            s[size - 1 - i] = tmp;
        }
    }
};
```


## 122.  347-中等-前 K 个高频元素
**中等**
- 题目描述
给定一个非空的整数数组，返回其中出现频率前?k?高的元素。
- 示例:
输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]

输入: nums = [1], k = 1
输出: [1]

- 思路：用hash表记录频率，用大根堆排序频率，拿出前顶面k个元素
```c++
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int, int> table;
        for(int num : nums)
            table[num]++;
        priority_queue<pair<int, int> > pq;  // 默认大根堆，大的都在顶
        for(auto t : table) 
            pq.push(pair<int, int>(t.second, t.first));
        vector<int> ans;
        while(k != 0) {
            ans.push_back(pq.top().second);
            pq.pop();
            k--;
        }
        return ans;
    }
};
```


## 123.  349-简单-两个数组的交集
**中等**
- 题目描述
给定两个数组，编写一个函数来计算它们的交集。
说明：
输出结果中的每个元素一定是唯一的。
我们可以不考虑输出结果的顺序。

- 示例：
输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2]

输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[9,4]

- 思路：排序、哈希、双指针、二分等等
```c++
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        // 用哈希表映射nums1频率，扫描nums2是否有重复出现，若有就转0，计算出现0的个数
        unordered_map<int, int> table;
        for(int num : nums1)
            table[num]++;
        for(int num : nums2) {
            if(table.count(num))
                table[num] = 0;
            else 
                continue;
        }
        vector<int> ans;
        for(auto t : table)
            if(t.second == 0)
                ans.push_back(t.first);
        return ans;
    }
};
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        // 或者用set
        unordered_set<int> m(nums1.begin(), nums1.end());
        vector<int> ans;
        for(int num : nums2) {
            if(m.count(num)) {
                ans.push_back(num);
                m.erase(num);
            }
        }
        return ans;
    }
};
```




## 124.  371-简单-两整数之和
**中等**
- 题目描述
不使用运算符?+ 和?-????????，计算两整数????????a?、b????????之和。

- 示例:
输入: a = 1, b = 2
输出: 3

输入: a = -2, b = 3
输出: 1

- 思路：
异或：
    相同为0，相异为1。二进制只有0和1，所以也就是只有0和1的时候才是1.同为0或者同为1都是0，而这个时候类比加法中有两种可能，一个是1+1=0 进位1，一个是0+0=0 无进位，所以还要知道这个0对应的是有进位还是没进位。这个时候就可以用位与了。
位与：
    同为1是1，有0则为0；类比加法：如果与的结果为1，那么说明是1+1,的场景，那么这个结果1可以看做是1+1的进位，所以要左移一位。与的结果是0.那么说明是1+0或者0+0，都是不需要进位的。所以先sum=a^b, 然后 a&b再左移一位（如果都是需要进位那么左移之后就全是1了），如果左移后是0，也就不需递归，直接返回sum，不为0就再用左移后的值与sum求和，也就是递归了。

```c++
int getSum(int a, int b) 
{
    int sum, carry; 
    sum = a ^ b;  //异或这里可看做是相加但是不显现进位，比如5 ^ 3
                 /*0 1 0 1
                   0 0 1 1
                 ------------
                   0 1 1 0      
              上面的如果看成传统的加法，不就是1+1=2，进1得0，但是这里没有显示进位出来，仅是相加，0+1或者是1+0都不用进位*/
    
    carry = (a & b) << 1;
    
                //相与为了让进位显现出来，比如5 & 3
                /* 0 1 0 1
                   0 0 1 1
                 ------------
                   0 0 0 1
              上面的最低位1和1相与得1，而在二进制加法中，这里1+1也应该是要进位的，所以刚好吻合，但是这个进位1应该要再往前一位，所以左移一位*/
    
    if(carry != 0)  //经过上面这两步，如果进位不等于0，那么就是说还要把进位给加上去，所以用了尾递归，一直递归到进位是0。
    {
        return getSum(sum, carry);
    }
    return sum;
}
// or
class Solution {
public:
    int getSum(int a, int b) {
        while (b) {
            auto c = ((unsigned int)a & b) << 1; // 防止 AddressSanitizer 对有符号左移的溢出保护处理
            a = a ^ b;      // 似乎是因为 负数不能左移
            b = c;
        }
        return a;
    }
};
```

## 125.  378-中等-有序矩阵中第K小的元素
**中等**
- 题目描述
给你一个?n x n?矩阵?matrix ，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。
请注意，它是 排序后 的第 k 小元素，而不是第 k 个 不同 的元素。

- 示例：

输入：matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8
输出：13
解释：矩阵中的元素为 [1,5,9,10,11,12,13,13,15]，第 8 小元素是 13

输入：matrix = [ [-5] ], k = 1
输出：-5

- 思路：大根堆、小根堆、二分

```c++
class Solution {
public:
    int kthSmallest(vector<vector<int>>& matrix, int k) {
        priority_queue<int> pq; // maxHeap
        for(int i = 0; i < matrix.size(); i++) {
            for(int j = 0; j < matrix[i].size(); j++) {
                pq.push(matrix[i][j]);
                if(pq.size() > k)
                    pq.pop();
            }
        }
        return pq.top();
    }
};
```

## 126.  394-中等-字符串解码
**困难**
- 题目描述
给定一个经过编码的字符串，返回它解码后的字符串。

编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。

- 示例:
输入：s = "3[a]2[bc]"
输出："aaabcbc"

输入：s = "3[a2[c]]"
输出："accaccacc"

输入：s = "2[abc]3[cd]ef"
输出："abcabccdcdcdef"

输入：s = "abc3[cd]xyz"
输出："abccdcdcdxyz"

- 思路：

```c++
class Solution {
public:
    string decodeString(string s) {
        int len = s.size();
        int num = 0;
        stack<int> numStk;
        stack<string> strStk;
        string cur = "";
        string result = "";
        for(int i = 0; i < len; i++) {
            if(s[i] >= '0' && s[i] <= '9') {
                num = num * 10 + s[i] - '0'; // 连续出现数字的情况
            }else if(s[i] == '[') {
                numStk.push(num);
                strStk.push(cur);
                num = 0;
                cur.clear();
            }else if((s[i] >= 'a' && s[i] <= 'z') || (s[i] >= 'A' && s[i] <= 'Z')) {
                cur += s[i];
            }else if(s[i] == ']') {
                int k = numStk.top();
                numStk.pop();
                for(int j = 0; j < k; j++)
                    strStk.top() += cur;
                cur = strStk.top();
                strStk.pop();
            }
        }
        result = cur;
        return result;
    }
};
```

## 127.  402-中等-移掉K位数字
**困难**
- 题目描述
给定一个以字符串表示的非负整数?num，移除这个数中的 k 位数字，使得剩下的数字最小。

注意:
num 的长度小于 10002 且?≥ k。
num 不会包含任何前导零。

- 示例:

输入: num = "1432219", k = 3
输出: "1219"
解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。

输入: num = "10200", k = 1
输出: "200"
解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。

输入: num = "10", k = 2
输出: "0"
解释: 从原数字移除所有的数字，剩余为空就是0。

- 思路：贪心算法
```c++
class Solution {
public:
    string removeKdigits(string num, int k) {
        if(num.size() == k)
            return "0";
        for(int i = 0; i < k; i++) {
            int idx = 0;
            for(int j = 1; j < num.size() && num[j-1] <= num[j]; j++) { 
                // 从左至右遍历找到第一个递增序列中，最靠右（既最大的数）
                // 14567 删除4 比 要删除7 作用小
                idx = j;    //  较大的那个就是首要删除的
            }
            num.erase(num.begin()+idx);
            while(num.size()>1 && num[0] == '0')
                //  删除前导0
                num.erase(num.begin());
        }
        return num;
    }
};
```


## 128.  406-中等-根据身高重建队列
**困难**
- 题目描述
假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。

请你重新构造并返回输入数组?people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。

- 示例：

输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
解释：
编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。
编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。
编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。
编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。
编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。

输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]
输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]

- 思路：

```c++
class Solution {
public:
    static bool cmp(const vector<int>& a, const vector<int>& b) {
        if(a[0] == b[0])
            return a[1] < b[1]; // k升序遍历
        return a[0] > b[0]; // h降序遍历
    }
    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
        /*
        0、构建队列q
        1、对people的h降序遍历，然后在相同的h中升序遍历k
        2、每个k就是这个人在目前队列构建过程中的位置索引
        输入: [[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]
        输出:
        [[7, 0]]
        [[7, 0], [7, 1]]
        [[7, 0], [6, 1], [7, 1]]
        [[5, 0], [7, 0], [6, 1], [7, 1]]
        [[5, 0], [7, 0], [5, 2], [6, 1], [7, 1]]
        [[5, 0], [7, 0], [5, 2], [6, 1], [4, 4], [7, 1]]
        */
        vector<vector<int>> ans;
        sort(people.begin(), people.end(), cmp);
        for(int i = 0; i < people.size(); i++) {
            // 
            if(people[i][1] >= ans.size())
                ans.push_back(people[i]);
            else
                ans.insert(ans.begin()+people[i][1], people[i]);
        }
        return ans;
    }
};
```


## 129.  409-简单-最长回文串
**中等**
- 题目描述
给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。

在构造过程中，请注意区分大小写。比如?"Aa"?不能当做一个回文字符串。

注意: 假设字符串的长度不会超过 1010。

- 示例:
输入: "abccccdd"
输出: 7
解释: 我们可以构造的最长的回文串是"dccaccd", 它的长度是 7。

```c++
class Solution {
public:
    int longestPalindrome(string s) {
        if(s.size() < 2)
            return 1;
        unordered_map<char, int> table;
        for(char c : s)
            table[c]++; // 哈希表记录频率
        int ans = 0;
        bool hasOne = false;
        for(auto t : table) {
            if(t.second == 1 && !hasOne) {
                hasOne = true;  // 如果是1则标记有1作为中间
                continue;
            }
            else if(t.second % 2 == 0)
                ans += t.second;    // 频率是偶数
            else {
                ans = ans + t.second - 1;
                if(!hasOne)         // 频率是奇数
                    hasOne = true;
            }
        }
        if(hasOne)
            ans++;
        return ans;
    }
};
```

## 130.  412-简单-Fizz Buzz
**简单**
- 题目描述
写一个程序，输出从 1 到 n 数字的字符串表示。

1. 如果?n?是3的倍数，输出“Fizz”；

2. 如果?n?是5的倍数，输出“Buzz”；

3.如果?n?同时是3和5的倍数，输出 “FizzBuzz”。

示例：

n = 15,

返回:
[
    "1",
    "2",
    "Fizz",
    "4",
    "Buzz",
    "Fizz",
    "7",
    "8",
    "Fizz",
    "Buzz",
    "11",
    "Fizz",
    "13",
    "14",
    "FizzBuzz"
]

- 思路：emmm

```c++
class Solution {
public:
    vector<string> fizzBuzz(int n) {
        if(n < 1)
            return {};
        vector<string> ans;
        for(int i = 1; i <= n; i++) {
            if(i % 3 == 0 && i % 5 == 0) 
                ans.push_back("FizzBuzz");
            else if(i % 3 == 0)
                ans.push_back("Fizz");
            else if(i % 5 == 0)
                ans.push_back("Buzz");
            else
                ans.push_back(std::to_string(i));
        }
        return ans;
    }
};
```

## 131.  415-简单-字符串相加
**简单**
- 题目描述
给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。
- 思路：int 转 string的练习 和 用sum对carry的运用
```c++
class Solution {
public:
    string addStrings(string num1, string num2) {
        // 重高位开始计算的啦，既个位
        int i = num1.size() - 1;
        int j = num2.size() - 1;
        int sum = 0;
        string res = "";
        while (i >= 0 || j >= 0 || sum) {
            if (i >= 0 && j >= 0) {
                sum += (num1[i--] - '0') + (num2[j--] - '0');
            }else if(i >= 0){
                sum += num1[i--] - '0';
            }else if(j >= 0){
                sum += num2[j--] - '0';
            }
            res += sum % 10 + '0';  // int->char 要数字写在前面啦
            sum /= 10;              // 此sum变carry
        }
        reverse(res.begin(), res.end());    // 最后
        return res;
    }
};
```

## 132.  416-中等-分割等和子集（未）
**困难** **dp**
- 题目描述
给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

注意:
每个数组中的元素不会超过 100
数组的大小不会超过 200

- 示例 :
输入: [1, 5, 11, 5]
输出: true
解释: 数组可以分割成 [1, 5, 5] 和 [11].

输入: [1, 2, 3, 5]
输出: false
解释: 数组不能分割成两个元素和相等的子集.

- 思路：
  
```c++
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = 0;
        for(int num : nums)
            sum += num;
        if (sum % 2 == 1)
            return false;
        sum = sum / 2;
        int n = nums.size();
        vector<bool> dp(sum + 1, false);
        dp[0] = true;
        for (int i = 0; i < n; i++) {
            for (int j = sum; j != 0; j--) {
                if(j - nums[i] >= 0)
                    dp[j] = dp[j] || dp[j - nums[i]];
            }
        }
        return dp[sum];
        /* vector<vector<bool>> dp(n + 1, vector<bool>(sum + 1, false));//dp[n+1][sum+1]
        for (int j = 0; j <= n; j++)
            dp[j][0] = true;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= sum; j++) {
                if (j - nums[i - 1] < 0)
                    dp[i][j] = dp[i - 1][j];
                else
                    dp[i][j] = dp[i - 1][j] | dp[i - 1][j - nums[i - 1]];
            }
        }
        return dp[n][sum]; */
    }
        /* int sum = 0;
        for(int num : nums)
            sum += num;
        if(sum % 2 != 0)
            return false;
        int target = sum / 2;
        int n = nums.size();
        int dp_i = 0; //当i==0时，dp==0;
        for (int i = 0; i < n; i++) {
            if(dp_i + nums[i] > target)
                continue;
            dp_i = dp_i + nums[i];
            if(dp_i == target)
                return true;
        }
        return false;
    } */
};
```

## 133.  448-简单-找到所有数组中消失的数字
**中等**
- 题目描述
给定一个范围在? 1 ≤ a[i] ≤ n (?n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。

找到所有在 [1, n] 范围之间没有出现在数组中的数字。

您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。

- 示例:
输入:
[4,3,2,7,8,2,3,1]

输出:
[5,6]

- 思路：将所有正数作为数组下标，置对应数组值为负值。那么，仍为正数的位置即为（未出现过）消失的数字。
```c++
vector<int> findDisappearedNumbers(vector<int>& nums) {
    for (int i = 0; i < nums.size(); ++i)
        nums[abs(nums[i])-1] = -abs(nums[abs(nums[i])-1]);
    vector<int> res;
    for (int i = 0; i < nums.size(); ++i){
        if (nums[i] > 0)
            res.push_back(i+1);
    }
    return res;
}
```


## 134.  454-中等-四数相加 II
**中等**
- 题目描述
给定四个包含整数的数组列表?A , B , C , D ,计算有多少个元组 (i, j, k, l)?，使得?A[i] + B[j] + C[k] + D[l] = 0。

为了使问题简单化，所有的 A, B, C, D 具有相同的长度?N，且 0 ≤ N ≤ 500 。所有整数的范围在 -228 到 228 - 1 之间，最终结果不会超过?231 - 1 。

- 例如:
输入:
A = [ 1, 2]
B = [-2,-1]
C = [-1, 2]
D = [ 0, 2]
输出: 2
解释:
两个元组如下:
1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0
2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0

- 思路：二分、哈希等等，用哈希记录AB各个元素相加和的频率，然后再查找哈希表内是否存在hash.count( -(c[j] + d[i]) )
```c++
class Solution {
public:
    int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {
        int N = A.size();
        if(N == 0)
            return 0;
        unordered_map<int, int> abMap;
        for(int j = 0; j < N; j++)
            for(int i = 0; i < N; i++) 
                abMap[(A[j]+B[i])]++;
        int ans = 0;
        for(int j = 0; j < N; j++)
            for(int i = 0; i < N; i++) {
                int tmp = -(C[j] + D[i]);
                if(abMap.count(tmp))
                    ans += abMap[tmp];
            }
        return ans;
    }
};
```

## 135.  455-简单-分发饼干
**简单**
- 题目描述
假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。

对每个孩子 i，都有一个胃口值?g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j]?。如果 s[j]?>= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

- 示例:

输入: g = [1,2,3], s = [1,1]
输出: 1
解释: 
你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
所以你应该输出1。

输入: g = [1,2], s = [1,2,3]
输出: 2
解释: 
你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。
你拥有的饼干数量和尺寸都足以让所有孩子满足。
所以你应该输出2.

- 思路：排序一下就可以了
```c++
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        int child = 0;
        int cookie = 0;
        sort(g.begin(), g.end());
        sort(s.begin(), s.end());
        while(child < g.size() && cookie < s.size()) {
            if(s[cookie] >= g[child]) {
                child++;//这个孩子满足了，开始看能否喂下一个孩子
            }
            cookie++;   //这个饼干没了或者不行，查看下一个饼干
        }
        return child;
    }
};
```

## 136.  461-简单-汉明距离
**简单**
- 题目描述
两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。
给出两个整数 x 和 y，计算它们之间的汉明距离。
就是计算 x 和 y 异或后的结果中二进制的 1 的个数

- 示例:
输入: x = 1, y = 4
输出: 2
解释:
1   (0 0 0 1)
4   (0 1 0 0)
       ↑   ↑
上面的箭头指出了对应二进制位不同的位置。

```c++
class Solution {
public:
    int hammingDistance(int x, int y) {
        int tmp = x ^ y;
        int ans = 0;
        while(tmp > 0) {
            if(tmp & 1 != 0)
                ans++;
            tmp = tmp >> 1;
        }
        return ans;
    }
};
```


## 137.  476-简单-数字的补数
**中等**
- 题目描述
给定一个正整数，输出它的补数。补数是对该数的二进制表示取反。

- 示例:
输入: 5         输出: 2
解释: 5 的二进制表示为 101（没有前导零位），其补数为 010。所以你需要输出 2 。

输入: 1         输出: 0
解释: 1 的二进制表示为 1（没有前导零位），其补数为 0。所以你需要输出 0 。

- 思路：
```c++
class Solution {
public:
    int findComplement(int num) {
/*
if num = 13 -> num = 1101
then allOne -> 1111
then num ^ allOne = 0010 
*/
        if(num == 0)
            return 1;
        int bitNum = num;
        int allOne = 0;             // 统计num有多少位，与allOne异或即可
        while(bitNum > 0) {
            bitNum = bitNum >> 1;   // 每次迭代去掉一位
            allOne = allOne << 1;   // 每次迭代增加一位
            allOne++;               // 每次迭代增加的是1
        }
        return num ^ allOne;        // 异或
    }
};
```


## 138.  538-中等-把二叉搜索树转换为累加树
**中等**
- 题目描述
给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node?的新值等于原树中大于或等于?node.val?的值之和。

提醒一下，二叉搜索树满足下列约束条件：

节点的左子树仅包含键 小于 节点键的节点。
节点的右子树仅包含键 大于 节点键的节点。
左右子树也必须是二叉搜索树。

- 思路：BST的中序遍历就是从小到大,那么反过来就是从大到小,然后累加就好了.

```c++
class Solution {
public:
    TreeNode* convertBST(TreeNode* root) {
        helper(root);
        return root;
    }
    int sum = 0;
    void helper(TreeNode* root) {
        if(!root)
            return;
        helper(root->right);
        sum += root->val;
        root->val = sum;
        helper(root->left);
    }
};
```

## 139.  543-简单-二叉树的直径
**中等**
- 题目描述
给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

- 示例 :
给定二叉树

          1
         / \
        2   3
       / \     
      4   5    
返回?3, 它的长度是路径 [4,2,1,3] 或者?[5,2,1,3]。
注意：两结点之间的路径长度是以它们之间边的数目表示。

- 思路：dfs深度优先

```c++
class Solution {
public:
    int ans = 0;
    int diameterOfBinaryTree(TreeNode* root) {
        if(!root)
            return 0;
        dfs(root);
        return ans;
    }
    int dfs(TreeNode* root) {
        // dfs找到root的两边的路径长度， 返回最长的长度
        if(!root->left && !root->right)
            return 0;
        int leftSize = root->left == nullptr ? 0 : dfs(root->left) + 1;
        int rightSize = root->right == nullptr ? 0 : dfs(root->right) + 1;
        ans = max(ans, leftSize + rightSize);
        return max(leftSize, rightSize);
    }
};
```

## 140.  560-中等-和为K的子数组（未）
**困难**
- 题目描述
给定一个整数数组和一个整数?k，你需要找到该数组中和为?k?的连续的子数组的个数。

- 示例:
输入:nums = [1,1,1], k = 2
输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。

- 思路：哈希
- 前缀和思想：我们求数列的和时，Sn = a1+a2+a3+...an; 此时Sn就是数列的前 n 项和。例 S5 = a1 + a2 + a3 + a4 + a5; S2 = a1 + a2。所以我们完全可以通过 S5-S2 得到 a3+a4+a5 的值，这个过程就和我们做题用到的前缀和思想类似。


```c++
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        // 暴力 //双重循环
        int sum = 0, res = 0;
        for(int i = 0; i < nums.size(); i++) {
            for(int j = i; j < nums.size(); j++) {
                sum += nums[j];
                if(sum == k)    //发现符合条件的区间
                    res++;
            }
            sum = 0;    //记得归零，重新遍历
        }
        /* vector<int> preSum(nums.size() + 1, 0);
        for (int i = 0; i <= nums.size(); ++i) {
            preSum[i+1] = preSum[i] + nums[i];  //这里需要注意，我们的前缀和是presum[1]开始填充的
        }
        int res = 0;    //统计个数
        for (int i = 1; i <= nums.size(); ++i) {
            for (int j = 0; j < i; ++j)
            //注意偏移，因为我们的nums[2]到nums[4]等于presum[5]-presum[2]
            //所以这样就可以得到nums[i,j]区间内的和
                if(preSum[i] - preSum[j] == k)
                    ++res;
        }
        return res; */
        int n = nums.size();
        //vector<int> preSum(n + 1, 0);
        unordered_map<int, int> mapped; //记录前缀和->前缀和出现的次数
        mapped[0] = 1;
        int res = 0;
        int sum_i = 0;  // 前缀和
        for (int i = 0; i < n; ++i) {
            sum_i = sum_i + nums[i];
            int sum_j = sum_i - k;
            if (mapped.count(sum_j))
                res += mapped[sum_j];
            if (mapped.count(sum_i))
                mapped[sum_i] += 1;
            else
                mapped[sum_i] = 1;
            }
        return res;
    }
};
```

## 141.  575-简单-分糖果
**简单**
- 题目描述
给定一个偶数长度的数组，其中不同的数字代表着不同种类的糖果，每一个数字代表一个糖果。你需要把这些糖果平均分给一个弟弟和一个妹妹。返回妹妹可以获得的最大糖果的种类数。

- 示例:
输入: candies = [1,1,2,2,3,3]
输出: 3
解析: 一共有三种种类的糖果，每一种都有两个。
     最优分配方案：妹妹获得[1,2,3],弟弟也获得[1,2,3]。这样使妹妹获得糖果的种类数最多。

输入: candies = [1,1,2,3]
输出: 2
解析: 妹妹获得糖果[2,3],弟弟获得糖果[1,1]，妹妹有两种不同的糖果，弟弟只有一种。这样使得妹妹可以获得的糖果种类数最多。

- 思路：哈希。妹妹最多可以得到 sz / 2 种不同的糖果，那么用哈希映射时返回哈希表的大小就可以了

```c++
class Solution {
public:
    int distributeCandies(vector<int>& candyType) {
        int sz = candyType.size();
        if(sz == 0)
            return 0;
        unordered_map<int, int> table;
        for(int i : candyType) {
            table[i]++;
            if(table.size() >= sz / 2)
                return sz / 2;
        }
        return table.size();
    }
};
```


## 142.  581-中等-最短无序连续子数组
**中等**
- 题目描述
给你一个整数数组 nums ，你需要找出一个 连续子数组 ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。
请你找出符合题意的 最短 子数组，并输出它的长度。

- 示例 1：

输入：nums = [2,6,4,8,10,9,15]
输出：5
解释：你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。

输入：nums = [1,2,3,4]
输出：0

输入：nums = [1]
输出：0
 
- 思路：找到无序数组的左右边界，相减即可
从左到右循环，记录最大值为 max，若 nums[i] < max, 则表明位置 i 需要调整, 循环结束，记录需要调整的最大位置 i 为 high; 
同理，从右到左循环，记录最小值为 min, 若 nums[i] > min, 则表明位置 i 需要调整，循环结束，记录需要调整的最小位置 i 为 low.

```c++
class Solution {
public:
    int findUnsortedSubarray(vector<int>& nums) {
        if(nums.size() < 2)
            return 0;

        int max = nums[0];
        int right = 0;// 无序数组右边界
        for (int i = 1; i < nums.size(); i++) {
            if (max > nums[i]) 
                right = i;  // 位置 i 这里需要调整
            else 
                max = nums[i];
        }

        int min = nums[nums.size() - 1];// 已遍历数组最小值
        int left = nums.size() - 1;// 无序数组下界
        for (int i = nums.size() - 2; i >= 0; i--) {
            if (min < nums[i])
                left = i;   // 位置 i 这里需要调整
            else 
                min = nums[i];
        }
       return right - left > 0 ? right - left + 1 : 0;
    }
};
```

## 143.  617-简单-合并二叉树
**简单**
- 题目描述
给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。

你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为?NULL 的节点将直接作为新二叉树的节点。

- 示例:
输入: 
	Tree 1                     Tree 2                  
          1                         2                             
         / \                       / \                            
        3   2                     1   3                        
       /                           \   \                      
      5                             4   7                  
输出: 
合并后的树:
	     3
	    / \
	   4   5
	  / \   \ 
	 5   4   7

- 思路：直接上

```c++
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {
        if(!t1 && !t2)
            return nullptr;
        TreeNode* root = new TreeNode();
        if(t1 && t2) {
            root->val = t1->val + t2->val;
            root->left = mergeTrees(t1->left, t2->left);
            root->right = mergeTrees(t1->right, t2->right);
        }else if(t1 && !t2) {
            root->val = t1->val;
            root->left = mergeTrees(t1->left, nullptr);
            root->right = mergeTrees(t1->right, nullptr);
        }else {
            root->val = t2->val;
            root->left = mergeTrees(t2->left, nullptr);
            root->right = mergeTrees(t2->right, nullptr);
        }
        return root;
    }
};
```

## 144.  647-中等-回文子串
**中等**
- 题目描述
给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。
具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。

- 示例：
输入："abc"
输出：3
解释：三个回文子串: "a", "b", "c"

输入："aaa"
输出：6
解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa"

- 思路：看代码注释

```c++
class Solution {
public:
    int countSubstrings(string s) {
        int n = s.size(), ans = 0;
        for (int i = 0; i < n; ++i) {
            int l = i, r = i; //以单字母为中心
            while (l >= 0 && r < n && s[l--] == s[r++]) ++ans;
            l = i, r = i + 1; //以双字母为中心
            while (l >= 0 && r < n && s[l--] == s[r++]) ++ans;
        }
        return ans;
    }
};
```

## 145.  654-中等-最大二叉树
**中等**
- 题目描述
给定一个不含重复元素的整数数组 nums 。一个以此数组直接递归构建的 最大二叉树 定义如下：

二叉树的根是数组 nums 中的最大元素。
左子树是通过数组中 最大值左边部分 递归构造出的最大二叉树。
右子树是通过数组中 最大值右边部分 递归构造出的最大二叉树。
返回有给定数组 nums 构建的 最大二叉树 。

- 思路: 直接上

```c++
class Solution {
public:
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        if(nums.size() == 0)
            return nullptr;
        return helper(nums, 0, nums.size() - 1);
    }
    TreeNode* helper(vector<int>& nums, int left, int right) {
        if(left > right)
            return nullptr;
        int max_i = left;
        for(int i = left + 1; i <= right; i++)  // 边界注意
            if(nums[i] > nums[max_i])
                max_i = i;
        TreeNode* root = new TreeNode(nums[max_i]);
        root->left = helper(nums, left, max_i - 1); // 因为有上面迭代中 max_i 可能 会等于 right
        root->right = helper(nums, max_i + 1, right);
        return root;
    }
};
```

## 146.  717-简单-1比特与2比特字符
**中等**
- 题目描述
有两种特殊字符。第一种字符可以用一比特0来表示。第二种字符可以用两比特(10?或?11)来表示。
现给一个由若干比特组成的字符串。问最后一个字符是否必定为一个一比特字符。给定的字符串总是由0结束。
解释：给你已经编码好的字符，判断是不是用单比特编码的字符结尾

- 示例:

输入: 
bits = [1, 0, 0]
输出: True
解释: 唯一的编码方式是一个两比特字符和一个一比特字符。所以最后一个字符是一比特字符。

输入: 
bits = [1, 1, 1, 0]
输出: False
解释: 唯一的编码方式是两比特字符和两比特字符。所以最后一个字符不是一比特字符。

- 思路：判断最后那个0前面有几个1

```c++
class Solution {
public:
    bool isOneBitCharacter(vector<int>& bits) {
        int sz = bits.size();
        if(sz == 1)
            return true;
        int numOfOne = 0;
        for(int i = sz - 2; i >= 0; i--) {
            if(bits[i] == 1)
                numOfOne++;
            else
                break;
        }
        return numOfOne % 2 == 0;   // 只与最后那个0前面的1的个数有关
    }
};
```

## 147.  718-中等-最长重复子数组
**中等** **dp**
- 题目描述
给两个整数数组?A?和?B?，返回两个数组中公共的、长度最长的子数组的长度。

- 示例：
输入：
A: [1,2,3,2,1]
B: [3,2,1,4,7]
输出：3
解释：长度最长的公共子数组是 [3, 2, 1] 。

- 思路：dp，滑动窗口

```c++
class Solution {
public:
    int findLength(vector<int>& A, vector<int>& B) {
        if(A.size() == 0 || B.size() == 0)
            return 0;
        vector<vector<int>> dp(A.size()+1, vector<int>(B.size()+1, 0));
        int ans = 0;
        for(int i = 1; i <= A.size(); i++) {
            for(int j = 1; j <= B.size(); j++) {
                if(A[i-1] == B[j-1]) {
                    dp[i][j] = dp[i-1][j-1] + 1;    // 想象一张表
                    ans = max(ans, dp[i][j]);       // 当前的dp与其左上角的值有关
                }
            }
        }
        return ans;
    }
};
```

## 148.  728-简单-自除数
**简单**
- 题目描述
自除数?是指可以被它包含的每一位数除尽的数。
例如，128 是一个自除数，因为?128 % 1 == 0，128 % 2 == 0，128 % 8 == 0。
还有，自除数不允许包含 0 。
给定上边界和下边界数字，输出一个列表，列表的元素是边界（含边界）内所有的自除数。

- 示例：
输入： 上边界left = 1, 下边界right = 22
输出： [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]

- 思路：直接上，用一个falg来辅助

```c++
class Solution {
public:
    vector<int> selfDividingNumbers(int left, int right) {
        int num = left;
        vector<int> ans;
        //unordered_map<int,int> table; // 用于记录
        bool flag = true;
        while(num <= right) {
            int tmp = num;
            while(tmp != 0) {
                int d = tmp % 10;
                if(d == 0 || num % d != 0) {
                    flag = false;
                    break;
                }
                tmp /= 10;
            }
            if(flag)
                ans.push_back(num);
            else
                flag = true;
            num++;
        }
        return ans;
    }
};
```

## 149.  739-中等-每日温度
**困难**
- 题目描述
请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用?0 来代替。

例如，给定一个列表?temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是?[1, 1, 4, 2, 1, 1, 0, 0]。

- 思路：维护递减栈，后入栈的元素总比栈顶元素小。比对当前元素与栈顶元素的大小
    1. 若当前元素 < 栈顶元素：入栈
    2. 若当前元素 > 栈顶元素：弹出栈顶元素，记录两者下标差值即为所求天数

```c++
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& T) {
        int size = T.size();
        vector<int> res(size, 0);
        stack<int> s;
        for (int i = size - 1; i >= 0; --i) {
            while(!s.empty() && T[i] >= T[s.top()])
                s.pop();
            res[i] = s.empty() ? 0 : (s.top() - i);
            s.push(i);
        }
        return res;
    }
};
```

## 150.  763-中等-划分字母区间
**中等**
- 题目描述
字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。
- 示例：
输入：S = "ababcbacadefegdehijhklij"
输出：[9,7,8]
解释：
划分结果为 "ababcbaca", "defegde", "hijhklij"。
每个字母最多出现在一个片段中。
像 "ababcbacadefegde", "hijhklij" 的划分是错误的，因为划分的片段数较少。

- 思路：用哈希记录每个字符最后出现的位置，然后遍历到i == end时结束一个片段

```c++
class Solution {
public:
    vector<int> partitionLabels(string S) {
        vector<int> ans;
        unordered_map<char, int> map;   //记录char c 和其最后出现位置的 map
        int start = 0, end = 0;
        for(int i = 0; i < s.size(); i++)
            map[S[i]] = i;
        for(int i = 0; i < s.size(); i++) {
            end = max(end, map[S[i]]);
            if(end == i) {
                ans.push_back(end - start + 1);
                start = end + 1;
            }
        }
        return ans;
        
    }
};
```

## 151.  767-中等-重构字符串
**困难**
- 题目描述
给定一个字符串S，检查是否能重新排布其中的字母，使得两相邻的字符不同。
若可行，输出任意可行的结果。若不可行，返回空字符串。

- 示例:

输入: S = "aab"
输出: "aba"

输入: S = "aaab"
输出: ""

- 思路：堆，看注释

```c++
class Solution {
public:
    string reorganizeString(string S) {
        int n = S.size();
        vector<int> cnt(26, 0);
        priority_queue<pair<int,char>> pq; // 默认大根堆，比较第一个数first int
        for(char c : S) {
            cnt[c-'a']++;
            if(cnt[c-'a']> (n+1)/2) //边界条件判断，数量最多的字母的个数超过S.size()+1)/2时，不能重构
                return "";
        }
        for(int i = 0; i < 26; i++) {
            if(cnt[i] > 0) {
                char c = 'a' + i;
                pq.push({cnt[i], c});   // c是字母， cnt[i]是频率
                // 频率越大越靠近顶端
            }
        }
        //重构字符串时，用了贪心的思想，先将优先队列最多的数量的字符间隔一个空格放入到字符数组中
        string ans(n, ' ');
        int idx = 0;
        //开始重构
        while(!pq.empty()) {
            pair<int, char> pair1 = pq.top();
            pq.pop();
            int num = pair1.first;
            int c = pair1.second;
            for(int i = 0; i < num; i++) {
                if(idx >= n)
                    idx = 1; //奇数位填完了，该填偶数位
                ans[idx] = c;
                idx += 2;
            }
        }
        return ans;
    }
};
```

## 152.  771- 简单-宝石与石头
**简单**
- 题目描述
给定字符串J?代表石头中宝石的类型，和字符串?S代表你拥有的石头。?S?中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。
J?中的字母不重复，J?和?S中的所有字符都是字母。字母区分大小写，因此"a"和"A"是不同类型的石头。

- 示例:
输入: J = "aA", S = "aAAbbbb"
输出: 3

输入: J = "z", S = "ZZ"
输出: 0
- 思路：用哈希表记录每一种S的数量，然后res += hash[ J[i] ];

```c++
class Solution {
public:
    int numJewelsInStones(string jewels, string stones) {
        if(jewels.size() == 0)
            return 0;
        unordered_map<char, int> exist;
        /* for(char jewel : jewels) {
            if(exist.count(jewel))
                return 0;
            exist[jewel]++;
        }
        int ans = 0;
        for(char stone : stones) {
            if(exist.count(stone))
                ans++;
        } */
        for(char stone : stones) {
            exist[stone]++;
        }
        int ans = 0;
        for(char jewel : jewels) {
            if(exist.count(jewel))
                ans += exist[jewel];
        }
        return ans;          
    }
};
```

## 153.  剑指09-简单-用两个栈实现队列
**简单**
```c++
class CQueue {
private:
    stack<int> s1;
    stack<int> s2;
public:
    CQueue() {
        /* s1.clear();
        s2.clear(); */
    }
    
    void appendTail(int value) {
        s1.push(value);
    }
    
    int deleteHead() {
        if(s2.empty() && s1.empty())
            return -1;
        if(s2.empty()) {
            while(!s1.empty()) {
                s2.push(s1.top());
                s1.pop();
            }
        }
        int ans = s2.top();
        s2.pop();
        return ans;
    }
};
```

## 154.  剑指10-I-简单-斐波那契数列
**简单**
写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：

F(0) = 0,? ?F(1)?= 1
F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。

答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

```c++
class Solution {
public:
    int fib(int n) {
        if(n < 2)
            return n;
        int a = 0, b = 1;
        for(int i = 2; i <= n; i++) {
            b = a + b;
            a = b - a;
            b %= 1000000007;
        }
        return b;
    }
};
```

## 155.  剑指03-简单-数组中重复的数字
**简单**
- 题目描述
找出数组中重复的数字。
在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。

- 示例：
输入：[2, 3, 1, 0, 2, 5, 3]
输出：2 或 3 

```c++
class Solution {
public:
    int findRepeatNumber(vector<int>& nums) {
        /* unordered_map<int,int> table;
        for(int n : nums) {
            table[n]++;
            if(table[n] > 1)
                return n;
        }
        return -1;
        //时间复杂度 O(n), 空间复杂度O(n) */
        sort(nums.begin(), nums.end());//时间复杂度 O(nlogn)
        for(int i = 1; i < nums.size(); i++) {
            if(nums[i] == nums[i-1])
                return nums[i];
        }
        return -1;
        //时间复杂度 O(nlogn), 空间复杂度O(1)
    }
};
```


## 156.  剑指04-中等-二维数组中的查找
**简单**
在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

示例:
现有矩阵 matrix 如下：
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
给定 target?=?5，返回?true。
给定?target?=?20，返回?false。

```c++
class Solution {
public:
    bool findNumberIn2DArray(vector<vector<int>>& matrix, int target) {
        int n = matrix.size();
        if(n == 0)
            return false;
        int m = matrix[0].size();
        if(m == 0)
            return false;
        int i = n - 1, j = 0;
        while(i >= 0 && j < m) {
            if(matrix[i][j] == target)
                return true;
            else if(matrix[i][j] > target)
                i--;
            else
                j++;
        }
        return false;
    }
};
```

## 157.  剑指10-II-简单-青蛙跳台阶问题
**简单**
一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n?级的台阶总共有多少种跳法。
答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

- 示例：
输入：n = 2     输出：2
输入：n = 7     输出：21
输入：n = 0     输出：1

```c++
class Solution {
public:
    int numWays(int n) {
        if(n == 0)
            return 1;
        vector<int> dp(n+1, 1);
        for(int i = 2; i <= n; i++) {
            dp[i] = dp[i-1] + dp[i-2];
            dp[i] %= 1000000007;
        }
        return dp[n];
    }
};
```


## 158.  剑指11-简单-旋转数组的最小数字
**简单**
- 题目描述
把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组?[3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。??
- 示例
输入：[3,4,5,1,2]   输出：1
输入：[2,2,2,0,1]   输出：0

```c++
class Solution {
public:
    int minArray(vector<int>& numbers) {
        /* // 时间复杂度 O(n)
        for(int i = 1; i < numbers.size(); i++) {
            if(numbers[i] < numbers[i-1])
                return numbers[i];
        }
        return numbers[0]; */
        if(numbers.size() < 1)
            return -1;
        int l = 0, r = numbers.size()-1;
        while(l < r) {
            int mid = (l+r) >> 1;
            if(mid > 0 && numbers[mid-1] > numbers[mid])
                return numbers[mid];
            if(numbers[mid] > numbers[r])   //还在左边递增序列
                l = mid + 1;
            else if(numbers[mid] < numbers[r]) //在右边递增序列
                r = mid;
            else
                r--;
        }
        return numbers[l];  //这边索引是numbers[l]
    }
};
```

## 159.  剑指05-简单-替换空格
**简单**
- 题目描述
请实现一个函数，把字符串 s 中的每个空格替换成"%20"

- 示例：
输入：s = "We are happy."
输出："We%20are%20happy."

```c++
class Solution {
public:
    string replaceSpace(string s) {
        if(s.size() == 0)
            return s;
        int numOfBlank = 0;
        for(char c : s)
            if(c == ' ')
                numOfBlank++;
        if(numOfBlank == 0)
            return s;
        int oriLength = s.size() - 1;
        s += string(numOfBlank * 2, ' ');
        int newLength = s.size() - 1;
        while(oriLength >= 0) {
            if(s[oriLength] != ' ') {
                s[newLength] = s[oriLength];
                newLength--;
            }else {
                s[newLength--] = '0';
                s[newLength--] = '2';
                s[newLength--] = '%';
            }
            oriLength--;
        }
        return s;
        
        /* // 原来的字符会被替换掉
        for(int i = 0; i < s.size(); i++) {
            if(s[i] == ' ') {
                s[i] = '%';
                s[i+1] = '2';
                s[i+2] = '0';
                i += 2;
            }
        } */
        return s;
    }
};
```

## 160.  剑指06-简单-从尾到头打印链表
**简单**
```c++
class Solution {
public:
    //vector<int> ans;
    vector<int> reversePrint(ListNode* head) {
        /* helper(head);
        return ans; */
        //一种不需要递归直接遍历的方法，需要遍历两次链表
        if(!head)
            return {};
        int cnt = 0;
        ListNode* node = head;
        while(node) {
            node = node->next;
            cnt++;
        }
        vector<int> ans(cnt, 0);
        node = head;
        for(int i = 1; i <= cnt; i++) {
            ans[cnt-i] = node->val;
            node = node->next;
        }
        return ans;
    }
    /* void helper(ListNode* head) {
        if(!head)
            return;
        helper(head->next);
        ans.push_back(head->val);
    } */
};
```

## 161.  剑指07-中等-重建二叉树
**中等**
- 题目描述
输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

例如，给出
    前序遍历 preorder =?[3,9,20,15,7]
    中序遍历 inorder = [9,3,15,20,7]
返回如下的二叉树：
    3
   / \
  9  20
    /  \
   15   7
?
```c++
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        if(preorder.size() != inorder.size() || preorder.size() < 1)
            return nullptr;
        return helper(preorder, inorder, 0, preorder.size()-1, 0, inorder.size()-1);
    }
    TreeNode* helper(vector<int>& po, vector<int>& io, int pl, int pr, int il, int ir) {
        if(pl > pr || il > ir)
            return nullptr;
        TreeNode* root = new TreeNode(po[pl]);
        int rootInInorder = il;
        while(po[pl] != io[rootInInorder]) rootInInorder++;
        int left = rootInInorder - il;  //leftTreeNum
        root->left = helper(po, io, pl+1, pl+left, il, rootInInorder-1);
        root->right = helper(po, io, pl+left+1, pr, rootInInorder+1, ir);        
        return root;
    }
};
```

## 162.  剑指14-I-中等-剪绳子
**困难** **dp**
- 题目描述
给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。
- 思路：
对于的正整数 n，当 n≥2 时，可以拆分成至少两个正整数的和。令 k 是拆分出的第一个正整数，则剩下的部分是 n?k，n?k 可以不继续拆分，或者继续拆分成至少两个正整数的和。由于每个正整数对应的最大乘积取决于比它小的正整数对应的最大乘积，因此可以使用动态规划求解。

dp数组的含义： dp[i] 表示将正整数 i 拆分成至少两个正整数的和之后，这些正整数的最大乘积。
边界条件： 0 不是正整数，1 是最小的正整数，0 和 1 都不能拆分，因此 dp[0]=dp[1]=0。
状态转移方程：
当 i≥2 时，假设对正整数 i 拆分出的第一个正整数是 j（1≤j<i），则有以下两种方案：

将 i 拆分成 j 和 i?j 的和，且 i?j 不再拆分成多个正整数，此时的乘积是 j×(i?j)；
将 i 拆分成 j 和 i?j 的和，且 i?j 继续拆分成多个正整数，此时的乘积是 j×dp[i?j]。
因此，当 j 固定时，有 dp[i]=max(j×(i?j),j×dp[i?j])。由于 j 的取值范围是 1 到 i?1，需要遍历所有的 j 得到 dp[i] 的最大值，因此可以得到状态转移方程如下：

dp[i]= max_{1≤j<i} {(j×(i?j),j×dp[i?j])}

最终得到 dp[n] 的值即为将正整数 n 拆分成至少两个正整数的和之后，这些正整数的最大乘积。

```c++
class Solution {
public:
    int cuttingRope(int n) {
        vector<int> dp(n+1,0);
        dp[1] = 1;
        for(int i = 2; i <= n; i++) {
            for(int j = 1; j <= i; j++) {
                dp[i] = max(dp[i], max(j*(i-j), j*dp[i-j]));//不懂状态更新
            }
        }
        return dp[n];
    }
};
```

## 163.  剑指25-简单-合并两个排序的链表
**简单**
- 题目描述
输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。

- 示例：
输入：1->2->4, 1->3->4
输出：1->1->2->3->4->4

```c++
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        if(!l1)
            return l2;
        if(!l2)
            return l1;
        if(l1->val < l2->val) {
            l1->next = mergeTwoLists(l1->next, l2);
            return l1;
        }else {
            l2->next = mergeTwoLists(l1,l2->next);
            return l2;
        }
    } 
};
```

## 164.  剑指26-中等-树的子结构
**中等**
- 题目描述
输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)
B是A的子结构， 即 A中有出现和B相同的结构和节点值。

- 例如:
给定的树 A:
? ? ?3
? ? / \
? ?4 ? 5
? / \
?1 ? 2
给定的树 B：
? ?4?
? /
?1
返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。

```c++
class Solution {
public:
    bool isSubStructure(TreeNode* A, TreeNode* B) {
        if(A == nullptr || B == nullptr)
            return false;
        return hasSubStructure(A, B) || isSubStructure(A->left, B) || isSubStructure(A->right, B);
    }
    bool hasSubStructure(TreeNode* A, TreeNode* B) {
        if(B == nullptr)    // B 对比完了
            return true;    
        if(A == nullptr || A->val != B->val)
            return false;   // B 还没对比完 A就完了
        return hasSubStructure(A->left, B->left) && hasSubStructure(A->right, B->right);
    }
};
```

## 165.  剑指27-简单-二叉树的镜像
**简单**
- 题目描述
请完成一个函数，输入一个二叉树，该函数输出它的镜像。

- 例如输入：
? ? ?4
? ?/ ? \
? 2 ? ? 7
?/ \ ? / \
1 ? 3 6 ? 9
镜像输出：
? ? ?4
? ?/ ? \
? 7 ? ? 2
?/ \ ? / \
9 ? 6 3? ?1

```c++
class Solution {
public:
    TreeNode* mirrorTree(TreeNode* root) {
        if(!root)
            return nullptr;
        // 前序遍历
        TreeNode* tmp = root->left;
        root->left = root->right;
        root->right = tmp;
        mirrorTree(root->left);
        mirrorTree(root->right);
        // 后序也可
        /* TreeNode* tmp = root->left;
        root->left = root->right;
        root->right = tmp; */
        return root;
    }
};
```

## 166.  剑指28-简单-对称的二叉树
**简单**
- 题目描述
请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。
例如，二叉树?[1,2,2,3,4,4,3] 是对称的。
? ? 1
? ?/ \
? 2 ? 2
?/ \ / \
3 ?4 4 ?3
但是下面这个?[1,2,2,null,3,null,3] 则不是镜像对称的:
? ? 1
? ?/ \
? 2 ? 2
? ?\ ? \
? ?3 ? ?3

```c++
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if(!root)
            return true;//用例有点、、、sjb
        return helper(root->left, root->right);
    }
    bool helper(TreeNode* a, TreeNode* b) {
        if(!a && !b)
            return true;
        if(!a || !b)
            return false;
        return a->val == b->val && helper(a->left, b->right) && helper(a->right, b->left);
    }
};
```

## 167.  剑指21-简单-调整数组顺序使奇数位于偶数前面
**简单**
- 题目描述
输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。
解释：就是让奇数元素排在偶数元素前面

- 示例：

输入：nums =?[1,2,3,4]
输出：[1,3,2,4] 
注：[3,1,2,4] 也是正确的答案之一。

```c++
class Solution {
public:
    vector<int> exchange(vector<int>& nums) {
        int sz = nums.size();
        if(sz < 2)
            return nums;
        int l = 0, r = sz - 1; // odd pointer, even pointer
        while(l < r) {
            while(l < r && (nums[l] % 2) != 0) l++;    //找到最前面的even
            while(l < r && (nums[r] % 2) == 0) r--;    //找到最后面的odd
            if(l < r) {
                int tmp = nums[l];
                nums[l] = nums[r];
                nums[r] = tmp;
            }
        }
        return nums;
    }
};
```

## 168.  剑指15-简单-二进制中1的个数
**简单**
- 题目描述
请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9?表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。

```c++
class Solution {
public:
    int hammingWeight(uint32_t n) {
        if(n == 0)
            return 0;
        int ans = 0;
        while(n != 0) {
            ans++;
            n = n & (n-1);
        }
        return ans;
    }
};
```

## 169.  剑指29-简单-顺时针打印矩阵
**简单**
- 题目描述
输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。

```c++
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        if(matrix.size() == 0 || matrix[0].size() == 0)
            return {};
        int up = 0;
        int down = matrix.size() - 1;
        int left = 0;
        int right = matrix[0].size() - 1;
        vector<int> ans;
        //while(up <= down && left <= right)
         while(true) {  // attention!!
            for(int i = left; i <= right; i++)
                ans.push_back(matrix[up][i]);
            if(++up > down) 
                break;
            for(int i = up; i <= down; i++) 
                ans.push_back(matrix[i][right]);
            if(--right < left)
                break;
            for(int i = right; i >= left; i--)
                ans.push_back(matrix[down][i]);
            if(--down < up)
                break;
            for(int i = down; i >= up; i--) 
                ans.push_back(matrix[i][left]);
            if(++left > right)
                break;
        }
        return ans;
    }
};
```

## 170.  剑指22-简单-链表中倒数第k个节点
**简单**
- 题目描述
输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。
例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 2 个节点是值为 4 的节点。

- 示例：
给定一个链表: 1->2->3->4->5, 和 k = 2.
返回链表 4->5.

```c++
class Solution {
public:
    ListNode* getKthFromEnd(ListNode* head, int k) {
        ListNode* fast = head;
        while(k-- > 0)
            fast = fast->next;
        ListNode* slow = head;
        while(fast) {
            slow = slow->next;
            fast = fast->next;
        }
        return slow;
    }
};
```

## 171.  剑指16-中等-数值的整数次方
**中等**
- 题目描述
实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。

- 示例:
输入: 2.00000, 10       输出: 1024.00000

输入: 2.10000, 3        输出: 9.26100

输入: 2.00000, -2       输出: 0.25000
解释: 2-2 = 1/22 = 1/4 = 0.25

```c++
class Solution {
public:
    double myPow(double x, int n) {
        // 用二分的思想
        if(n == 0)
            return 1.0;
        if(n == 1)
            return x;
        if(n == -1)
            return 1 / x;
        double half = myPow(x, n / 2);
        double rest = myPow(x, n % 2);
        return half * half * rest;
    }
};
```

## 172.  剑指24-简单-反转链表
**简单**
- 题目描述
定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。

- 示例:

输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL

```c++
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if(!head || !head->next)
            return head;
        /* ListNode* pre = nullptr;
        ListNode* cur = head;
        ListNode* next = nullptr;
        while(cur) {
            next = cur->next;
            cur->next = pre;
            pre = cur;
            cur = next;
        }
        return pre; */
        ListNode* node = reverseList(head->next);
        head->next->next = head;
        head->next = nullptr;
        return node;
    }
};
```

## 173.  剑指18-简单-删除链表的节点
**简单**
- 题目描述
给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。
返回删除后的链表的头节点。

- 思路：好像删掉的节点不需要delete？
```c++
class Solution {
public:
    ListNode* deleteNode(ListNode* head, int val) {
        if(!head)
            return head;
        if(head->val == val)
            return head->next;
        ListNode* p = head;// p == cur
        ListNode* pre = nullptr;
        while(p->val != val) {
            pre = p;
            p = p->next;
        }
        pre->next = p->next;
        return head;
    }
};
```

## 174.  剑指40-简单-最小的k个数
**简单**
- 题目描述
输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。
```c++
class Solution {
public:
    vector<int> getLeastNumbers(vector<int>& arr, int k) {
        /* sort(arr.begin(),arr.end());
        vector<int> ans(arr.begin(), arr.begin()+k);
        return ans; */
        if(k == 0) 
            return {};
        priority_queue<int, vector<int>, greater<int>> pq; // 小根堆
        int pqSize = arr.size() - k;
        vector<int> ans;
        for(int num : arr) {
            pq.push(num);
            if(pq.size() > pqSize) {
                ans.push_back(pq.top());
                pq.pop();
            }
        }
        return ans;
    }
};
```


## 175.  剑指30-简单-包含min函数的栈
**中等**
- 题目描述
定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。

```c++
struct Node {
    int val;
    int curMin;
    Node* next;

    Node(int x,int y, Node* n) : val(x), curMin(y), next(n) {}
    Node() {
        val = 0; curMin = 0; next = nullptr;
    }
};
class MinStack {
private:
    Node* node;
    int curMin;
public:
    /** initialize your data structure here. */
    /* stack<int> stk;
    stack<int> minStk; */
    
    MinStack() {
        curMin = INT_MAX;
        node = nullptr;
    }
    
    void push(int x) {
        /* stk.push(x);
        if(minStk.empty() || x <= minStk.top())
            minStk.push(x); */
        //curMin = std::min(x, curMin); //这是错的
        if(node == nullptr)
            node = new Node(x, x, nullptr);
        else
            node = new Node(x, std::min(x, node->curMin), node); // 这里秒啊！！
    }
    
    void pop() {
        /* if(!stk.empty()){
            if(stk.top() == minStk.top()) {
                minStk.pop();
            }
            stk.pop();
        } */
        if(node->next) {
            Node* tmp = node;
            node = node->next;
            delete tmp;
            tmp = nullptr;
        }else {
            delete node;
            node = nullptr;
        }
    }
    
    int top() {
        /* return stk.top(); */
        return node->val;
    }
    
    int min() {
        /* return minStk.top(); */
        return node->curMin;
    }
};
/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack* obj = new MinStack();
 * obj->push(x);
 * obj->pop();
 * int param_3 = obj->top();
 * int param_4 = obj->min();
 */
```

## 176.  剑指42-简单-连续子数组的最大和
**中等** **dp**
- 题目描述
输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。
要求时间复杂度为O(n)。

- 示例:
输入: nums = [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释:?连续子数组?[4,-1,2,1] 的和最大，为?6。

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        /* int sum = 0;
        int ans = INT_MIN;
        for(int num : nums) {
            if(sum < 0)
                sum = num;
            else
                sum += num;
            if(sum > ans)
                ans = sum;
        }
        return ans; */
        vector<int> dp(nums.size(), 0);
        dp[0] = nums[0];    //初始化条件
        int ans = nums[0];      //初始化条件
        for(int i = 1; i < nums.size(); i++) {
            dp[i] = max(nums[i], nums[i]+dp[i-1]);
            ans = max(ans,dp[i]);
        }
        return ans;
    }
};
```

## 177.  剑指36-中等-二叉搜索树与双向链表
**中等**
- 题目描述
输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。

```c++
class Solution {
public:
    Node* head;
    Node* pre;
    Node* treeToDoublyList(Node* root) {
        if(!root)
            return nullptr;
        inorder(root);
        pre->right = head;
        head->left = pre;
        return head;
    }
    void inorder(Node* cur) {
        if(!cur)
            return;
        inorder(cur->left);
        if(!head)
            head = cur;
        if(!pre)
            pre = cur;
        else {
            pre->right = cur;
            cur->left = pre;
            pre = cur;
        }
        inorder(cur->right);
    }
};
```

## 178.  剑指31-中等-栈的压入、弹出序列
**中等**
- 题目描述
输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。

```c++
class Solution {
public:
    bool validateStackSequences(vector<int>& pushed, vector<int>& popped) {
        if(pushed.empty() || popped.empty())
            return true;
        stack<int> stk;
        int k = 0;
        for(int num : pushed) {
            stk.push(num);
            while(!stk.empty() && stk.top() == popped[k]) {
                stk.pop();
                k++;
            }
        }
        return stk.empty();
    }
};
```

## 179.  剑指38-中等-字符串的排列
**中等**
- 题目描述
输入一个字符串，打印出该字符串中字符的所有排列。
你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。

- 示例:
输入：s = "abc"
输出：["abc","acb","bac","bca","cab","cba"]

```c++
class Solution {
public:
    vector<string> ans;
    string path = "";
    vector<string> permutation(string s) {
        if(s.size() == 0)
            return ans;
        if(s.size() == 1) {
            ans.push_back(s);
            return ans;
        }
        sort(s.begin(), s.end());   //这里注意！！！
        vector<bool> used(s.size(), false);
        dfs(s, used);
        return ans;
    }
    void dfs(string s, vector<bool> used) {
        if(path.size() == s.size()) {
            ans.push_back(path);
            return;
        }
        for(int i = 0; i < s.size(); i++) {
            if(used[i])
                continue;
            if(i > 0 && !used[i-1] && s[i]==s[i-1]) // 这里注意是used[i-1]
                continue;
            used[i] = true;
            path.push_back(s[i]);
            dfs(s, used);
            path.pop_back();
            used[i] = false;
        }
    }
};
```

## 180.  剑指39-简单-数组中出现次数超过一半的数字
**简单**
- 题目描述
数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。
你可以假设数组是非空的，并且给定的数组总是存在多数元素。

- 示例:
输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]
输出: 2

```c++
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        //时间O(nlogn)，空间O(1)
        /* sort(nums.begin(), nums.end());
        return nums[nums.size()/2]; */
        //时间O(n)，空间O(n/2)
        /* unordered_map<int, int> hash;
        int targetNum = nums.size() / 2;
        int ans = nums[0];
        for(int num : nums) {
            hash[num]++;
            if(hash[num] > targetNum) {
                ans = num;
                break;
            }
        }
        return ans; */
        //解法三：摩尔投票法
        //也可以理解成混战极限一换一，不同的两者一旦遇见就同归于尽，最后活下来的值都是相同的，即要求的结果
        //时间O(n)，空间O(1)
        int ans = 0;
        int count = 0;
        for(int num : nums) {
            if(count == 0) {
                ans = num;
                count++;
            }else {
                if(ans == num)
                    count++;
                else
                    count--;
            }
        }
        return ans;
    }
};
```

## 181.  剑指32-中等-I-从上到下打印二叉树
**中等**
- 题目描述
从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印

```c++
class Solution {
public:
    vector<int> levelOrder(TreeNode* root) {
        vector<int> ans;
        if(!root)
            return ans;
        queue<TreeNode*> q;
        q.push(root);
        while(!q.empty()) {
            TreeNode* node = q.front();
            q.pop();
            if(node->left)
                q.push(node->left);
            if(node->right)
                q.push(node->right);
            ans.push_back(node->val);
        }
        return ans;
    }
};
```

## 182.  剑指32-简单-II-从上到下打印二叉树 II
**简单**
- 题目描述(只是打印方式不一样，其他跟181一样啦)
从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行

```c++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> ans;
        if(!root)
            return ans;
        queue<TreeNode*> q;
        q.push(root);
        while(!q.empty()) {
            vector<int> data;
            int sz = q.size();
            for(int i = 0; i < sz; i++) {
                TreeNode* node = q.front();
                q.pop();
                data.push_back(node->val);
                if(node->left)
                    q.push(node->left);
                if(node->right)
                    q.push(node->right);
            }
            ans.push_back(data);
        }
        return ans;
    }
};
```

## 183.  剑指32-中等-从上到下打印二叉树 III
**简单**
- 题目描述（除了打印方式不一样，其他与182都一样）
请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。

```c++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> ans;
        if(root == NULL){
            return ans;
        }
        queue<TreeNode*> q;
        q.push(root);
        bool isLeft = false;
        while(!q.empty()){
            int rowLen = q.size();
            vector<int> temp;
            for(int i = 0; i < rowLen; ++i){
                TreeNode* curNode = q.front();
                q.pop();
                if(curNode != NULL){
                    temp.push_back(curNode->val);
                    if(curNode->left)q.push(curNode->left);
                    if(curNode->right)q.push(curNode->right);
                }
            }
            isLeft = !isLeft;
            if(!isLeft){
                ans.push_back(vector<int>(temp.rbegin(), temp.rend())); //用vector<int>(temp.rbegin(), temp.rend())取代了reverse就快好多啊
            }else{
                ans.push_back(temp);
            }
        }
        return ans;
    }
};
```

## 184.  剑指33-中等-二叉搜索树的后序遍历序列
**中等**
- 题目描述
输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。

- 思路：

```c++
class Solution {
public:
    bool verifyPostorder(vector<int>& postorder) {
        int sz = postorder.size();
        if(sz < 2)
            return true;
        return helper(postorder, 0, sz-1);
    }
    bool helper(vector<int>& postorder, int l, int r) {
        if(l >= r)  //边界条件，不符合l<r通通给true
            return true;
        int root = postorder[r];
        int mid = l;
        // 别忘了mid < r
        while(mid < r && root > postorder[mid]) mid++; // 此时的mid索引对应的数postorder[mid]已经大于等于root
        //用for来检验，因为mid还有后用
        for(int i = mid; i < r; i++)
            if(postorder[i] < root)
                return false;   //这是属于root的右子树部分，如果小于root则不是
        if(!helper(postorder, l, mid-1))
            return false;
        if(!helper(postorder, mid, r-1))
            return false;
        return true;
    }
};
```

## 185.  剑指50-简单-第一个只出现一次的字符
**简单**
- 题目描述
在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。

```c++
class Solution {
public:
    char firstUniqChar(string s) {
        int sz = s.size();
        if(sz == 0)
            return ' ';
        unordered_map<char, int> hash;
        for(char c : s)
            hash[c]++;
        for(char c : s) {
            if(hash[c]==1)
                return c;
        }
        return ' ';
    }
};
```

## 186.  剑指34-中等-二叉树中和为某一值的路径
**中等**
- 题目描述
输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。

```c++
class Solution {
public:
    vector<vector<int>> ans;
    vector<int> path;
    vector<vector<int>> pathSum(TreeNode* root, int sum) {
        if(!root)
            return ans;
        dfs(root, sum);
        return ans;
    }
    void dfs(TreeNode* root, int sum) {
        if(!root)
            return;
        if(!root->left && !root->right && sum == root->val) {
            path.push_back(root->val);
            ans.push_back(path);
            path.pop_back();
            return;
        }
        path.push_back(root->val);
        dfs(root->left, sum-root->val);
        dfs(root->right, sum-root->val);
        path.pop_back();
    }
};
```

## 187.  剑指55-I-简单-二叉树的深度
**简单**
- 题目描述
输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。

```c++
class Solution {
public:
    int maxDepth(TreeNode* root) {
        //return !root ? 0 : max(maxDepth(root->left), maxDepth(root->right)) + 1;
        if(!root)
            return 0;
        int ans = 0;
        queue<TreeNode*> q;
        q.push(root);
        while(!q.empty()) {
            int sz = q.size();
            TreeNode* node;
            for(int i = 0; i< sz; i++) {
                node = q.front();
                q.pop();
                if(node->left) q.push(node->left);
                if(node->right) q.push(node->right);
            } 
            ans++;
        }
        return ans;
    }
};
```

## 188.  剑指56-I-中等-数组中数字出现的次数
**困难**
- 题目描述
一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。

```c++
class Solution {
public:
    vector<int> singleNumbers(vector<int>& nums) {
        int sz = nums.size();
        if(sz == 2)
            return nums;
        int helper = 0;
        for(int num : nums)
            helper = helper ^ num;  // 将所有数异或
        int index = 0;
        while((helper & 1) == 0) {
            helper = helper >> 1;
            index++;//就是那个1的位置
        }// 找出异或结果中的最低位1，（其他位1也可以但这个1比较好找）
         // 异或结果中的1位代表两个不同的数在这个位置是不同的，所以可以分成两组
        int n1 = 0, n2 = 0;
        for(int num : nums) {
            if((num >> index) & 1)
                n1 = n1 ^ num;
            else
                n2 = n2 ^ num;
        }
        vector<int> ans{n1, n2};
        return ans;
        /* vector<int> ans;
        unordered_map<int, int> hash;
        for(int num : nums)
            hash[num]++;
        for(int num : nums) {
            if(hash[num] == 1)
                ans.push_back(num);
            if(ans.size() == 2)
                break;
        }
        return ans; */
    }
};
```

## 189.  剑指56-II-中等-数组中数字出现的次数 II
**中等**
- 题目描述
在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。

```c++
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        /* sort(nums.begin(),nums.end());
        for(int i = 0; i < nums.size() - 2; i+=3) { // 这里细节
            if(nums[i] != nums[i+2]) {
                return nums[i];  
            }
        }
        return nums.back(); //这里细节 */
        // 另外hash方法就不试啦
        int ans = 0;
        for(int i = 0; i < 32; i++) { //移动了0次~31次
            int cnt = 0; // 计算每一位中的1的个数的和
            for(int num : nums) {
                if(num & (1 << i))
                    cnt++;
            }
            if(cnt % 3 != 0) {  //说明答案在这个位上是1，否则答案在这个位上是0
                ans = ans ^ (1 << i);
            }
        }
        return ans;
    }
};
```

## 190.  剑指57-简单-和为s的两个数字
**简单**
- 题目描述
输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
    /* 解法1： 使用hash表，一次遍历，时间O(N)，空间O(N)，此方法和leetcode两数之和一样，但那道题数组无序，本题数组有序，所以肯定有更优解

    解法2： 使用二分，遍历数组，比如target=40,nums[0] = 10，那么用二分查找30。时间O(NLogN)，空间O(1)

    解法3： 使用双指针，时间O(N) 空间O(1)，应该是最优解了吧。。 */
        int l = 0, r = nums.size() - 1;
        while(l < r) {
            int sum = nums[l] + nums[r];
            if(sum == target)
                break;
            else if(sum > target)
                r--;
            else
                l++;
        }
        return {nums[l], nums[r]};
    }
};
```

## 191.  剑指45-中等-把数组排成最小的数
**困难**
- 题目描述
输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。

- 示例:
输入: [10,2]        输出: "102"

```c++
class Solution {
public:
    string minNumber(vector<int>& nums) {
        vector<string> str;
        string ans;
        for(int n : nums)
            str.push_back(to_string(n));
        /* sort(str.begin(), str.end(), cmp); */
        //或者用以下lamda
        sort(str.begin(), str.end(), [](const string& a, const string& b){return a+b < b+a;});
        for(string s : str)
            ans = ans + s;
        return ans;
    }
private:
    static bool cmp(const string& a, const string& b) {
        return a+b < b+a;
    }
};
```

## 192.  剑指57-II-简单-和为s的连续正数序列
**中等**
- 题目描述
输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。
序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。

- 示例：
输入：target = 9        输出：[[2,3,4],[4,5]]

```c++
class Solution {
public:
    vector<vector<int>> findContinuousSequence(int target) {
        /* int i = 1;
        double j = 2.0;
        vector<vector<int>> result;
        while(i < j) {
            //公式推导：target = (i+j)/2 * (j-i+1)  既平均值*个数，因此可以通过i和target来算出j
            j = (-1+sqrt(1+4*(2*target+(long)i*i-i)))/2;
            if(j == (int)j) {
                vector<int> ans;
                for(int k = i; k <= j; k++) {
                    ans.push_back(k);
                }
                result.push_back(ans);
            }
            i++;    
        }
        return result;
        //时间 O(n) 空间 O(1) */
        //以下是滑动窗口， actually是双指针，时间 O(n) 空间 O(1) 
        int i = 1, j = 2;
        int sum = i+j;
        vector<vector<int>> result;
        if(target == 1)
            return result;
        while(i < j) {
            if(sum == target) {
                vector<int> ans;
                for(int k = i; k <= j; k++)
                    ans.push_back(k);
                result.push_back(ans);
                sum -= i;
                i++;
            }else if(sum < target) {
                j++;
                sum += j;
            }
            else {
                sum -= i;
                i++;
            }
        }
        return result;
    }
};
```

## 193.  剑指52-简单-两个链表的第一个公共节点
**简单**
- 题目描述
输入两个链表，找出它们的第一个公共节点。

```c++
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        if(!headA || !headB)
            return nullptr;
        ListNode* you = headA;
        ListNode* she = headB;
        while(you != she) {
            you = you ? you->next : headB;  // 走完自己的路走她的路
            she = she ? she->next : headA;  // 走完她自己的路再走你的路
        }                                   // 如果相遇则有缘，你则是她
        return you;                         // 如果无缘则，都是nullptr
    }
};
```

## 194.  剑指47-中等-礼物的最大价值
**中等** **dp**
- 题目描述
在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？

- 示例:
输入: 
[
? [1,3,1],
? [1,5,1],
? [4,2,1]
]
输出: 12
解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物

```c++
class Solution {
public:
    int maxValue(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();
        if(n == 1 && m == 1)
            return grid[0][0];
        /* vector<vector<int>> dp(m, vector<int>(n, 0));
        dp[0][0] = grid[0][0];
        for(int i = 1; i < n; i++)
            dp[0][i] = dp[0][i-1] + grid[0][i];
        for(int i = 1; i < m; i++)
            dp[i][0] = dp[i-1][0] + grid[i][0];
        for(int i = 1; i < m; i++) {
            for(int j= 1; j < n; j++) {
                dp[i][j] = grid[i][j] + max(dp[i-1][j], dp[i][j-1]);
            }
        }
        return dp[m-1][n-1]; */
        vector<int> dp(n+1, 0);
        for(int i = 0; i < m; i++) {
            for(int j = 0; j < n; j++) {
                dp[j+1] = max(dp[j], dp[j+1]) + grid[i][j]; // dp[j]是前面，dp[j+1]是上面
            }
        }
        return dp[n];
    }
};
```

## 195.  剑指58-I-简单-翻转单词顺序
**困难**
- 题目描述
输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串"I am a student. "，则输出"student. a am I"。

- 示例：

输入: "the sky is blue"
输出:?"blue is sky the"

输入: " ?hello world! ?"
输出:?"world! hello"
解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。

输入: "a good ? example"
输出:?"example good a"
解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。

```c++
class Solution {
public:
    string reverseWords(string s) {
        int l = 0, r = s.size()-1;
        while(s[l]==' ' && l < s.size()) l++;   // 去左空格
        if(l == s.size()) return "";
        while(s[r]==' ') r--;                   // 去右空格
        int idx = 0;
        while(l <= r) {
            s[idx++] = s[l++];
            while(s[l] == ' ' && s[l+1] == ' ') l++;
        }
        s.erase(idx);
        reverse(s.begin(), s.end());
        //reverse(s.begin(), s.begin()+idx);
        l = 0, r = 0;
        while(r < idx) {
            // 令s[l]为字符开始，s[r]为字符结束，s[r+1]==' ' or r+1==idx
            while(r+1 < idx && s[r+1] != ' ') r++;
            int next = r + 2;
            while(l < r) swap(s[l++], s[r--]);
            l = next, r = next;
        }
        return s;
    }
};
```

## 196.  剑指53-I-简单-在排序数组中查找数字 I
**中等**
- 题目描述
统计一个数字在排序数组中出现的次数。

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        if(nums.size() == 0)
            return 0;
        int l = 0, r = nums.size() - 1;
        while(l < r) {
            int mid = (l+r) >> 1; // 这里是向下取整
            if(target <= nums[mid])
                r = mid;
            else
                l = mid + 1;
        }
        if(nums[l] != target) 
            return 0;
        int left = l;//找到左边界
        /* l = 0, r = nums.size() - 1;
        while(l < r) {
            int mid = (l+r+1) >> 1; // 注意这里的加一！！！是为了向上取整
            if(target >= nums[mid])
                l = mid;
            else
                r = mid - 1;
        }
        int right = l; //
        return right - left + 1;  */
        //上面是找target的左右边界，下面是找target+1的左边界
        l = 0, r = nums.size(); // 注意这里
        while(l < r) {
            int mid = (l+r) >> 1; // 这里是向下取整
            if(target+1 <= nums[mid])
                r = mid;
            else
                l = mid + 1;
        }
        int right = l;
       /*  if(right == left)   
            return 1; */
        return right - left;
    }
};
```

## 197.  剑指58-II-简单-左旋转字符串
**简单**
- 题目描述
字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串"abcdefg"和数字2，该函数将返回左旋转两位得到的结果"cdefgab"。

```c++
class Solution {
public:
    string reverseLeftWords(string s, int n) {
        /* int sz = s.size();
        if(sz == 1)
            return s;
        s = s + string(n, ' ');
        for(int i = 0; i < n; i++) {
            s[sz+i] = s[i];
        }
        return s.substr(n); */
        //以上是字符串拼接
        //以下是字符串反转，原地算法
        if(s.size() == 1)
            return s;
        reverse(s.begin(), s.begin()+n);
        reverse(s.begin()+n, s.end());
        reverse(s.begin(), s.end());
        return s;
    }
};
```



## 198.  剑指53-II-简单-0～n-1中缺失的数字
**简单** **二分不容易想到**
- 题目描述
一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。

- 示例:
输入: [0,1,3]               输出: 2
输入: [0,1,2,3,4,5,6,7,9]   输出: 8

```c++
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        /* nums.push_back(0);
        int ans = 0;
        for(int i = 0; i < nums.size(); i++) {
            ans = ans ^ i ^ nums[i];
        }
        return ans; */
        // 有序就要二分 ，异或只是为了炫技
        // 就是为了用“有序”这个条件
        // 对于有序数组, 大小为i的数应当处于下标为i的位置上, 如果不在, 说明在该数字之前发生了错位
        int l = 0, r = nums.size() - 1;
        while(l < r) {
            int mid = (l + r) >> 1;
            if(mid != nums[mid])
                r =  mid;   // 缺少的数就是r或r之前
            else
                l = mid + 1;// 如果mid == nums[mid]说明mid之前的数都是存在的，缺少的数是在mid的后面
        }                   // 二分法结束后，l = r+1 = size()
        // 如果0 ~ n-1都不缺，那就是缺了n
        return l == nums.size() - 1  && l == nums[l] ? l + 1 : l;
    }
};
```


## 199.  剑指48-中等-最长不含重复字符的子字符串
**中等**
- 题目描述
请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        /* 用hash<char, int>来表示窗口window，初始化left=right=0索引
        每次扩展一次就right++，并window[s[right]]++
        若window[s[right]] > 1则缩短窗口，left++
        在缩短时，window[s[left]]--
        缩短完成后，更新长度len = right - left */
        int sz = s.size();
        if(sz == 0) return 0;
        if(sz == 1) return 1;
        int len = 0, l = 0, r = 0;
        unordered_map<char, int> window;
        while(r < sz) {
            char c = s[r];
            r++;
            window[c]++;
            while(window[c] > 1) {
                char toDelete = s[l];
                l++;
                window[toDelete]--;
            }
            if(len < r - l)
                len = r - l;
        }
        return len;
    }
};
```

## 200.  剑指54-简单-二叉搜索树的第k大节点
**中等**
- 题目描述
给定一棵二叉搜索树，请找出其中第k大的节点。
- 示例:
输入: root = [3,1,4,null,2], k = 1
   3
  / \
 1   4
  \
?  2
输出: 4

输入: root = [5,3,6,2,4,null,null,1], k = 3
       5
      / \
     3   6
    / \
   2   4
  /
 1
输出: 4

```c++
class Solution {
public:
    int ans = 0;
    int cnt = 1;
    int kthLargest(TreeNode* root, int k) {
        helper(root, k);
        return ans;
        /* vector<int> vec;
        inorder(root, vec);
        return vec[vec.size()-k]; */
    }
    void helper(TreeNode* root, int k) {
        if(!root)
            return;
        helper(root->right, k);
        if(cnt++ == k) {
            ans = root->val;
            return;
        }/* else
            cnt++; */
        helper(root->left, k);
    }
    void inorder(TreeNode* root, vector<int>& vec) {
        if(!root)
            return;
        inorder(root->left, vec);
        vec.push_back(root->val);
        inorder(root->right, vec);
    }
};
```

## 201.  剑指49-中等-丑数
**中等**
- 题目描述
我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。

- 示例:

输入: n = 10
输出: 12
解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。

```c++
class Solution {
public:
    int nthUglyNumber(int n) {
        if(n < 4)
            return n;
        int idx2 = 0, idx3 = 0, idx5 = 0;
        //初始分别指向三个有序链表第一个元素,这三个有序链表是想象出来的，分别就是ugly数组元素分别乘以2,3,5得到的
        vector<int> ugly(n,0);
        ugly[0] = 1;                //基础丑数为1
        for(int i = 1; i < n; i++) {
            int tmp = min(ugly[idx2]*2, min(ugly[idx3]*3, ugly[idx5]*5));
            //三个链表可能有相同元素，所以只要是最小的，都要移动指针
            if(tmp == ugly[idx2]*2) idx2++;
            if(tmp == ugly[idx3]*3) idx3++;
            if(tmp == ugly[idx5]*5) idx5++;
            ugly[i] = tmp;
        }
        return ugly[n-1];
    }
};
```


## 202.  剑指65-简单-不用加减乘除做加法
**中等**
- 题目描述
写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。

```c++
class Solution {
public:
    int add(int a, int b) {
        if(a == 0)  return b;
        if(b == 0)  return a;
        /*
        a+b = a ^ b + (a & b) << 1
        两数和 = 非进位和 + 进位和
        */
        /* while(b) {
            int sum = a ^ b;
            int carry = (unsigned int)(a & b) << 1; // 负数不允许左移
            a = sum;
            b = carry;
        }
        return a; */
        int sum = a ^ b;
        int carry = (unsigned int)(a & b) << 1;
        return add(sum, carry); //迭代皮一下
    }
};
```

## 203.  剑指59-I-滑动窗口的最大值
**困难** **不是很懂啊**
- 题目描述
给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。
- 示例:

输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3
输出: [3,3,5,5,6,7] 
解释: 
  滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7

```c++
class NewQueue {
private:
    deque<int> dq;
public:
    NewQueue() {}
    void push(int n) {
        while(!dq.empty() && n > dq.back())
            dq.pop_back();
        dq.push_back(n);
    }
    void pop(int n)  {
        if(n == dq.front())
            dq.pop_front();
    }
    int getMax() {
        return dq.front();
    }
};
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        vector<int> ans;    // ans.size() = sz - k + 1
        int sz = nums.size();
        if(sz == 0 || k == 0)
            return ans;
        //version 1 双指针 时间复杂度O(n*(n-k+1))既n*n
        /* for(int i = 0; i < sz - k + 1; i++) {
            int l = i, r = i + k - 1;
            int tmp = nums[l];
            for(int j = l+1; j <= r; j++) {
                tmp = max(tmp, nums[j]);
            }
            ans.push_back(tmp);
        }
        return ans; */
        //version 2 单调队列 O(n)
        NewQueue q;
        for(int i = 0; i < sz; i++) {
            if(i < k-1) {
                q.push(nums[i]);
            }else {
                q.push(nums[i]);
                ans.push_back(q.getMax());
                q.pop(nums[i-k+1]);
            }
        }
        return ans;
        // 下面是大佬的deque，存的是索引
        /* for(int i = 0; i < nums.size(); ++i) {
            while(!deq.empty() && nums[deq.back()] <= nums[i]) 
                deq.pop_back();
            deq.push_back(i);
            if(deq.front() == i - k) deq.pop_front();
            if(i >= k - 1) ans.push_back(nums[deq.front()]);
        } */
    }
};
```


## 204.  剑指66-中等-构建乘积数组
**中等**
- 题目描述
给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中?B[i] 的值是数组 A 中除了下标 i 以外的元素的积, 即?B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。

- 示例:
输入: [1,2,3,4,5]
输出: [120,60,40,30,24]

```c++
class Solution {
public:
    vector<int> constructArr(vector<int>& a) {
        int sz = a.size();
        vector<int> leftProduct(sz, 1);
        vector<int> rightProduct(sz, 1);
        for(int i = 1; i < sz; i++)
            leftProduct[i] = leftProduct[i-1] * a[i-1];
        for(int i = sz-2; i >= 0; i--)
            rightProduct[i] = rightProduct[i+1] * a[i+1];
        for(int i = 0; i < sz; i++)
            rightProduct[i] = rightProduct[i] * leftProduct[i];
        return rightProduct;
    }
};
//https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/solution/liang-tang-bian-li-by-z1m/
//题解无敌
```

## 205.  剑指61-简单-扑克牌中的顺子
**中等**
- 题目描述
从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。

```c++
class Solution {
public:
    bool isStraight(vector<int>& nums) {
        // 第一步：排序
        // 第二步：统计王的个数
        // 第三步：统计需要王的个数
        sort(nums.begin(), nums.end());
        int numOfZero = 0;  // numOfZero = index
        while(nums[numOfZero] == 0) numOfZero++; // 这里的大小数0的个数，也是第一个非0的索引
        int needOfZero = 0;
        for(int i = numOfZero + 1; i < 5; i++) {
            if(nums[i] == nums[i-1]) return false;
            needOfZero += nums[i] - nums[i-1] - 1; 
        } 
        return needOfZero <= numOfZero; // 一定是小于等于噢！
    }
};
```

## 206.  剑指55-II-简单-平衡二叉树
**简单** *AVL-平衡二叉树* *BST-二叉搜索树*
- 题目描述
输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。

```c++
class Solution {
public:
    bool isBalanced(TreeNode* root) {
        return dfs(root) == -1 ? false : true;
    }
    int dfs(TreeNode* root) {
        if(!root)
            return 0;
        int leftH = dfs(root->left);
        int rightH = dfs(root->right);
        if(leftH == -1 || rightH == -1 || abs(leftH - rightH) > 1)
            return -1;
        return max(leftH, rightH) + 1;
    }
};
```

## 207.  剑指63-中等-股票的最大利润
**中等** **dp**
- 题目描述
假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少

- 示例:
输入: [7,1,5,3,6,4]         输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。

输入: [7,6,4,3,1]           输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.empty())
            return 0;
        int dp_i_0 = 0;         // 表示第i天，没有股票，手上的资产
        int dp_i_1 = INT_MIN;   // 表示第i天，拥有股票，手上的资产
        for(int i = 0; i < prices.size(); i++) {
            dp_i_0 = max(dp_i_0, dp_i_1 + prices[i]);   // dp_i_0 = max(不卖则资产不变，卖则获得prices[i]的资产)
            dp_i_1 = max(dp_i_1, -prices[i]);           // dp_i_1 = max(不买则资产不变，买则失去prices[i]的资产)
        }
        return dp_i_0;
    }
};
```


## 208.  剑指64-中等-求1+2+…+n
**中等**
- 题目描述
求 1+2+...+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。

- 示例：
输入: n = 3         输出:?6
输入: n = 9         输出:?45

```c++
class Solution {
public:
    int sumNums(int n) {
        // version 1 : 一种很秀的做法
        /* bool arr[n][n+1];
        return sizeof(arr) >> 1; */
        // version 2 : 递归
        int sum = n; // 递归终止条件，当n=1时，返回的sum=1
        bool stop = n > 0 && (sum += sumNums(n-1)); // 值得注意的是，当前面n>0不满足时，后面就不会判断了，于是后面就“短路”了
        return sum;
    }
};
```


## 209.  剑指68-I-简单-二叉搜索树的最近公共祖先
**中等**
- 题目描述
给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

```c++
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        // 终极思路是：用二分搜索来做，BST的特点是中序遍历是升序，所以root->val在p和q的val之间
        // 如果root->val都大于p和q的val，则到root->left找，否则到root->right找
        /* if(!root || p == root || q == root)
            return root;
        if(p->val > root->val && q->val > root->val)
            return lowestCommonAncestor(root->right, p, q);
        if(p->val < root->val && q->val < root->val)
            return lowestCommonAncestor(root->left, p, q);
        // 剩下的情况是root->val在p和q的val之间，所以root就是最低公共祖先
        return root;
    } */
        // 迭代
        TreeNode* node = root;
        while(node) {
            if(p->val > node->val && q->val > node->val)
                node = node->right;
            else if(p->val < node->val && q->val < node->val)
                node = node->left;
            else   
                return node;
        }
        return nullptr;
    }
};
```



## 210.  剑指68-II-简单-二叉树的最近公共祖先
**中等**
- 题目描述
给定一个`二叉树`, 找到该树中两个指定节点的最近公共祖先。

```c++
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        /**
        注意p,q必然存在树内, 且所有节点的值唯一!!!
        递归思想, 对以root为根的(子)树进行查找p和q, 如果root == null || p || q 直接返回root
        表示对于当前树的查找已经完毕, 否则对左右子树进行查找, 根据左右子树的返回值判断:
        1. 左右子树的返回值都不为null, 由于值唯一左右子树的返回值就是p和q, 此时root为LCA
        2. 如果左右子树返回值只有一个不为null, 说明只有p和q存在与左或右子树中, 最先找到的那个节点为LCA
        3. 左右子树返回值均为null, p和q均不在树中, 返回null
        **/
        if(!root || p == root || q == root)
            return root;
        TreeNode* left = lowestCommonAncestor(root->left, p, q);
        TreeNode* right = lowestCommonAncestor(root->right, p, q);
        if(!left && !right)
            return nullptr;
        if(left && right)
            return root;
        return left ? left : right;
    }
};
```