#第一节
-1. 死循环 for(;;);

#第二节
-1. object = entity 就是东西，it may be visible or invisible, in programming languages object is variable. 对象就是变量

-2. 对象 = 属性 + 服务 ； 内置有属性的数据，外置有对外的功能和接口

-3. 面向过程：按时间顺序； 面向对象：存在什么东西来分析；

-4. class 就是高级的struct，struct只有数据，而class不只有数据还有操作

#第三节
-1. 对象与对象之间的交互是消息，对象的状态不由外力直接改变的，而是让对象自己做不做动作

-2. 所有东西都可以通过总结他们相同的特征来归为一类，类定义了对象长什么样，对象是一个那个类的东西或实例

-3. OOP Characteristics
1)Everything is an object.
2)A program is a bunch of objects telling each other what to do by sending messages.(而不是Howtodo)
3)Each object has its own memory made up of other objects.
4)Every object has a type.(fish is fish, bird is bird.)
5)All objects of a particular type can receive the same messages.(所有可以接收相同消息的对象可以被分为同一类，从个体的同性即对象的接口)

-4. 接口的作用：消息交流和保护作用，就是松耦合

-5. 内部的具体实现需要保护起来

-6. Encapsulation封装
Bundle data and methods dealing with these data together in an object.
Hide the details of the data and the action.
Restrict only access to the publicized methods.

#第四节
-1. 每一个类的定义都建议定义成两个文件：一个头文件.h和一个body文件.ccp
头文件里存放这个类的所具有的函数原型（包括构造函数和析构函数）、还有声明数据成员

-2. 两个连着的冒号叫做域的解析符

#第五节
-1. Definition of a class
Separated .h and .cpp files are used to define one class.
Class declaration and prototypes in that class are in the header file(.h).
All the bodies of these functions are in the source file(.cpp).

-2. the header files
If a function/class is declared in a header file, you must include the header
file everywhere the function/class is used and where the function/class is defined.

-3. the class header files are telling you how to used and what you can use. 

-4. #include
#include is to insert the included file into the .cpp file at where the #include statement is.
#include "xx.h" : first search in the current directory, then the directories declared somewhere.
#include <xx.h> : search in the specified directoires, like "includes" or other 系统目录
#include <xx> : same as #include <xx.h>

-5. Standard header file structure
#ifndef HEADER_FLAG
#define HEADER_FLAG
// type declaration here...
#endif //HEADER_FLAG

-6. Tips for header
One class declaration per header file;
Associated with one source file in the same prefix of file name;
The contents of a header file is surrounded with #ifndef #define #endif

#第六节
-1. Abstract
Abstraction is the ability to ignore details of parts to focus attention on a higher level of a problem.

-2. 在做抽象时尽量在没有或者很少代价的情况下为后来的改进入口做铺路

#第七节
-1. Fields, Parameters, local variables
	All three kinds of variable are able to store a value that is appropriate to their defined type;
	Fields are defined outside constructors and methods;
	Fields are used to store data that persists throughout the life of an object.
As such, they maintain the current state of an object. They have a lifetime that lasts as long as their object lasts;
	Fields have class scope: their accessibility extends throughout the whole class, and so they can be used within any of the 
constructors or methods of the class in which they are defined.

-2. Fields 就是字段，就是类的成员变量

#第八节
-1. this : the hidden parameter
"this" is a hidden parameter for all member functions, with the type of the class;
void Point::print()
->(can be regarded as)
void Point::print(Point *p)

-2. this : pointer to the caller
Inside member functions, you can use this as the pointer to the cariable that calls the function.
"this" is a natural local variable of all class member functions that you can not define, but can use it directly.

#第九节
-1. 构造函数: Guaranteed initialization with the constructor
If a class has a constructor, the compiler automatically calls that constructor at the point an object is created,
before clinet programmers can get their hands on the object;
The name of the constructor is the same as the name of the class.

-2. 构造函数没有返回类型，但可以有参数，并且当被定义一个对象时就会被调用；

-3. 析构函数: The destructor，在这个对象要结束时被调用，不能有参数，而且不能有返回类型
In C++, cleanup is as important as initialization and is therefore guaranteed with the destructor;
The destructor is named after the name of the class with a leading tilde(~). The destructor never has any arguments.

#第十节
-1. 即使是C语言也可以在随意地方定义新变量；

-2. 空间是进了大括号的时间就分配了，但是构造函数是在运行到那一行的时候才会运行；

-3. 没有构造的时候是不能够析构的；

-4. 以下的是一种构造函数，需要一个初始化变量输入a
struct Y { float f; int i; Y(int a) };
Y y1[] = {Y(1), Y(2), Y(3) };	//ok
Y y2[2] = { Y(1) }; // not ok

#第十一节
-1. new与delete
new int; new Stash;// Stash是一个类名称，这里调用构造函数 new int[10]; 
delete p; delete[] p;

-2. Tips for new and delete
> Don't use delete to free memory that new didn't allocate;
> Don't use delete to free the same block of memory twice in succession;
> Use delete [] if used new [] to allocate an array;
> Use delete (no brackets) if used new to allocate a single entity;
> It's safe to apply delete to the null pointer (nothing happens);

#第十二节
-1. 类与结构对比：class defaults to private; struct defaults to public;

#第十三节
-1. Initialization list 与 assignment的区别
> Student::Student(string s):name(s) {} //initialization, before constructor, 初始化，推荐都用这个
> Student::Student(string s) { name = s;} //assignment, 赋值 = 初始化 + 赋值

#第十四节
-1. 组合：construct new object with existing objects, it is the relationship of "has-a"

#第十五节
-1. 
































