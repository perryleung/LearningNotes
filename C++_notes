1、单个字符可以用‘’也可以用“”，字符串必须用“”，因此推荐都用“”

2、转义转行字符“\n”或‘\n’

3、算术运算时最好的方法是保持两个数据的类型一致

4、如果一个浮点数据赋予整型变量，那么小数点后面的数据将会被舍弃

5、如果一个浮点类型变量小数点后值为0，也需要用0补齐，否则将会被视为整型

6、Huffman树中大节点在右孩子

7、利用new为数组申请必须在最后用delete释放，当我们用new[]分配的对象是基本数据类型时，用delete和delete[]没有区别。但是，当分配的对象是自定义对象时，二者不能通用。一般来说使用new分配的对象，用delete来释放。用new[]分配的内存用delete[]来逐个释放。delete释放new分配的单个对象指针指向的内存。delete[]释放new分配的对象数组指针指向的内存。

8、技巧：
int a; cin>>a; int num[a](错的)；
正确使用方法有：int *num = new int[a];结束：delete[] num;
最后被定义了如a大小的数量的指针，用的时候可以当数组用，num[0]

9、#define 定义的常量语句不能加分号。密码常量一般用到string数据类型就要引入头文件string.h，#define定义string类型时要加双引号

10、求变量的字节大小函数sizeof()

11、break是跳出最近的循环

12、bool 变量两个值 true\false

13、在使用switch时，若case语句有return则不需要break

14、cout<<true输出值是1

15、define定义和const定义一样初始化后不能再赋值

16、C++的API函数中pow(a,b)可以计算a的b次方，要在math.h中

17、string str;读取字符串之中的某一位用数组读取方式，而字符串的长度可以用string的成员函数length()获取，如str.length()；括号是必不可少的

18、在头文件ctime.h中返回时间time(0)，其值指的是距离UNIX系统时间纪元1970年1月1日0点为止，
计算秒：seconds = time(0);
计算分钟：m = (seconds % 3600) / 60;
计算小时：h = (seconds % (3600 * 24)) / 3600 + 8;
用24小时制：h %= 24;

19、在cstdlib.h头文件中，有srand()和rand()产生随机数，后者是自动有种种子的，结合前者可以去除种子：
srand((int)time(0));
每次返回1~6的整数：result = 1+(int)(6.0*rand()/(RAND_MAX+1.0)) 

20、数组间复制数据需要它们的变量类型相同

21、使用二分法查找目标元素的时间比较短，但是它的适用前提是数组数据已经被排序，二分法的思想是：对于给>定值的查找，如果大于该数组的中间元素，下一步在元素值大的区域继续与其中间元素比较，否则下一步在元素值>小的区域内继续查找，直到找到目标元素，如果到最后还是没有找到则输出“数组中不存在该元素”

22、所谓四舍法是去掉小数点后面的位数

23、一个数组的字节数是其类型字节数的整数倍，获取数组的大小范围可以用如下：
数组的大小 = 数组所占字节数 / 数组类型所占字节数
int array_[num] = {......};
num = sizeof(array_) / sizeof(int);

24、如果一个工程逻辑问题复杂就必须考虑画程序流程图

25、使用结构体时要注意处理内存问题

26、定义字符数组 char student[5][10]; 此处行表示第几个同学，列表示姓名的长度(均不超过9个字符)

27、一个汉字是占用两个字节

28、对于字符数组 char xx[num];的赋值可以使用 strcpy函数

29、C++中处理字符串的方式有两种，一种是字符数组一种是字符串类string，两者有区别，而使用string类做字符串操作时必须包含头文件string.h

30、字符数组被声明后必须进行初始化，char ch[3] = {'a','b','c'}; 显式定义字符数组的大小时，可以不写数组的元素个数，书写格式为char ch[];此时后面赋值的元素有几个，该字符数组的大小就有多少

31、用for循环访问修改一段字符串时，其所能容纳的长度是在其被初始化时已经被固定了，因为for循环的范围是str.length()

32、在计算机中字符"\0"是截断标志符，在其之后的内容被看作是冗余的，字符串和字符数组同样适用

33、当定义了字符变量后使用cin来为其赋值多个字符值时，只能被赋值第一个输入的字符值，剩下的多余的字符值(常常被称为垃圾)被存入内存缓冲区，此时可以使用getchar()函数来吸收缓冲区的多余字符，getchar()函数返回的是一个整型数值，对应的是从缓冲区中读入的ASC||码值，可以通过char(getchar())来转换成字符，每次只会读取一个，按回车读取，按其他键是输入，如果缓存区的所有字符值都被读取完，则返回空白

34、在使用字符串赋值时可以使用以下三种方式：cin>> 、getline()、赋值运算符=，getline(a,b,c)有三个参数，第一个参数是指进行读入操作的输入流，可以是cin、ifstream等，第二个参数b是赋值对象，必须是string类型的字符串，是输出型参数，指输入的字符串存储于其中，第三个参数是终结标志符，是一个字符类型char，即在字符串输入的过程中，一旦遇到该字符就终止了字符串的输入，如下
string str; getline(cin,str,'$');
值得注意的是由第二个参数可知，getline()函数只能用作与string类型的字符串，不可以使用字符数组

35、strcpy(str1,str2)是C语音标准库函数，作用是将str2地址上的内容(地址开头直到遇到结束符)赋值到str1地址上，该函数的适用对象是字符数组


36、适用于字符数组，strlen(a)，参数a是字符数组头地址，返回数组长度，技巧是可以用于一开始没有固定长度的数组

37、一般用于字符数组，C风格，字符串比较函数strcmp(str1,str2)，返回的是整型数值，等于0则str1=str2；大于0则str1>str2；小于0则str1<str2；即使两个字符串的大小及内容相同，但是有大小写区分，结果也是不相同的，并且大写字母小于小写字母

38、字符串函数strcat(str1,str2)；将str2的内容连接到str1，因为str1是目标字符串，所以要求它的大小必须大于它自身，并且要足够大到可以容纳到连接字符串str2

39、字符串&字符数组函数strupr(a)，将内容的所以小写字母改为大写，输入的参数是首地址

40、比较两个string字符串，两种方式，第一种方式是!= 、>= 、<=，第二种方式是用string类的成员函数compare()，C
++字符串中的内容区分大小写，大写字母不等于其小写字母，如下
if(str!=str2)
if(bool(compare_result=str3.compare(str1)))

41、查找string的某个元素，string类中有很多个成员函数，如下，还有很多未列举
(1)find(a,b)，从b位置开始从前往后查找字符a在当前字符串中的位置
(2)find_first_not_of(a,b)，从b位置开始从前往后查找字符a在当前字符串中第一个不匹配的位置
(3)find_first_of(a,b)，从b位置开始从前往后查找字符a在当前字符串中第一次出现的位置
(4)find_last_not_of(a,b)，从b位置开始从后往前查找字符a在当前字符串中第一个不匹配的位置
(5)find_last_of(a,b)，从b位置开始从后往前查找字符a在当前字符串中第一次出现的位置
(6)rfind(a,b)，从b位置开始从后往前查找字符a在当前字符串中的位置
string str = "asdf"; char ch = "sd"; str.rfind(ch);

42、使用成员函数检测string字符串是否非空，可以利用成员函数empty()实现，如果为空，返回布尔值true，反正返回false，string 变量名.empty()

43、获取string字符串的长度，C风格字符串利用函数strlen()获取长度，相应的string字符串运用成员函数length()获取其长度，格式如下：长度变量 = 字符串.length()

44、提取string字符串的子串，格式：子串变量=原字符串.substr(起始位置,子串长度)；

45、定义空字符串：string str = "";

46、C风格字符串相加可以利用strcat()来实现，在string字符串中可以利用运算符(+)来实现：
str1 = str2 + str3 ;
还可以利用成员函数append();即str1.append(ch)，可以连接字符数组也可连接字符串

47、string字符串与单字符相加，直接用 (+)

48、string成员函数replace(a,b,str)函数可以替换其中的字符，第一个参数是起始位置，第二个参数是替换的长度，第三个是要替上的字符串的首地址，格式：
string str1 = "Hello World";
string str2 = "C++";
str1.replace(6,5,str2);

49、数组指针本质是指针，而指针数组本质是数组，指针数组和数组指针的区别在于，指针数组的每个元素都是指针，而数组指针只有整个数组为指针
类型标识符 (*变量名)[个数]; //数组指针
类型标识符 *变量名[个数]; //指针数组			

50、用指针去修改const常量的值是行不通的

51、当用指针指向某一段内存时，事先并不知道需要申请多少，此时动态申请内存就显得很必要。C++有多个动态申请内存的方式，主要两种：
(1)malloc方式，这种动态申请内存方式需要包含头文件malloc.h
申请一维内存格式：
类型标志符 *变量名;
变量名 = (类型标志符*)malloc(sizeof(类型标志符)*数组大小);
释放内存格式：
free(变量名); 变量名 = NULL;
申请二维内存格式：
类型标志符 **变量名;
变量名 = (类型标志符**)malloc(sizeof(类型标志符*)*数组行大小);
for(int i=0;i<数组行大小;i++)
	变量名[i] = (类型标志符*)malloc(sizeof(类型标志符)*数组列大小);
释放内存格式：
free(变量名); 变量名 = NULL;
(2)new方式
申请一维内存格式：
类型标志符 *变量名;
变量名 = new 类型标志符[数组大小];
释放内存格式：
delete[] 变量名; 变量名 = NULL;
申请二维内存格式：
类型标志符 **变量名;
变量名 = new 类型标志符*[数组行大小];
for(int i=0;i<数组行大小;i++)
	变量名[i] = new 类型标志符[数组列大小];
释放内存格式：
delete[] 变量名; 变量名 = NULL;

52、指针有一个变量类型是void*，它可以指向任意类型的数据，即任意类型的指针都可以赋值给void*，但void*不可以赋值给其他类型的指针，除非采用强制类型转换。看074.cpp

53、在指针应用场合，&是取地址运算符，*是取该地址指向内存的内容，->是由指针直接取内存内容(一般用于指向结构体的指针：结构体指针变量->结构体成员变量)，就相当于(*指针名).成员变量

54、每种变量类型占用不同的字节大小，可以用一个字节的char类型来输出其他大于一个字节的变量按字节输出其内容，
int a = 12345;
for(int i=0;i<sizeof(int);i++)
	cout<<((char*)&a)[i]<<endl;

55、当用new和malloc函数动态申请内存时，最后需要释放指针和内存，但是在释放指针前必须先判断当前指针是否指向内存的首地址，如果没有则会导致程序崩溃，当指向内存块的指针已经超出其边界一定要将指针指回首地址，看077.cpp

56、以下三种情况会造成野指针：指针创建后没有初始化(解决方法是初始化为NULL或者指向合法的内存)；指针在使用free()和delete[]函数释放指向的内存时没有释放指针(在释放内存后也将将指针设为NULL)；指针的创建和操作不在同一个作用域中

57、函数的形参传值：void FUNCTION_NAME(int a,int b);传地址：void FUNCTION_NAME(int *a,int *b);

58、函数重载：如果两个函数名字相同，但是因为参数的类型不同，系统也会根据不同的要求调用不同的函数体

59、格式打印输出，主要依靠iomanip头文件，看087.cpp，整型可以按其他进制输出，浮点型可以用科学计数法、精度设置等等，字符串可以按照对齐输出

60、如果赋值的字符串大小小于字符数组的长度时会有0内存，造成内存的浪费，此时需要将0内存去掉，092.cpp

61、像这种 int* FUNCTION_NAME(xxx)，返回的是数组的首地址，意味着可以返回很多个值

62、如果要换行可以用'\'，即
string str[5] = {"asd","qer",\
		"xcv",\
		"ghj","wetr"};

63、第01行包含的头文件cctype.h用于函数isalpha()的使用，可以判断该元素是否为字母

64、 函数重载体现在多个函数名字必须相同，但是参数列表的内容不同，可以是数量或者参数类型不同，但是，如果在函数重载合法的情况下，数量的不同但多出的不同有默认值将会产生二义性，系统报错，函数重载的二义性发生在当参数类型相同、个数不一样时，由于参数默认值造成它们的参数实质一样

65、main()是所有程序的入口函数，但是在main()函数结束后还能再执行代码，此时需要在main()中注册函数，在main()的最后一行代码被执行完后，还能执行新的代码，先被注册的函数后执行。_onexit()可以注册函数，返回类型可以是int类型，如下
void add(){} 
void substract(){}
void main()
{ atexit(add);		//第三执行
  atexit(substract);	//第二执行
  cout<<"main"<<endl;	//第一执行
 }

66、递归函数是一直返回，直到不在调用自身即终止

67、随机生成小写字母：
lower_index = 1 + (int)(26.0 * rand() / (RAND_MAX + 1.0));
lower = char(lower_index + 96);
随机生成大写字母：
upper_index = 1 + (int)(26.0 * rand() / (RAND_MAX + 1.0));
upper = char(upper_index + 64);
生成随机数(0-9)：
num = 0 + (int)(9.0 * rand() / (RAND_MAX + 0.0));

68、main函数可以接收参数解释DOS命令，是在启动运行时传递参数的，格式分两种如下：
int main(int argc, char** argv);
int main(int argc, char* argv[]);

69、在一种循环事件内，若想自操作退出可以用bool类型来定义一个flag变量

70、不成文规定：类名字大写，类的定义必须在大括号后加分号，类只有在声明类对象才能被使用，类函数相关程序由110开始，编写类的时候有个技巧就是先定义private里面的参数

71、类的构造函数是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值，<1>作用：赋初值,初始化对象的数据成员,由编译器帮我们调用。<2>特点：①函数名和类名一样。②没有返回值。③支持有参/无参。④可以重载。 <3>调用时机：在类的对象创建时刻,编译器帮我们调用构造函数。

72、析构函数是当对象被销毁时被系统调用的方法，一般用来清空内存。<1>作用：用于释放资源。<2>特点：①和类名一样,不过得在前面加上~。②无参数,无返回值。③因为无参数,无返回值,所以不可以重载。④尽量不要自己调用析构函数,但是在某些需要的时候再调用。<3>调用时机：快退出函数的时候,编译器帮我们调用。

73、根据类中的定义的构造函数，可以声明类对象，并在声明对象时输入需要的参数，其带参数的构造函数输入参数赋值给类的私有成员变量

74、system("pause");暂停按下

75、如果不将运算符重载函数定义为类的友元函数，将不能访问其私有变量，友元函数是C++中的一种机制，它不属于类的成员函数，但是可以访问到类的私有变量，因此，它在一定程度上破坏了封装的特性。在一个类中用friend关键字修饰另一个类的声明，那么该类就是这个类的友元类。另外一个类可以访问本类的私有属性。

76、算符重载分为全局函数运算符重载和成员函数运算符重载。共分为三步：用operator关键字修饰要重载的运算符；确定返回值是对象、引用或是地址；全局运算符重载不含this指针这个参数，成员函数运算符重载含参，成员函数进行运算符重载的时候，如果是左操作数，只需要用this指针加以控制就可以了，友元函数对运算符重载的常见应用场景就是对<<和>>这样的运算符，因为cin对象和cout对象并没有暴露给你，所以只能采取友元这样的方式来实现想要的功能

77、运算符重载的意思是可以将对应的运算符号定义新的功能，看111.cpp

78、类的一个特征就是封装，public和private作用就是实现这一目的。所以：用户代码（类外）可以访问public成员而不能访问private成员；private成员只能由类成员（类内）和友元访问。类的另一个特征就是继承，protected的作用就是实现这一目的。所以：protected成员可以被派生类对象访问，不能被用户代码（类外）访问。有public，protected，private三种继承方式，它们相应地改变了基类成员的访问属性。
1.public继承：基类public成员，protected成员，private成员的访问属性在派生类中分别变成：public, protected, private
2.protected继承：基类public成员，protected成员，private成员的访问属性在派生类中分别变成：protected, protected, private
3.private继承：基类public成员，protected成员，private成员的访问属性在派生类中分别变成：private, private, private
但无论哪种继承方式，上面两点都没有改变：private成员只能被本类成员（类内）和友元访问，不能被派生类访问，protected成员可以被派生类访问。

79、类继承的实现可以节省很多代码量

80、类的多态性体现在当响应同一条消息时，结果却不一样，也即结果呈现多样性，类多态的应用存在于基类的指针指向子类的对象。

81、虚函数就是类的成员函数前面加上virtual关键字的函数。虚函数的作用就是为了实现多态性（Polymorphism），多态性是将接口与实现进行分离；用形象的语言来解释就是实现以共同的方法，但因个体差异而采用不同的策略。使用了virtual程序将根据引用或指针指向的类型来选择方法，如果没有使用virtual程序将根据指针类型或引用类型来选择方法。1.构造函数不能使虚函数。创建派生类对象时，将调用派生类的构造函数，而不是基类的构造函数，然后派生类的构造函数将调用基类的一个构造函数，这种顺序不同于继承机制。因此派生类不继承基类的构造函数，所以将类的构造函数声明为虚函数没有什么意义。2.友元函数不能是虚函数。友元函数不是类成员，而只有成员才能是虚函数。115.cpp和114.cpp构造虚函数的方式不同，115构造的是纯虚函数，而114构造的是虚成员函数。

82、基类属于抽象类时不能实例化，只能定义其指针和引用，实例化子类对象后对子类对象取址，然后调用基类的纯虚函数，响应不同的指令

83、当多继承出现二义性问题时，二义性现象可以通过虚继承避免，但在现实编程中很少用到多继承

84、双冒号(::)的用法，表示 “域操作符”，例如：声明了一个类A，在类A中声明一个成员函数void foo()，但没有在类A的声明中给出函数foo的定义，那么在类外定义foo时，就要写成void A::foo()表示foo()函数是类A的成员函数。表示引用成员函数和变量，作用域成员运算符，例如：System::Math::Sqrt()相当于System.Math.Sqrt()

85、判断三个坐标两条线段之间是否垂直可以用向量点乘法

86、在类中，全局变量的使用具有局限性，此时可以定义为静态数据成员实现多个对象间的数据共享，而类的静态变量初始化时需要在类外(即全局)，所谓共享，就是在同类的两个对象之间的静态变量共享内存，当某对象的静态变量发送改变，那么其他对象的相同静态变量也会受影响而改变

87、atoi函数是将字符串转化为整数

88、在类内部被声明又被定义的函数称为内联函数，它的应用是解决函数调用的效率问题，一般的调用函数，在进入被调用函数的地址前，先保护现场再转入函数地址，待被调用函数执行完后，转回先前的地址，恢复现场继续执行。而内联函数的使用是将该函数体直接放到当前执行地址，因此提高了效率。内联函数如果很小则可以提高效率。小功能的开销是因为小功能的执行时间小于切换时间。

89、内联函数具有以下优点：1）不会发生函数调用开销。2）当调用函数时，它还节省了推送/弹出变量在堆栈上的开销。3）它还节省了函数返回调用的开销。4）内联函数时，可以使编译器对函数体执行特定于上下文的优化。对于正常的函数调用，这种优化是不可能的。 通过考虑调用上下文和被调用上下文的流程，可以获得其他优化。5）对于嵌入式系统，内联函数可能很有用（如果它很小），因为内联可以产生比函数调用前导码和返回更少的代码。
内联功能缺点：1）来自内联函数的添加变量消耗额外的寄存器，如果要使用寄存器的变量数增加，则在内联函数之后，它们可能会在寄存器变量资源利用率上产生开销。这意味着当在函数调用点替换内联函数体时，函数使用的变量总数也会被插入。因此，用于变量的寄存器数量也将增加。因此，如果在函数内联变量数量大幅增加之后，它肯定会导致寄存器利用率的开销。2）如果使用太多的内联函数，那么二进制可执行文件的大小将会很大，因为相同代码的重复。3）太多的内联也会降低指令缓存命中率，从而降低从缓存内存到主内存的指令获取速度。4）如果有人更改了内联函数中的代码，则内联函数可能会增加编译时间开销，因此必须重新编译所有调用位置，因为编译器需要再次替换所有代码以反映更改，否则它将继续使用旧功能。5）内联函数可能对许多嵌入式系统没用。因为在嵌入式系统中，代码大小比速度更重要。6）内联函数可能会导致颠簸，因为内联可能会增加二进制可执行文件的大小。内存中的颠簸会导致计算机性能下降。

90、内联函数的行数不能太多，1-5行为宜，否则会有反效果

91、构造函数可以是两个：默认和带参数的
Line();			//默认构造函数
Line(int a=0,int b=0); 	//带参数的构造函数

92、每个类对象在实例化时都有一个this指针指向其数据的首地址，当类的非静态成员函数在访问非静态成员变量时，若遇到行参变量和成员变量相同，可以用this指针指向成员变量以示区别，当类中的非静态函数对与成员变量同名的变量进行操作时，切记用this指针标明该类的成员变量

93、复制构造函数从一个类对象复制到另一个对象

94、在先声明的时候用const为函数，它的意义在于不改变成员变量的值

95、在cstdlib或stdlib.h库中包含一个rand()函数，不接受任何参数而返回一个随机整数

96、4种访问名称空间std的方法：
1)using namespace std;在函数定义之前
2)using namespace std;在函数定义之中
3)using std::cout;放在特定的函数定义中
4)std::cout<<"xxx"直接使用

97、归根结底short是short int简称、long是long int的简称

98. 头文件climits定义了符号常量来表示类型的限制，例如int的最大值最小值等

99. #define是C语言常用的，const是C++常用的

100. 另外一种初始化的方法是Ｃ＋＋独有的： 
int a(321); 	// a = 321
也有：
int a{321};	// a = {321}
上述如果大括号为空则初始化为０

101、如果能对变量初始化就尽量初始化变量，将变量声明和赋值分开可能带来瞬间悬而未决的问题

102. short最大32767，unsigned short最大65535

103、int是计算机中最“自然”的语言，一般的整型就用它

104. 不同进制的书写均在计算机中被存储为二进制
int a = 42;	//十进制
int b = 042;	//八进制
int c = 0x42;	//十六进制
输出相应的进制：
cout<<a<<endl;
cout<<oct;
cout<<b<<endl;
cout<<hex<<c<<endl;

105. 如果程序中忽然出现一个未声明的数字，除非数值太大或有后缀说明，否则将被定义为ｉｎｔ

106. char类型打印字符：
cout.put(ch);
cout.put('!');
cout<<"!";
打印ASCII码：
cout<<'!';

107. 对于常规字符如字母标点符号数字等，最简单的方法就是将字符用单引号括起来,特殊符号需要转义

108.对于char类型可以是有符号也可以是无符号的,必要时可以显式表示
char x;
unsigned char x;	//0-225
signed char x;		//-128~127

109. 新增的类型
char16_t无符号长16bit
char32_t无符号长32bit

110.在布尔类型中,非零既为true,零为false,而布尔类型转换为int:true为1,false为0

111.创建常变量尽量进行初始化否则将出现很大问题,有以下几种通用约定:1)常变量首字母大写;2)常变量大写;3)常变量名字前加个k

112.对于除法若操作数有其中一个是浮点数,那么其运算结果也是浮点数

113.cout自动去除数字后面的零,为了不去掉可用以下方法:
cout.setf(ios_base::fixed, ios_base::floatfield)

114.数组之间不能相互赋值

115.控制计算位置数组元素个数可以用以下方法
int things[] = {1,2,3,4,6};
int num_elements = sizeof(things) / sizeof(int);

116.字符串结尾是'\0'，其ASCII码是0，用cout打印字符串时要注意其末尾是否加有'\0'，这是一种非常不实用的方法，因此用下：
char bird[11] = "Mr.A";		//这被称为字符串常量
这样初始化就隐式地包括了字符串结尾地空字符，要保证数组足够大包括起来
char的数组初始化也可以不用确定多少个字符
char first_data[] = {"bei hu"};	//等号可以省略

117.字符常量（单引号）可以当作是ASCII码的另一种形式，下面是将83赋给shirt_size：
char shirt_size = 'S';

118.用于检测字符数组的长度可以用如下：
#include <cstring>
const int size = 15;
char a[size] = "c++sdf";
cout<<strlen(a);
strlen()只是计算可见的字符

119.若想读取字符数组前面几个字符，可以在中间插入或改写'\0'，在用cout读取即可：
a[3] = '\0';
cout << a;   // c++

120.cin对输入的只能识别到空格前

121. 若输入有空格符的字符串，如New York，用getline()或get(),这两个是字符数组用的
这里是需要采用面向行而不是面向单词的方法，istream中的类（cin）提供了如此方法，这两个函数都是读取一行，直到有换行符
getline()丢弃换行符，get()保留换行符
推荐多用get(),因为老式的实现没有getline(),而且get()更容易检查出错误

121. getline()两个参数,第一个是用来存储输入行的数组的名称,第二个参数读取字符数,必须预留一个字符
cin.getline(name,20)
另外:
cin.getline(name1,20).getline(name2,20);其效果与两次调用cin.getline()一样

122. get()将换行符都保留在输入队列中,因此若有两个get(),第二个将首读到换行符,因此要:
cin.get(name,20);
cin.get();
cin.get(age,20);
或者:
cin.get(name,20).get();

123. 用cin>>直接输入也会将换行符保留在输入队列中,因此若后续要继续使用get或getline,必须要使用一个过度的get(),如:
( cin >> year ).get();
getline(name, 20);

124. 使用字符数组还有其他的技术方法,例如复制和拼接,但是要用以下c类型的头文件
#include <cstring>
strcpy(charr1,charr2); //copy charr2 to charr1
strcat(charr1,charr2); //charr2结尾charr1 
int len_of_charr = strlen(charr1); //obtain length

125. string类提供了将字符串作为一种数据类型的表示方法,要
#include <string>
using namespace std;
using是一条编译指令,string类定义隐藏了字符串的数组性质,如下:
string str1 = liang;
cout << "The third letter in " << str1 << " is " << str1[2];

126. string对象更方便更安全,可以将char数组视为一组用于存储一个字符串的char存储单元,而string类变量是一个表示字符串的实体

127. 特别方便的是string对象可以使用 + 和 += 来进行合并,而且string对象之间可以直接赋值,不必像字符数组那般特别技术,查看长度:
int len_of_str = str.size()

128. string类具有自动调整大小的功能,从而避免了字符数组容易出现的内存溢出的问题

129. string类的面向行的读取与字符数组的不一样,如下:
cin.getline(charr,20);
getline(cin,strr);

130. 定义完结构体后,声明结构变量时C++是可以省略关键字struct的,直接用结构体名称声明结构变量,而结构变量的初始化也可以用一次大括号完成

131. 可以使用赋值符号=将结构赋值给另一个同类型的结构,可以创建结构体数组

132. 共同体(union)能存储不同的数据格式,但只能同时存储其中一种,结构体是可以同时存储int\long\和double,而共同体只能存储int或long或double,共同体的长度为其最大成员的长度

133. 共同体的用途是节省内存,另外还有匿名共同体,其成员都是位于相同地址的变量,可以以下用处:
struct widget
{
	char brand[20];
	int type;
	union id
	{
		long id_num;
		char id_char[20];
	}id_val;
};
...
widget prize;
...
if(prize.type == 1)
	cin >> prize.id_val.id_num;
else
	cin >> prize.id_val.id_char;
########以下匿名共同体,id_num和id_char相同地址,被视为prize的两个成员而不需要中间标识符id_val
struct widget
{
	char brand[20];
	int type;
	union
	{
		long id_num;
		char id_char[20];
	};
};
...
widget prize;
...
if(prize.type == 1)
	cin >> prize.id_num;
else
	cin >> prize.id_char;

134. enum枚举创建了符号常量,如下:
enum spectrum {red, orange, yellow, green, blue, violet, indigo, ultraviolet}; //对应的整数值 0-7
spectrum band;
band = blue;	//枚举量只有等号赋值,而且赋值的内容被规定
或:
enum {red, orange, yellow, green, blue, violet, indigo, ultraviolet};
这情况是只打算使用常量,而不创建枚举类型的变量

135. 枚举的取值范围 C++ primer plus 4.6.2

136. 指针是一个变量,这个指针变量是存储变量的地址的,用取址符号可以(&)赋值,(*)是间接值或解除引用运算符,用于指针可以得到该地址处存储的值

137. 编译阶段决策\运行阶段决策

138. 可以在声明语句中初始化指针,被初始化的是指针,而不是它指向的值
int higgens = 5;
int * pt = &higgens;

139. C++创建指针时只会分配用来存储地址的内存,而不会分配用来存储指针所指向的数据的内存,为数据提供空间是一个独立的步骤
long * fellow;
*fellow = 2233;
这情况会很危险,2233将被存在地址2233上,一定要在对指针应用解除引用运算符(*)之前,将指针初始化为一个确定的适当的地址,这是关于指针使用的金科玉律

140. 指针描述的是位置,通常是整数,不能对指针进行操作,要将数字值作为地址来使用,应通过强制类型转换数字转换为适当的地址类型

141.在运行阶段为一个int值分配未命名的内存,并使用指针来访问这个值
1)关键字new
需要告诉new为哪种数据类型分配内存,new将找到一个长度合适的内存块并返回该内存块的地址,如
int *pn = new int;		//allocate memory with new
. . . 					//use the memory
delete pn;				//free memory with delete when done
备注:
delete只能用对应的new分配的指针内存
2)将变量的地址赋给指针
int higgens;
int *pt = &higgens;
在第二种情况下可以通过变量名称访问该int值,而第一种情况只能通过该指针进行访问
备注:
pn指向的内存没有名称,被称为数据对象,数据对象指的是为数据项分配的内存块,数据对象使程序在管理内存方面有更大的控制权
typeName * pointer_name = new typeName;
用来指定需要什么样的内存和用来声明合适的指针

142. 静态连编\动态连编,前者是编译时决策,后者是运行时决策,适用于大型数据:数组\字符串\结构

143. 创建动态数组要将数组的元素类型和元素数目告诉new,如下:
type_name * pointer_name = new type_name [num_elements];
int * psome = new int [10];
//new运算符返回地一个元素的地址
delete [] psome;
//	数组的元素读取:psome[0] \ psome[1] \ psome[2] \ ... \ psome[9]
//	psome指的是指向第一个元素的指针
//	psome = psome + 1; 指的是指针变量加一,将指向下一个元素的地址,即现在psome[0]的值是原来psome[1]的值,psome[1]是原来psome[2]
备注:
由上述可知将指针变量加一后,增加的量等于它指向的类型的字节数

144. 在数组和指针的应用中有一些技巧:
arrayname[i] becomes *(arrayname+i);		//valid
pointername[i] becomes *(pointername+i);	//valid
pointername = pointername + 1;			//valid
arrayname = arrayname + 1;			//not allowed

145. sizeof运算符对数组得到的是数组的长度:例如double的字节*数组元素个数,而对指针得到的是指针的长度:例如






































