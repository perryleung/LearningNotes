1、单个字符可以用‘’也可以用“”，字符串必须用“”，因此推荐都用“”

2、转义转行字符“\n”或‘\n’

3、算术运算时最好的方法是保持两个数据的类型一致

4、如果一个浮点数据赋予整型变量，那么小数点后面的数据将会被舍弃

5、如果一个浮点类型变量小数点后值为0，也需要用0补齐，否则将会被视为整型

6、Huffman树中大节点在右孩子

7、利用new为数组申请必须在最后用delete释放，当我们用new[]分配的对象是基本数据类型时，用delete和delete[]没有区别。但是，当分配的对象是自定义对象时，二者不能通用。一般来说使用new分配的对象，用delete来释放。用new[]分配的内存用delete[]来逐个释放。delete释放new分配的单个对象指针指向的内存。delete[]释放new分配的对象数组指针指向的内存。

8、技巧：
int a; cin>>a; int num[a](错的)；
正确使用方法有：int *num = new int[a];结束：delete[] num;
最后被定义了如a大小的数量的指针，用的时候可以当数组用，num[0]

9、#define 定义的常量语句不能加分号。密码常量一般用到string数据类型就要引入头文件string.h，#define定义string类型时要加双引号

10、求变量的字节大小函数sizeof()

11、break是跳出最近的循环

12、bool 变量两个值 true\false

13、在使用switch时，若case语句有return则不需要break

14、cout<<true输出值是1

15、define定义和const定义一样初始化后不能再赋值

16、C++的API函数中pow(a,b)可以计算a的b次方，要在math.h中

17、string str;读取字符串之中的某一位用数组读取方式，而字符串的长度可以用string的成员函数length()获取，如str.length()；括号是必不可少的

18、在头文件ctime.h中返回时间time(0)，其值指的是距离UNIX系统时间纪元1970年1月1日0点为止，
计算秒：seconds = time(0);
计算分钟：m = (seconds % 3600) / 60;
计算小时：h = (seconds % (3600 * 24)) / 3600 + 8;
用24小时制：h %= 24;

19、在cstdlib.h头文件中，有srand()和rand()产生随机数，后者是自动有种种子的，结合前者可以去除种子：
srand((int)time(0));
每次返回1~6的整数：result = 1+(int)(6.0*rand()/(RAND_MAX+1.0)) 

20、数组间复制数据需要它们的变量类型相同

21、使用二分法查找目标元素的时间比较短，但是它的适用前提是数组数据已经被排序，二分法的思想是：对于给>定值的查找，如果大于该数组的中间元素，下一步在元素值大的区域继续与其中间元素比较，否则下一步在元素值>小的区域内继续查找，直到找到目标元素，如果到最后还是没有找到则输出“数组中不存在该元素”

22、所谓四舍法是去掉小数点后面的位数

23、一个数组的字节数是其类型字节数的整数倍，获取数组的大小范围可以用如下：
数组的大小 = 数组所占字节数 / 数组类型所占字节数
int array_[num] = {......};
num = sizeof(array_) / sizeof(int);

24、如果一个工程逻辑问题复杂就必须考虑画程序流程图

25、使用结构体时要注意处理内存问题

26、定义字符数组 char student[5][10]; 此处行表示第几个同学，列表示姓名的长度(均不超过9个字符)

27、一个汉字是占用两个字节

28、对于字符数组 char xx[num];的赋值可以使用 strcpy函数

29、C++中处理字符串的方式有两种，一种是字符数组一种是字符串类string，两者有区别，而使用string类做字符串操作时必须包含头文件string.h

30、字符数组被声明后必须进行初始化，char ch[3] = {'a','b','c'}; 显式定义字符数组的大小时，可以不写数组的元素个数，书写格式为char ch[];此时后面赋值的元素有几个，该字符数组的大小就有多少

31、用for循环访问修改一段字符串时，其所能容纳的长度是在其被初始化时已经被固定了，因为for循环的范围是str.length()

32、在计算机中字符"\0"是截断标志符，在其之后的内容被看作是冗余的，字符串和字符数组同样适用

33、当定义了字符变量后使用cin来为其赋值多个字符值时，只能被赋值第一个输入的字符值，剩下的多余的字符值(常常被称为垃圾)被存入内存缓冲区，此时可以使用getchar()函数来吸收缓冲区的多余字符，getchar()函数返回的是一个整型数值，对应的是从缓冲区中读入的ASC||码值，可以通过char(getchar())来转换成字符，每次只会读取一个，按回车读取，按其他键是输入，如果缓存区的所有字符值都被读取完，则返回空白

34、在使用字符串赋值时可以使用以下三种方式：cin>> 、getline()、赋值运算符=，getline(a,b,c)有三个参数，第一个参数是指进行读入操作的输入流，可以是cin、ifstream等，第二个参数b是赋值对象，必须是string类型的字符串，是输出型参数，指输入的字符串存储于其中，第三个参数是终结标志符，是一个字符类型char，即在字符串输入的过程中，一旦遇到该字符就终止了字符串的输入，如下
string str; getline(cin,str,'$');
值得注意的是由第二个参数可知，getline()函数只能用作与string类型的字符串，不可以使用字符数组

35、strcpy(str1,str2)是C语音标准库函数，作用是将str2地址上的内容(地址开头直到遇到结束符)赋值到str1地址上，该函数的适用对象是字符数组


36、适用于字符数组，strlen(a)，参数a是字符数组头地址，返回数组长度，技巧是可以用于一开始没有固定长度的数组

37、一般用于字符数组，C风格，字符串比较函数strcmp(str1,str2)，返回的是整型数值，等于0则str1=str2；大于0则str1>str2；小于0则str1<str2；即使两个字符串的大小及内容相同，但是有大小写区分，结果也是不相同的，并且大写字母小于小写字母

38、字符串函数strcat(str1,str2)；将str2的内容连接到str1，因为str1是目标字符串，所以要求它的大小必须大于它自身，并且要足够大到可以容纳到连接字符串str2

39、字符串&字符数组函数strupr(a)，将内容的所以小写字母改为大写，输入的参数是首地址

40、比较两个string字符串，两种方式，第一种方式是!= 、>= 、<=，第二种方式是用string类的成员函数compare()，C
++字符串中的内容区分大小写，大写字母不等于其小写字母，如下
if(str!=str2)
if(bool(compare_result=str3.compare(str1)))

41、查找string的某个元素，string类中有很多个成员函数，如下，还有很多未列举
(1)find(a,b)，从b位置开始从前往后查找字符a在当前字符串中的位置
(2)find_first_not_of(a,b)，从b位置开始从前往后查找字符a在当前字符串中第一个不匹配的位置
(3)find_first_of(a,b)，从b位置开始从前往后查找字符a在当前字符串中第一次出现的位置
(4)find_last_not_of(a,b)，从b位置开始从后往前查找字符a在当前字符串中第一个不匹配的位置
(5)find_last_of(a,b)，从b位置开始从后往前查找字符a在当前字符串中第一次出现的位置
(6)rfind(a,b)，从b位置开始从后往前查找字符a在当前字符串中的位置
string str = "asdf"; char ch = "sd"; str.rfind(ch);

42、使用成员函数检测string字符串是否非空，可以利用成员函数empty()实现，如果为空，返回布尔值true，反正返回false，string 变量名.empty()

43、获取string字符串的长度，C风格字符串利用函数strlen()获取长度，相应的string字符串运用成员函数length()获取其长度，格式如下：长度变量 = 字符串.length()

44、提取string字符串的子串，格式：子串变量=原字符串.substr(起始位置,子串长度)；

45、定义空字符串：string str = "";

46、C风格字符串相加可以利用strcat()来实现，在string字符串中可以利用运算符(+)来实现：
str1 = str2 + str3 ;
还可以利用成员函数append();即str1.append(ch)，可以连接字符数组也可连接字符串

47、string字符串与单字符相加，直接用 (+)

48、string成员函数replace(a,b,str)函数可以替换其中的字符，第一个参数是起始位置，第二个参数是替换的长度，第三个是要替上的字符串的首地址，格式：
string str1 = "Hello World";
string str2 = "C++";
str1.replace(6,5,str2);

49、数组指针本质是指针，而指针数组本质是数组，指针数组和数组指针的区别在于，指针数组的每个元素都是指针，而数组指针只有整个数组为指针
类型标识符 (*变量名)[个数]; //数组指针
类型标识符 *变量名[个数]; //指针数组			

50、用指针去修改const常量的值是行不通的

51、当用指针指向某一段内存时，事先并不知道需要申请多少，此时动态申请内存就显得很必要。C++有多个动态申请内存的方式，主要两种：
(1)malloc方式，这种动态申请内存方式需要包含头文件malloc.h
申请一维内存格式：
类型标志符 *变量名;
变量名 = (类型标志符*)malloc(sizeof(类型标志符)*数组大小);
释放内存格式：
free(变量名); 变量名 = NULL;
申请二维内存格式：
类型标志符 **变量名;
变量名 = (类型标志符**)malloc(sizeof(类型标志符*)*数组行大小);
for(int i=0;i<数组行大小;i++)
	变量名[i] = (类型标志符*)malloc(sizeof(类型标志符)*数组列大小);
释放内存格式：
free(变量名); 变量名 = NULL;
(2)new方式
申请一维内存格式：
类型标志符 *变量名;
变量名 = new 类型标志符[数组大小];
释放内存格式：
delete[] 变量名; 变量名 = NULL;
申请二维内存格式：
类型标志符 **变量名;
变量名 = new 类型标志符*[数组行大小];
for(int i=0;i<数组行大小;i++)
	变量名[i] = new 类型标志符[数组列大小];
释放内存格式：
delete[] 变量名; 变量名 = NULL;

52、指针有一个变量类型是void*，它可以指向任意类型的数据，即任意类型的指针都可以赋值给void*，但void*不可以赋值给其他类型的指针，除非采用强制类型转换。看074.cpp

53、在指针应用场合，&是取地址运算符，*是取该地址指向内存的内容，->是由指针直接取内存内容(一般用于指向结构体的指针：结构体指针变量->结构体成员变量)，就相当于(*指针名).成员变量

54、每种变量类型占用不同的字节大小，可以用一个字节的char类型来输出其他大于一个字节的变量按字节输出其内容，
int a = 12345;
for(int i=0;i<sizeof(int);i++)
	cout<<((char*)&a)[i]<<endl;

55、当用new和malloc函数动态申请内存时，最后需要释放指针和内存，但是在释放指针前必须先判断当前指针是否指向内存的首地址，如果没有则会导致程序崩溃，当指向内存块的指针已经超出其边界一定要将指针指回首地址，看077.cpp

56、以下三种情况会造成野指针：指针创建后没有初始化(解决方法是初始化为NULL或者指向合法的内存)；指针在使用free()和delete[]函数释放指向的内存时没有释放指针(在释放内存后也将将指针设为NULL)；指针的创建和操作不在同一个作用域中

57、函数的形参传值：void FUNCTION_NAME(int a,int b);传地址：void FUNCTION_NAME(int *a,int *b);

58、函数重载：如果两个函数名字相同，但是因为参数的类型不同，系统也会根据不同的要求调用不同的函数体

59、格式打印输出，主要依靠iomanip头文件，看087.cpp，整型可以按其他进制输出，浮点型可以用科学计数法、精度设置等等，字符串可以按照对齐输出

60、如果赋值的字符串大小小于字符数组的长度时会有0内存，造成内存的浪费，此时需要将0内存去掉，092.cpp

61、像这种 int* FUNCTION_NAME(xxx)，返回的是数组的首地址，意味着可以返回很多个值

62、如果要换行可以用'\'，即
string str[5] = {"asd","qer",\
		"xcv",\
		"ghj","wetr"};

63、第01行包含的头文件cctype.h用于函数isalpha()的使用，可以判断该元素是否为字母

64、 函数重载体现在多个函数名字必须相同，但是参数列表的内容不同，可以是数量或者参数类型不同，但是，如果在函数重载合法的情况下，数量的不同但多出的不同有默认值将会产生二义性，系统报错，函数重载的二义性发生在当参数类型相同、个数不一样时，由于参数默认值造成它们的参数实质一样

65、main()是所有程序的入口函数，但是在main()函数结束后还能再执行代码，此时需要在main()中注册函数，在main()的最后一行代码被执行完后，还能执行新的代码，先被注册的函数后执行。_onexit()可以注册函数，返回类型可以是int类型，如下
void add(){} 
void substract(){}
void main()
{ atexit(add);		//第三执行
  atexit(substract);	//第二执行
  cout<<"main"<<endl;	//第一执行
 }

66、递归函数是一直返回，直到不在调用自身即终止

67、随机生成小写字母：
lower_index = 1 + (int)(26.0 * rand() / (RAND_MAX + 1.0));
lower = char(lower_index + 96);
随机生成大写字母：
upper_index = 1 + (int)(26.0 * rand() / (RAND_MAX + 1.0));
upper = char(upper_index + 64);
生成随机数(0-9)：
num = 0 + (int)(9.0 * rand() / (RAND_MAX + 0.0));

68、main函数可以接收参数解释DOS命令，是在启动运行时传递参数的，格式分两种如下：
int main(int argc, char** argv);
int main(int argc, char* argv[]);

69、在一种循环事件内，若想自操作退出可以用bool类型来定义一个flag变量

70、不成文规定：类名字大写，类的定义必须在大括号后加分号，类只有在声明类对象才能被使用，类函数相关程序由110开始，编写类的时候有个技巧就是先定义private里面的参数

71、类的构造函数是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值，<1>作用：赋初值,初始化对象的数据成员,由编译器帮我们调用。<2>特点：①函数名和类名一样。②没有返回值。③支持有参/无参。④可以重载。 <3>调用时机：在类的对象创建时刻,编译器帮我们调用构造函数。

72、析构函数是当对象被销毁时被系统调用的方法，一般用来清空内存。<1>作用：用于释放资源。<2>特点：①和类名一样,不过得在前面加上~。②无参数,无返回值。③因为无参数,无返回值,所以不可以重载。④尽量不要自己调用析构函数,但是在某些需要的时候再调用。<3>调用时机：快退出函数的时候,编译器帮我们调用。

73、根据类中的定义的构造函数，可以声明类对象，并在声明对象时输入需要的参数，其带参数的构造函数输入参数赋值给类的私有成员变量

74、system("pause");暂停按下

75、如果不将运算符重载函数定义为类的友元函数，将不能访问其私有变量，友元函数是C++中的一种机制，它不属于类的成员函数，但是可以访问到类的私有变量，因此，它在一定程度上破坏了封装的特性。在一个类中用friend关键字修饰另一个类的声明，那么该类就是这个类的友元类。另外一个类可以访问本类的私有属性。

76、算符重载分为全局函数运算符重载和成员函数运算符重载。共分为三步：用operator关键字修饰要重载的运算符；确定返回值是对象、引用或是地址；全局运算符重载不含this指针这个参数，成员函数运算符重载含参，成员函数进行运算符重载的时候，如果是左操作数，只需要用this指针加以控制就可以了，友元函数对运算符重载的常见应用场景就是对<<和>>这样的运算符，因为cin对象和cout对象并没有暴露给你，所以只能采取友元这样的方式来实现想要的功能

77、运算符重载的意思是可以将对应的运算符号定义新的功能，看111.cpp

78、类的一个特征就是封装，public和private作用就是实现这一目的。所以：用户代码（类外）可以访问public成员而不能访问private成员；private成员只能由类成员（类内）和友元访问。类的另一个特征就是继承，protected的作用就是实现这一目的。所以：protected成员可以被派生类对象访问，不能被用户代码（类外）访问。有public，protected，private三种继承方式，它们相应地改变了基类成员的访问属性。
1.public继承：基类public成员，protected成员，private成员的访问属性在派生类中分别变成：public, protected, private
2.protected继承：基类public成员，protected成员，private成员的访问属性在派生类中分别变成：protected, protected, private
3.private继承：基类public成员，protected成员，private成员的访问属性在派生类中分别变成：private, private, private
但无论哪种继承方式，上面两点都没有改变：private成员只能被本类成员（类内）和友元访问，不能被派生类访问，protected成员可以被派生类访问。

79、类继承的实现可以节省很多代码量

80、类的多态性体现在当响应同一条消息时，结果却不一样，也即结果呈现多样性，类多态的应用存在于基类的指针指向子类的对象。

81、虚函数就是类的成员函数前面加上virtual关键字的函数。虚函数的作用就是为了实现多态性（Polymorphism），多态性是将接口与实现进行分离；用形象的语言来解释就是实现以共同的方法，但因个体差异而采用不同的策略。使用了virtual程序将根据引用或指针指向的类型来选择方法，如果没有使用virtual程序将根据指针类型或引用类型来选择方法。1.构造函数不能使虚函数。创建派生类对象时，将调用派生类的构造函数，而不是基类的构造函数，然后派生类的构造函数将调用基类的一个构造函数，这种顺序不同于继承机制。因此派生类不继承基类的构造函数，所以将类的构造函数声明为虚函数没有什么意义。2.友元函数不能是虚函数。友元函数不是类成员，而只有成员才能是虚函数。115.cpp和114.cpp构造虚函数的方式不同，115构造的是纯虚函数，而114构造的是虚成员函数。

82、基类属于抽象类时不能实例化，只能定义其指针和引用，实例化子类对象后对子类对象取址，然后调用基类的纯虚函数，响应不同的指令

83、当多继承出现二义性问题时，二义性现象可以通过虚继承避免，但在现实编程中很少用到多继承

84、双冒号(::)的用法，表示 “域操作符”，例如：声明了一个类A，在类A中声明一个成员函数void foo()，但没有在类A的声明中给出函数foo的定义，那么在类外定义foo时，就要写成void A::foo()表示foo()函数是类A的成员函数。表示引用成员函数和变量，作用域成员运算符，例如：System::Math::Sqrt()相当于System.Math.Sqrt()

85、判断三个坐标两条线段之间是否垂直可以用向量点乘法

86、在类中，全局变量的使用具有局限性，此时可以定义为静态数据成员实现多个对象间的数据共享，而类的静态变量初始化时需要在类外(即全局)，所谓共享，就是在同类的两个对象之间的静态变量共享内存，当某对象的静态变量发送改变，那么其他对象的相同静态变量也会受影响而改变

87、atoi函数是将字符串转化为整数

88、在类内部被声明又被定义的函数称为内联函数，它的应用是解决函数调用的效率问题，一般的调用函数，在进入被调用函数的地址前，先保护现场再转入函数地址，待被调用函数执行完后，转回先前的地址，恢复现场继续执行。而内联函数的使用是将该函数体直接放到当前执行地址，因此提高了效率。内联函数如果很小则可以提高效率。小功能的开销是因为小功能的执行时间小于切换时间。

89、内联函数具有以下优点：1）不会发生函数调用开销。2）当调用函数时，它还节省了推送/弹出变量在堆栈上的开销。3）它还节省了函数返回调用的开销。4）内联函数时，可以使编译器对函数体执行特定于上下文的优化。对于正常的函数调用，这种优化是不可能的。 通过考虑调用上下文和被调用上下文的流程，可以获得其他优化。5）对于嵌入式系统，内联函数可能很有用（如果它很小），因为内联可以产生比函数调用前导码和返回更少的代码。
内联功能缺点：1）来自内联函数的添加变量消耗额外的寄存器，如果要使用寄存器的变量数增加，则在内联函数之后，它们可能会在寄存器变量资源利用率上产生开销。这意味着当在函数调用点替换内联函数体时，函数使用的变量总数也会被插入。因此，用于变量的寄存器数量也将增加。因此，如果在函数内联变量数量大幅增加之后，它肯定会导致寄存器利用率的开销。2）如果使用太多的内联函数，那么二进制可执行文件的大小将会很大，因为相同代码的重复。3）太多的内联也会降低指令缓存命中率，从而降低从缓存内存到主内存的指令获取速度。4）如果有人更改了内联函数中的代码，则内联函数可能会增加编译时间开销，因此必须重新编译所有调用位置，因为编译器需要再次替换所有代码以反映更改，否则它将继续使用旧功能。5）内联函数可能对许多嵌入式系统没用。因为在嵌入式系统中，代码大小比速度更重要。6）内联函数可能会导致颠簸，因为内联可能会增加二进制可执行文件的大小。内存中的颠簸会导致计算机性能下降。

90、内联函数的行数不能太多，1-5行为宜，否则会有反效果

91、构造函数可以是两个：默认和带参数的
Line();			//默认构造函数
Line(int a=0,int b=0); 	//带参数的构造函数

92、每个类对象在实例化时都有一个this指针指向其数据的首地址，当类的非静态成员函数在访问非静态成员变量时，若遇到行参变量和成员变量相同，可以用this指针指向成员变量以示区别，当类中的非静态函数对与成员变量同名的变量进行操作时，切记用this指针标明该类的成员变量

93、复制构造函数从一个类对象复制到另一个对象

94、在先声明的时候用const为函数，它的意义在于不改变成员变量的值

95、在cstdlib或stdlib.h库中包含一个rand()函数，不接受任何参数而返回一个随机整数

96、4种访问名称空间std的方法：
1)using namespace std;在函数定义之前
2)using namespace std;在函数定义之中
3)using std::cout;放在特定的函数定义中
4)std::cout<<"xxx"直接使用

97、归根结底short是short int简称、long是long int的简称

98. 头文件climits定义了符号常量来表示类型的限制，例如int的最大值最小值等

99. #define是C语言常用的，const是C++常用的

100. 另外一种初始化的方法是Ｃ＋＋独有的： 
int a(321); 	// a = 321
也有：
int a{321};	// a = {321}
上述如果大括号为空则初始化为０

101、如果能对变量初始化就尽量初始化变量，将变量声明和赋值分开可能带来瞬间悬而未决的问题

102. short最大32767，unsigned short最大65535

103、int是计算机中最“自然”的语言，一般的整型就用它

104. 不同进制的书写均在计算机中被存储为二进制
int a = 42;	//十进制
int b = 042;	//八进制
int c = 0x42;	//十六进制
输出相应的进制：
cout<<a<<endl;
cout<<oct;
cout<<b<<endl;
cout<<hex<<c<<endl;

105. 如果程序中忽然出现一个未声明的数字，除非数值太大或有后缀说明，否则将被定义为ｉｎｔ

106. char类型打印字符：
cout.put(ch);
cout.put('!');
cout<<"!";
打印ASCII码：
cout<<'!';

107. 对于常规字符如字母标点符号数字等，最简单的方法就是将字符用单引号括起来,特殊符号需要转义

108.对于char类型可以是有符号也可以是无符号的,必要时可以显式表示
char x;
unsigned char x;	//0-225
signed char x;		//-128~127

109. 新增的类型
char16_t无符号长16bit
char32_t无符号长32bit

110.在布尔类型中,非零既为true,零为false,而布尔类型转换为int:true为1,false为0

111.创建常变量尽量进行初始化否则将出现很大问题,有以下几种通用约定:1)常变量首字母大写;2)常变量大写;3)常变量名字前加个k

112.对于除法若操作数有其中一个是浮点数,那么其运算结果也是浮点数

113.cout自动去除数字后面的零,为了不去掉可用以下方法:
cout.setf(ios_base::fixed, ios_base::floatfield)

114.数组之间不能相互赋值

115.控制计算位置数组元素个数可以用以下方法
int things[] = {1,2,3,4,6};
int num_elements = sizeof(things) / sizeof(int);

116.字符串结尾是'\0'，其ASCII码是0，用cout打印字符串时要注意其末尾是否加有'\0'，这是一种非常不实用的方法，因此用下：
char bird[11] = "Mr.A";		//这被称为字符串常量
这样初始化就隐式地包括了字符串结尾地空字符，要保证数组足够大包括起来
char的数组初始化也可以不用确定多少个字符
char first_data[] = {"bei hu"};	//等号可以省略

117.字符常量（单引号）可以当作是ASCII码的另一种形式，下面是将83赋给shirt_size：
char shirt_size = 'S';

118.用于检测字符数组的长度可以用如下：
#include <cstring>
const int size = 15;
char a[size] = "c++sdf";
cout<<strlen(a);
strlen()只是计算可见的字符

119.若想读取字符数组前面几个字符，可以在中间插入或改写'\0'，在用cout读取即可：
a[3] = '\0';
cout << a;   // c++

120.cin对输入的只能识别到空格前

121. 若输入有空格符的字符串，如New York，用getline()或get(),这两个是字符数组用的
这里是需要采用面向行而不是面向单词的方法，istream中的类（cin）提供了如此方法，这两个函数都是读取一行，直到有换行符
getline()丢弃换行符，get()保留换行符
推荐多用get(),因为老式的实现没有getline(),而且get()更容易检查出错误

121. getline()两个参数,第一个是用来存储输入行的数组的名称,第二个参数读取字符数,必须预留一个字符
cin.getline(name,20)
另外:
cin.getline(name1,20).getline(name2,20);其效果与两次调用cin.getline()一样

122. get()将换行符都保留在输入队列中,因此若有两个get(),第二个将首读到换行符,因此要:
cin.get(name,20);
cin.get();
cin.get(age,20);
或者:
cin.get(name,20).get();

123. 用cin>>直接输入也会将换行符保留在输入队列中,因此若后续要继续使用get或getline,必须要使用一个过度的get(),如:
( cin >> year ).get();
getline(name, 20);

124. 使用字符数组还有其他的技术方法,例如复制和拼接,但是要用以下c类型的头文件
#include <cstring>
strcpy(charr1,charr2); //copy charr2 to charr1
strcat(charr1,charr2); //charr2结尾charr1 
int len_of_charr = strlen(charr1); //obtain length

125. string类提供了将字符串作为一种数据类型的表示方法,要
#include <string>
using namespace std;
using是一条编译指令,string类定义隐藏了字符串的数组性质,如下:
string str1 = liang;
cout << "The third letter in " << str1 << " is " << str1[2];

126. string对象更方便更安全,可以将char数组视为一组用于存储一个字符串的char存储单元,而string类变量是一个表示字符串的实体

127. 特别方便的是string对象可以使用 + 和 += 来进行合并,而且string对象之间可以直接赋值,不必像字符数组那般特别技术,查看长度:
int len_of_str = str.size()

128. string类具有自动调整大小的功能,从而避免了字符数组容易出现的内存溢出的问题

129. string类的面向行的读取与字符数组的不一样,如下:
cin.getline(charr,20);
getline(cin,strr);

130. 定义完结构体后,声明结构变量时C++是可以省略关键字struct的,直接用结构体名称声明结构变量,而结构变量的初始化也可以用一次大括号完成

131. 可以使用赋值符号=将结构赋值给另一个同类型的结构,可以创建结构体数组

132. 共同体(union)能存储不同的数据格式,但只能同时存储其中一种,结构体是可以同时存储int\long\和double,而共同体只能存储int或long或double,共同体的长度为其最大成员的长度

133. 共同体的用途是节省内存,另外还有匿名共同体,其成员都是位于相同地址的变量,可以以下用处:
struct widget
{
	char brand[20];
	int type;
	union id
	{
		long id_num;
		char id_char[20];
	}id_val;
};
...
widget prize;
...
if(prize.type == 1)
	cin >> prize.id_val.id_num;
else
	cin >> prize.id_val.id_char;
########以下匿名共同体,id_num和id_char相同地址,被视为prize的两个成员而不需要中间标识符id_val
struct widget
{
	char brand[20];
	int type;
	union
	{
		long id_num;
		char id_char[20];
	};
};
...
widget prize;
...
if(prize.type == 1)
	cin >> prize.id_num;
else
	cin >> prize.id_char;

134. enum枚举创建了符号常量,如下:
enum spectrum {red, orange, yellow, green, blue, violet, indigo, ultraviolet}; //对应的整数值 0-7
spectrum band;
band = blue;	//枚举量只有等号赋值,而且赋值的内容被规定
或:
enum {red, orange, yellow, green, blue, violet, indigo, ultraviolet};
这情况是只打算使用常量,而不创建枚举类型的变量

135. 枚举的取值范围 C++ primer plus 4.6.2

136. 指针是一个变量,这个指针变量是存储变量的地址的,用取址符号可以(&)赋值,(*)是间接值或解除引用运算符,用于指针可以得到该地址处存储的值

137. 编译阶段决策\运行阶段决策

138. 可以在声明语句中初始化指针,被初始化的是指针,而不是它指向的值
int higgens = 5;
int * pt = &higgens;

139. C++创建指针时只会分配用来存储地址的内存,而不会分配用来存储指针所指向的数据的内存,为数据提供空间是一个独立的步骤
long * fellow;
*fellow = 2233;
这情况会很危险,2233将被存在地址2233上,一定要在对指针应用解除引用运算符(*)之前,将指针初始化为一个确定的适当的地址,这是关于指针使用的金科玉律

140. 指针描述的是位置,通常是整数,不能对指针进行操作,要将数字值作为地址来使用,应通过强制类型转换数字转换为适当的地址类型

141.在运行阶段为一个int值分配未命名的内存,并使用指针来访问这个值
1)关键字new
需要告诉new为哪种数据类型分配内存,new将找到一个长度合适的内存块并返回该内存块的地址,如
int *pn = new int;		//allocate memory with new
. . . 					//use the memory
delete pn;				//free memory with delete when done
备注:
delete只能用对应的new分配的指针内存
2)将变量的地址赋给指针
int higgens;
int *pt = &higgens;
在第二种情况下可以通过变量名称访问该int值,而第一种情况只能通过该指针进行访问
备注:
pn指向的内存没有名称,被称为数据对象,数据对象指的是为数据项分配的内存块,数据对象使程序在管理内存方面有更大的控制权
typeName * pointer_name = new typeName;
用来指定需要什么样的内存和用来声明合适的指针

142. 静态连编\动态连编,前者是编译时决策,后者是运行时决策,适用于大型数据:数组\字符串\结构

143. 创建动态数组要将数组的元素类型和元素数目告诉new,如下:
type_name * pointer_name = new type_name [num_elements];
int * psome = new int [10];
//new运算符返回地一个元素的地址
delete [] psome;
//	数组的元素读取:psome[0] \ psome[1] \ psome[2] \ ... \ psome[9]
//	psome指的是指向第一个元素的指针
//	psome = psome + 1; 指的是指针变量加一,将指向下一个元素的地址,即现在psome[0]的值是原来psome[1]的值,psome[1]是原来psome[2]
备注:
由上述可知将指针变量加一后,增加的量等于它指向的类型的字节数

144. 在数组和指针的应用中有一些技巧:
arrayname[i] becomes *(arrayname+i);		//valid
pointername[i] becomes *(pointername+i);	//valid
pointername = pointername + 1;			//valid
arrayname = arrayname + 1;			//not allowed

145. 允许指针和整数相加,加1的结果等于原来地址值加上指向的对象占用的总字节数,还可以将一个指针减去另一个指针获得两个指针的差,仅当两个指针指向同一个数组时,将得到两个元素的间隔

146. tacos[0] means *tacos; tacos[3] means *(tacos + 3);

147. 头文件cstring, strcpy(), strlen()

148. 如果指针的类型是char* , 则cout将显示指向的字符串,但要显示其地址,必须要强制转换为另一个指针类型,如(int *)

149. 在运行时创建数组和结构要优于在编译时创建，要用new，具体创建结构的语句如下：
structName *pointerName = new structName;
备注：
访问结构成员时需要有技巧，若是指针访问则：pointerName->member;
而用结构名称访问成员时直接用(.)号：structName.member;
注意*pointerName就是被指向的值，既结构本身，访问成员：(*pointerName).member;
最后的最后：
delete pointerName;

150. 头文件cstring,strcpy(字符串首地址1，字符串首地址2)；

151. 可以用以下方法输入:
char *name;
name = getname();
delete [] name;
char *getname()
{
    char temp[80];
    cout << "Enter last name: ";
    cin >> temp;
    char *pn = new char[strlen(temp)+1];
    strcpy(pn, temp);

    return pn;
}

152. 数组名是一个指针!!

153. 模板类vector\array\ ???

154. 通常cout在显示bool值之前将它们转换为int,既1和0,但cout.setf(ios::boolalpha)函数调用设置了一个标记,该标记命令接下来的cout均显示true和false

155. 头文件string ,string word; ,word.size() //这里包含了'\0'的字符数量

156. 前缀递增和前缀递减和解除引用运算符的优先级相同,以从右到左的方式进行结合,后缀递增和后缀递减的优先级相同,但比前缀运算符的优先级高,这两个运算符以从左到右的方式结合.
备注:
前缀运算符的从右到结合规则意味着*++pt:先++,后*
另一方面++*pt意味着:先*,后++
假设pt = &arr[2]; ,x = *pt++; x还是arr[2]的值,然而执行完操作后指针加一变arr[3]
后缀运算符一切都是先其他运行,最后自己运行

157. 逗号运算符可以将两个表达式合并为1个,可以在for循环的检测中 i++,j--等适用

158. 逗号运算符也是有顺序的,越前面越先计算,而逗号表达式的值是最后部分的值

159. cata = 17,240;	//最后为17, 抛弃240
cata = (17, 240);	//最后是240，抛弃17

160． 比较两个字符串是否相同存在难点，因为字符串牵引着地址，应使用Ｃ－风格字符串库中的strcmp()函数来比较
备注：
头文件strcmp(),
该函数接受两个字符串地址作为参数，
两个字符串相同，函数返回0，
第一个字符串按字母顺序排在第二个字符串之前，返回一个负值，
第一个字符串按字母顺序排在第二个字符串之后，返回一个正值，
用这样来判断：strcmp(str1, str2) == 0;

161. while循环体的测试条件一开始便false则不执行

162. 循环中的三个原则：指定循环终止条件;在首次测试之前初始化条件;在条件再次测试之前更新条件

163. do..while是至少执行一次，再判断能否跳出循环的测试条件

164. 基于范围的for循环：
备注:
1- 只能显示不能操作
double prices[5] = {12.2, 0.3, 3.6, 83.1, 1.9};
for(double x : prices)
	cout << x << endl;
2-　可以操作
for(double &x : prices)
	x = x * 0.8;

165. 选择停止标记符号：一种方法选择某个特殊的字符被称为哨兵字符(sentinel character)作为停止标记

166. 读取char值时，与读取其他基本类型一样，cin将忽略空格和换行符号，这里是字符而不是字符数组

167. 要读取输入的空格字符，可以cin.get(ch);这里

168. 许多操作系统都支持重定向，意味着允许用文件替换键盘输入，也允许通过键盘模拟文件尾条件

169. 检测到文件尾(EOF)条件后，cin将两位(eofbit和failbit)都设置为1,
通过cin.eof()来查看：若检测到EOF，则cin.eof()返回bool值true，否则返回false;
通过cin.fail()来查看：若检测到EOF，则cin.fail()返回bool值true，否则返回false;

170. 初始化二维数组：花括号里面用花括号

171.  头文件cctype，其中包含的函数的返回类型是int而不是bool，
备注：
用isalpha()检测字符是否为字母字符
用isdigits()检测字符是否为数字字符
用isspace()检测字符是否为空白
用ispunct()来检测字符是否为标点符号
...还有其他字符检测，可以查看头文件说明

172.  条件运算符(?:)是一个三操作数的来替代if else的运算符：
int c = a > b ? a : b;

173. switch(integer-expression)必须是一个结果为整数值的表达式，而case (标签)：
标签常见是int或char常量，也可以是枚举量，如果都没有则跳转到default
程序不会再执行到下一个case处自动停止，要让程序执行完一组特定语句后停止，必须使用break
switch语句将int值和枚举量标签进行比较时，将枚举量提升为int，另外while循环测试条件中也是
注意switch(xxx){}后不用
如果既可以使用if else if语句，也可以使用switch语句，则当选项不少于3个时，应使用switch语句，因为它跟高效
case标签都必须是一个单独的值，必须是整数（包括char），因此switch无法处理浮点数

174. bradk和continue语句
两者均可使程序跳过部分代码
在switch或循环中用break，使程序跳到（switch或循环部分之后）的语句处执行
在循环中用continue，让程序跳过这次循环中余下的代码，而重新一轮的循环

175. clear()方法重置错误输入标记，同时也重置文件尾EOF条件，错误的输入和EOF都将导致cin返回false

176. 
 int golf[MAX];
 ...
 /*以下是一段纠正错误输入的代码*/
 while(!(cin>>golf[i]))
 {
     cin.clear();    //reset input
     while(cin.get() != '\n' )
         continue;    //get rid of bad input
     cout << "Please enter a number : ";
 }
 因为错误的输入cin返回false，因此不会将任何值放到数组中，而进入了while循环
 该循环的第一条语句使用clear()方法重置输入，如果没有这个重置，程序将拒绝继续读取输入
 内部while用cin.get()来读取行尾之前的所有输入，从而删除这一行中的错误输入

177. 对于文本I/O使用cin输入时，程序将输入视为一系列的字节不管目标数据类型时什么，输入一开始都是字符数据--文本数据，每个字节都被解释为字符编码

178. 头文件fstream，for file I/O，这一个均支持输入和输出

179. 声明一个ofstream对象并将其同文件关联起来后便可以像使用cout那样使用它，总之，使用文件输出的主要步骤如下：
包含头文件fstream
创建一个ofstream对象		      //输出用的
将该ofsteam对象同一个文件关联起来	//这是新创建一个txt文件，it shoule be .txt
				   //如果有同名字的文件则覆盖，后续将可以修改“覆盖”这一操作，默认截短为0	
就像使用cout那样使用该ofstream对象

180. 示例如下，要求用户自己输入，显示到屏幕&将信息写入到文件
/*
    cout.precision(2);
    cout.setf(ios_base::showpoint);
    outFile.precision(2);
    outFile.setf(ios_base::showpoint);
    这两个方法都是一些格式方法，主要想说明outFile可以使用所有cout可使用的任何方法
*/
// outfile.cpp -- writing to a file
#include <iostream>
#include <fstream>                  // for file I/O

int main()
{
    using namespace std;

    char automobile[50];
    int year;
    double a_price;
    double d_price;

    ofstream outFile;               // create object for output
    outFile.open("carinfo.txt");    // associate with a file

    cout << "Enter the make and model of automobile: ";
    cin.getline(automobile, 50);
    cout << "Enter the model year: ";
    cin >> year;
    cout << "Enter the original asking price: ";
    cin >> a_price;
    d_price = 0.913 * a_price;

// display information on screen with cout

    cout << fixed;
    cout.precision(2);
    cout.setf(ios_base::showpoint);
    cout << "Make and model: " << automobile << endl;
    cout << "Year: " << year << endl;
    cout << "Was asking $" << a_price << endl;
    cout << "Now asking $" << d_price << endl;

// now do exact same things using outFile instead of cout

    outFile << fixed;
    outFile.precision(2);
    outFile.setf(ios_base::showpoint);
    outFile << "Make and model: " << automobile << endl;
    outFile << "Year: " << year << endl;
    outFile << "Was asking $" << a_price << endl;
    outFile << "Now asking $" << d_price << endl;
    
    outFile.close();                // done with file
    return 0;
}

181. 文件输入可以结合使用cin和eof()\fail()方法来判断输入是否成功，
对象cin本身被用作测试条件时，如果最后一个读取操作成功，它将被转换为布尔true，否则时false
声明一个ifstream对象并将其同文件关联起来后便可以像使用cin那样使用它，所有可用于cin的操作和方法都可用于ifstream对象

182. 试图打开一个不存在的文件用于输入会有很大的风险甚至出现错误，用以下的方法可以退出
#inclue <cstdlib>	//头文件主要用于exit()
istream inFile;
inFile.open("AFileNotExit.txt");
if( !inFile.is_open())
{
    cout << "Could not open the file " << endl;
    cout << "Program terminating.\n";
    exit(EXIT_FAILURE);
}

183. 
    ifstream inFile;
    inFile.open(filename.txt);
    /*
    留一段检测是否打开的代码
    */
    double value;
    double sum = 0.0;
    int count = 0;          // number of items read
    inFile >> value;        // get first value
    while (inFile.good())   // while input good and not at EOF
    {
        ++count;            // one more item read
        sum += value;       // calculate running total
        inFile >> value;    // get next value
    }
    if (inFile.eof())
        cout << "End of file reached.\n";
    else if (inFile.fail())
        cout << "Input terminated by data mismatch.\n";
    else
        cout << "Input terminated for unknown reason.\n";
备注：
最后一次读取数据时遇到EOF，方法eof()返回true，是真的最后，不是每行的最后
如果最后读取发生意外/EOF时，good()将不再是true

184. 函数体结果的类型必须是函数定义时的类型或可以被转换为函数定义时的类型

185. 函数原型指的是在程序开头定义函数的语句，因为它提供了程序的整体结构，也是C++的编程风格,可以帮助编译器纠错

186. 函数原型是一条语句，因此必须以(;)结束，
最简单的方法就是复制函数定义的函数头并添加分号:
double cube(double x);
另外函数原型也可以省略掉变量名，只要类型列表就可以了
double cube(double,double);

187. 对于函数的参数，普通的参数在mian()中定义了之后传到函数结构中，两者是不同的，函数结构只是main()中数据的副本，因此函数再怎么弄都不影响main()

188. 方括号指出arr是一个数组，而方括号为空则表明是一个指针，因此在编写函数其他部分时可以当作数组和指针使用，它的意思是把数组的首个元素的地址传进给函数，这不就是指针吗？
int sum_arr(int arr[], int n);
sum_arr()函数将mian()的数组的地址赋给指针变量arr，将arrSize赋给n，意味着
将数组的位置（地址）、包含的元素种类（类型）以及元素的数目（n变量）提交给函数，函数使用的是原来的数组，而不是拷贝

189. 理解以下两个等式即可
arr[i] == *(ar + i);
&arr[i] == ar + i;

190. 一种输入出错退出程序的方法：
cin >> temp;
if (!cin)	// bad input
{
    cin.clear();
    while (cin.get() != '\n')
        continue;
    cout << "Bad input; input process terminated. \n";
    break;
}

191. 为了避免函数修改数组的内容，可以再声明形参时使用关键字const
void show_array(const double ar[], int n);
备注：
意味着不能使用ar修改该数据，但能够使用ar[0]这样的值
原始的数组不一定是常量
show_array()对于ar只是只读

192. const与指针，一般有两种方式
第一种方法是让指针指向一个常量对象，这样可以防止使用该指针来修改所指向的值
第二种方法是将指针本身声明为常量，防止改变指针指向的位置
-------------------------
将常规变量的地址赋给指向const的指针：可行
int age = 39;
const int *pt = &age;
不能使用pt来修改这个值，意思是*pt为const，不能修改，但pt是可变的，可以重新指向其他变量，就是第二种
-------------------------
将const变量的地址赋给指向const的指针：可行
const float g_earth = 9.80;
const float *pe = &g_earth;
-------------------------
将const的地址赋给常规指针：不行
const float g_moon = 1.63;
float *pm = &g_moon;
因为为了避免pm修改g_moon

192. 以下：
int data[3][4] = {{1,2,3,4},{4,5,6,7},{3,6,9,8}};
int total = sum(data, 3);
total是一个函数，sum()的原型中的data应该是指向由4个int组成的数组的指针，因为第一维是第二维数组的地址（指针），因此：
int sum(int (*ar2)[4], int size);  
或
int sum(int ar2[][4], int size);
以上两种都是ar2是指针，不是数组，指向由4个int组成的数组，因而指针类型指定了列数

193. 以下是将声明一个由4个指向int的指针组成的数组，而不是由一个指向4个int的数组的指针
int *ar2[4];	//指针的数组，函数的参数不能是数组
int (*ar2)[4];	//数组的指针

194. 假设要将字符串作为参数传递给函数，则表示字符串的方式有三种：
char数组；用引号括起来的字符串常量；被设置为字符串的地址的char指针
以上都是char指针（char*）
将字符串作为参数来传递的实际是字符串第一个字符的地址，因此，字符串函数原型应将其表示字符串的形参声明为char*类型

195. 要编写一个返回字符串的函数，它是无法返回一个字符串的，但可以返回字符串的地址

196. 函数参数是某一个结构时，函数将使用原始结构的副本，按值传递给结构，
与数组名代表数组第一个元素的地址不同的是，结构名只是结构的名称，要获得其地址必须使用(&)

197. 运用数学库中的函数，头文件cmath
计算开方：distance = sqrt(x*x + y*y);
计算角度：angle = atan2(y,x);

198. cin可以作为测试表达式，它将根据输入的成功与否返回布尔值，例如：
while(cin>>num1)，cin期望用户输入一个数字，如果用户输入了q，cin>>将知道q不是数字，从而将q留在输入队列中，并返回一个将被转换为false的值导致循环结束

199. “若要传递结构的地址而不是整个结构以节省时间和空间”，这句话的意思是，传结构的地址到函数时利用的参时是原本的实质的结构，
而单单传递结构值给函数时是函数元素的副本，传递前需要时间和空间去创建，
三个地方：
调用函数时把结构地址传递给函数；
将形参声明为指向结构名称的指针，优于函数不修改结构因此使用const修饰符；
由于形参是指针而不是结构，因此用(->)而不是(.)
如下：
void show_polar(const polar *pda)
{
    using namespace std;
    const double Rad_to_Deg = 57.29577951;
    cout << "distance = " << pda->distance;
    cout << ", angle = " << pda->angle * Rad_to_Deg;
}

200. 二维char数组不如用一维string数组，同样可以当作普通数组传递给函数，若不想被函数修改，在传递地址参数时加const便可
void show_string(const string sa[], int n);
别忘记了string的读取：
string list[SIZE];
getline(cin,list[i]);

201. 递归，自己调用自己

202. 函数也有地址，函数地址对用户没什么用，对程序却很有用：
可以编写将另一个函数的地址作为参数的函数，这样第一个函数将能够找到第二个函数并运行之；
相比于直接调用，这是笨拙的方法，但它允许在不同的时间传递不同函数的地址，可以在不同的时间使用不同的函数

203. 获取函数的地址很简单：只要使用函数名（后面不跟参数）即可：
think()是一个函数，或者说是该函数的返回值，那么，think就是这个函数的地址

204. 声明指向函数的指针时，也必须指定指针指向的函数类型，既声明应指定函数的返回类型以及函数的参数列表（特征标）：
函数原型：
double pam(int);
则正确的指针类型声明：
double (*pf)(int);
pf = pam;	//把函数地址赋给指针
说明：
//技巧：这里把int用括号括起来可以看作是函数的参数列表，就可以联想到函数
double *pf(int);	//意味着pf()是一个返回指针的函数
double (*pf)(int);	//意味着pf是一个指向函数的指针
double x = pam(5);
double y = (*pf)(5);	//通过函数指针来调用函数，结果x=y
//--------
实际上也可以用以下：
double z = pf(5);	//z = y = x
备注：
第一，由于pf是函数指针，而*pf是函数，因此可以(*pf)()当函数调用
第二，由于函数名是指向该函数的指针（就是一般的函数名字就是该函数的地址），指向该函数的指针的行为应该与函数名相似，因此可以pf()当函数调用

205. 当某个函数要用地址来调用另一个函数时，可以用以下原型：
void estimate(int lines, double (*pf)(int));
备注：
第二个参数是函数指针，它指向的函数接受一个int参数，返回一个double值；
运用estimate函数：estimate(50, pam);

206. 假设要声一个指针指向某一个函数，只需要将目标函数原型中的函数名替换为(*pf)指针名字

207. 内联函数的使用：编译器将使用相应的函数代码替换函数调用，使程序无需跳动执行，比常规函数稍快，代价是需要占用更多内存，内联函数不能递归

208. 使用内联函数的做法是：通常是省略函数原型，将整个函数定义放在本该提供原型的地方，在函数定义前加上关键字：inline

209. (&)的另一个作用是引用，可以理解为让一个变量拥有别名，其实是同样的东西，如下：
int rats;
int & rodents = rats;
备注：
上述是引用声明，允许将rats和rodents互换--包括指向相同的值和内存单元，将rodents的类型声明为int&，即指向int变量的引用
引用的典型用法是作为函数的参数，这里只是普通的使用基础
引用在声明时就必须初始化，这和指针不同

210. 引用传递：函数中的变量名称为调用程序中的变量的别名，如下：
----按值传递----
void sneezy(int x);
int main()
{
    int times = 20;
    sneezy(times);
    ...
}
void sneezy(int x)
{...}
----引用传递----
void sneezy(int x);
int main()
{
    int times = 20;
    sneezy(times);
    ...
}
void sneezy(int &x)
{...}
备注：
按值传递是两个变量两个名称，而引用传递是一个变量两个名称
用引用传递时只能传递变量，不能传递表达式：
sneezy(times);		//it's okay
sneezy(times+5);	//it's not okay

211. 在使用引用参数声明的函数时，应在函数的参数声明时尽可能使用const（如果不修改参数的值的话），如下
double refcube(const double &ra)

212. 以下返回的是一个整形引用
int & accmulate(int & target, const int & source);

213. 将类对象传递给函数时，C++通常的做法是使用引用，例如可以通过使用引用让函数将类string\ostream\istream\ofstream\ifstream等类的对象作为参数

214. ostream是基类，而ofstream是派生类，派生类继承了基类的方法，这意味着ofstream对象可以使用基类的特性，如格式化方法precision()和setf()

215. 继承的另一个特性是，基类引用可以指向派生类对象，而无需进行强制类型转换

216. 使用引用参数的主要原因：
1）希望能够修改调用函数中的数据对象；
2）通过传递引用而不是整个数据对象，可以提高程序的运行速度；
当数据对象较大时（如结构和类对象）第二个原因很重要，这些也是使用指针参数的原因

217. 使用引用、使用指针、使用按值传递的原则：
1）如果数据对象很小，如内置数据类型或小型结构，则按值传递；
2）如果数据对象时数组，则使用指针，因为这是唯一选择，并将指针声明为指向const的指针；
3）如果数据对象是较大的结构，则使用const指针或const引用，以提高程序的效率，节省复制结构的时间和空间
4）如果数据对象是类对象，则使用const引用，类设计的语义常常要求使用引用，传递类对象参数的标准方式是按引用传递
=====对于修改调用函数中数据的函数=====
5）如果数据对象是内置数据类型，则使用指针
6）如果数据对象是数组，则只能使用指针
7）如果数据对象是结构，则使用引用或指针
8）如果数据对象是类对象，则使用引用

218. 设置函数的默认参数必须通过函数原型，将默认值赋给原型中的参数，有了原型的默认就不需要在函数定义里的参数列表再次添加

219. 对于带参数列表的函数必须从右向左添加默认值，也就是说，要为某个参数设置默认值则必须为它右边的所有参数提供默认值：
在设计类时通过使用默认参数可以减少要定义的析构函数、方法以及方法重载的数量

220. 函数多态（函数重载）可以使用多个同名的函数，常用：同名函数完成相同的工作但使用不同的参数列表，程序可以根据函数的参数列表（也称为函数特征标）来判断
因此：
虽然函数重载方便但不能滥用，
仅当函数基本上执行相同的任务但使用不同的数据时才应采用函数重载

221. 函数模板时通用的函数描述，其中的泛型可用具体的类型（如int或double）替换，通过将类型作为参数传递给模板可使编译器生成该类型的函数
例如：
template <typename AnyType>
void Swap(AnyType &a, AnyType & b)
{
    AnyType temp;
    temp = a;
    a = b;
    b = temp;
}
备注：
关键字template 和 typename 是必须的，除非可以使用关键字class代替typename，不过它们两个是等价的，没有区别，跟类没有关系；
AnyType是通用类型的临时命名；
必须用尖括号；
并非所有的模板参数都必须是模板参数类型，可以是具体类型：
template <typename AnyType>
void(AnyType a, AnyType b, int c);

222. 如果需要多个将同一种算法用于不同类型的函数则需要用到模板，尽量用typename，函数原型的声明：
template <typename AnyType>		//不可缺少
void Swap(AnyType &a, AnyType &b);
用的时候直接调用参数：
int x=1; int y=2; Swap(x,y);
double x=1.2; double y=2.5; Swap(x,y);

223. 有重载函数当然也有重载的模板

224. 别忘了数组之间不能直接赋值，而结构间可以直接赋值，这也是模板的限制

225. 显式具体化包含所需的代码，当编译器找到与函数调用匹配的具体化定义时将不再寻找模板，备注：
-对于给定的函数名可以有非模板函数、模板函数、和显式具体化模板函数以及它们的重载函数；
-显式具体化的原型和定义应以template<>开头，并通过名称来指出类型；
-非模板函数最优，具体化次之，常规模板最后
-在声明中使用前缀template和template<>以区分显式实例化和显式具体化
---
void Swap(job &, job &);
---
template <> void Swap<job>(job &, job &);	//<job>是可选的
template <> void Swap(job &, job &);		//与上式是等效的
---
template<typename T>
void Swap(T &, T &);
---

226. 头文件中常包含的内容：
函数原型；使用#define或const定义的符号常量；结构声明；类声明；模板声明；内联函数

227. 包含自己的头文件时，应使用引号而不是尖括号

228. 
#ifndef COORDIN_H_
#define COORDIN_H_
//...place include file contents here
#endif

229. 代码块中的变量在程序执行到此处时才被分配内存，代码块被程序执行完时，变量的内存将被回收，就是：
代码块内的变量只能在此代码块内使用

230. 如果没有显式地初始化静态变量，编译器将把它设置为0

231. 在每个使用外部变量地文件中都必须声明之，变量只能有一次定义（定义或声明），定义给变量分配存储空间，声明不给变量分配存储空间
注意引用声明时要使用关键字extern且不能初始化，否则声明为定义，导致分配存储空间

232. C++为静态变量提供了3种连接性：外部连接性（可在其他文件中访问）、内部连接性（只能在当前文件中访问）和无连接性（只能在当前函数或代码块中访问）
它们在整个程序的执行期间存在，与自动变量相比它们的寿命更长

233. 程序中的自动变量用栈来临时存储，后进先出

234. 静态变量如果没有被显式初始化，那么程序会自动将它们初始化为0

235. 按需创建静态变量：（9.2.3静态持续变量）
外部连接性：在代码块的外面声明它
内部连接性：在代码块的外面声明它，并使用static限定符
无连接性：在代码块内声明它，并使用static限定符

236. 如果要在多个文件中使用外部变量，只需要在一个文件中包含该变量的定义，但在使用该变量的其他文件中都必须使用关键字extern来声明之

237. C++不允许在一个函数中顶一个另一个函数，因此所有函数的存储持续性都自动为静态的，整个程序执行期间都在
默认下：
函数的连接性是外部的，既可以文件共享，实际可以在函数的原型中使用关键字extern来指出函数是在另一个文件中定义的
还可以使用static将函数的连接性设置为内部，只能在一个文件中使用，必须同时在原型和函数定义中使用static关键字

238. 初始化动态分类，单值可以用括号，其他的结构或者数组要用大括号，那么就推荐用大括号吧
int *pi = new int {6};
int *pi = new int (6);
int *ar = new int [4] {1,2,3,4};
struct where {double x; double y; double z;};
where *one = new where {1.2, 3.4, 4.5};

239. 以下是配对的函数：
分配函数（alloction function）：
void *operator new(std::size_t);
void *operator new[](std::size_t);
释放函数（deallocation function）：
void operator delete(void *);
void operator delete[](void *);
std::size_t是一个typedef，对应于合适的在整形

240. 可以通过定义一种新的声明区域来创建命名的名称空间，这样做的目的之一是提供一个声明名称的区域，
在这里，一个名称空间中的名称不会与另外一个名称空间的相同名称发生冲突，同时允许程序的其他部分使用该名称空间中声明的东西
备注：
1）名称空间可以是全局的，也可以是另一个名称空间中的，但不能位于代码块中
2）默认情况下在名称空间声明的名称的连接性为外部的（除非它引用了常量）
3）全局名称空间（global namespace）对应于文件级声明区域
4）任何名称空间中的名称都不会与其他名称空间中的名称发生冲突，如下面的fetch()函数和pal变量：
namespace Jack{
    double pail;
    void fetch();
    int pal;
    struct Well { ... }; 
}
namespace Jill{
    double bucket(double n) { ... }
    void fetch();
    int pal;
    struct Hill { ... }; 
}
5）名称空间是开放的（open）既可以把名称加入到已有的名称空间中，如下：
namespace Jill{
    char * goose(const char *);
}
6）在原来地名称空间如果已经声明了函数原型，那么可以在该名称空间中再次使用来提供该函数的代码
7）使用作用域解析运算符::使用名称空间中的名称
8）可以使用using声明使用特定的标识符，如下
using Jill::pal;
可以使用名称pal来替代Jill::fetch
9）using编译指令使所有的名称都可用，如下
using namespace Jack;
但是要小心可能不同的名称空间存在相同的名称
10）名称空间的定义中可以发生嵌套，也可以在一个名称空间中声明另一个名称空间：在一个，名称空间中使用using namespace xxx;

241. 一般利用名称空间的使用技巧：程序9.11\9.12\9.13
一个文件写名称空间：namesp.h
一个文件写名称空间中的函数的具体实现：namesp.cpp // 要#include"namesp.h"
一个文件写main：namessp.cpp

242. 命名空间硬核使用技巧：
1）使用在已命名的名称空间中声明的变量而不是使用外部全局变量，也不是使用静态全局变量；
2）如果开发一个函数库或类库，将其放在一个名称空间中
3）仅将编译指令using作为一种将旧代码转换为使用名称空的权宜之计 	//既using namespace xxx;
4）不要再头文件使用using编译指令
5）导入名称时，首选使用作用解析运算符或using声明方法
6）对于using声明，首选将其作用域设置为局部而不是全局

243. 面向对象编程的特性（OOP）：抽象、封装和数据隐藏、多态、继承、代码的可重用性
OOP编程与过程性编程有差异

244. 处理复杂性的方法之一是简化和抽象，类是一种将抽象转换为用户定义类型的C++工具，它将数据表示和操纵数据的方法组合成一个整洁的包

245. 类规范有两个方面：类声明（类蓝图）和类方法定义（类细节）

246. 交互系统由类对象组成，而接口由编写类的人提供的方法组成（.xxx），接口让程序员能够编写与类对象交互的代码，从而让程序能够使用类对象，
方法就像接口；对象就像实时的一个数据；类就像一个包

247. 如果更人性化：不要将使用类的程序视为公共用户，而将编写程序的人视为公共用户，要使用某个类，必须了解其公共接口，要编写类，必须创建其公共接口

248. 通常将接口（类的定义）放在头文件中，将实现（类方法的代码）方在源代码文件中，不成文的规定：将类的的名称的首字母大写

249. 别忘记了：
#include <string>
std::string company;

250. 类成员可以是数据类型变量也可以是函数，通常将变量的声明放在类的private，函数的原型比较少放在private，比较多是放在public

251. 类的定义完成后千万不要忘记了分号结尾
class Stock
{
private:
    ...
public:
    ...
};

252. 使用类对象的程序都可以直接访问共有部分，但只能通过共有成员函数（或友元函数）来访问对象的私有成员，
要修改类的private成员，只能通过public的函数修改，
公有成员函数是程序和对象的私有成员之间的桥梁，提供了对象和程序之间的接口

253. 类的设计尽可能将公有接口与现实细节分开，公有接口表示设计的抽象组件，
封装：
将实现细节放在一起并将它们与抽象分开；
数据隐藏（将数据放在private）
将实现的细节隐藏再私有部分；
将类函数的定义和类的声明放在不同的文件中；

254. 如果省略关键字private，那么类中的声明认是private，当然还是用显式的比较好

255. 创建类描述的第二部分：为那些由类声明中的原型表示的成员函数提供代码，就是提供函数的实现细节
成员函数的定义：函数头、函数体、可以有返回类型和参数，另外还有两个特征：
定义成员函数时，使用作用域解析运算符（::）来标识函数所属的类；
类方法可以访问private组件，就是定义的类的成员函数可以访问私有成员；




































